"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/path-to-regexp@6.1.0/node_modules/path-to-regexp/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/path-to-regexp@6.1.0/node_modules/path-to-regexp/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function lexer(str) {
      var tokens = [];
      var i = 0;
      while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
          tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
          continue;
        }
        if (char === "\\") {
          tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
          continue;
        }
        if (char === "{") {
          tokens.push({ type: "OPEN", index: i, value: str[i++] });
          continue;
        }
        if (char === "}") {
          tokens.push({ type: "CLOSE", index: i, value: str[i++] });
          continue;
        }
        if (char === ":") {
          var name = "";
          var j = i + 1;
          while (j < str.length) {
            var code = str.charCodeAt(j);
            if (
              // `0-9`
              code >= 48 && code <= 57 || // `A-Z`
              code >= 65 && code <= 90 || // `a-z`
              code >= 97 && code <= 122 || // `_`
              code === 95
            ) {
              name += str[j++];
              continue;
            }
            break;
          }
          if (!name)
            throw new TypeError("Missing parameter name at " + i);
          tokens.push({ type: "NAME", index: i, value: name });
          i = j;
          continue;
        }
        if (char === "(") {
          var count = 1;
          var pattern = "";
          var j = i + 1;
          if (str[j] === "?") {
            throw new TypeError('Pattern cannot start with "?" at ' + j);
          }
          while (j < str.length) {
            if (str[j] === "\\") {
              pattern += str[j++] + str[j++];
              continue;
            }
            if (str[j] === ")") {
              count--;
              if (count === 0) {
                j++;
                break;
              }
            } else if (str[j] === "(") {
              count++;
              if (str[j + 1] !== "?") {
                throw new TypeError("Capturing groups are not allowed at " + j);
              }
            }
            pattern += str[j++];
          }
          if (count)
            throw new TypeError("Unbalanced pattern at " + i);
          if (!pattern)
            throw new TypeError("Missing pattern at " + i);
          tokens.push({ type: "PATTERN", index: i, value: pattern });
          i = j;
          continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
      }
      tokens.push({ type: "END", index: i, value: "" });
      return tokens;
    }
    function parse(str, options) {
      if (options === void 0) {
        options = {};
      }
      var tokens = lexer(str);
      var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
      var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
      var result = [];
      var key = 0;
      var i = 0;
      var path5 = "";
      var tryConsume = function(type) {
        if (i < tokens.length && tokens[i].type === type)
          return tokens[i++].value;
      };
      var mustConsume = function(type) {
        var value2 = tryConsume(type);
        if (value2 !== void 0)
          return value2;
        var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
      };
      var consumeText = function() {
        var result2 = "";
        var value2;
        while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
          result2 += value2;
        }
        return result2;
      };
      while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
          var prefix = char || "";
          if (prefixes.indexOf(prefix) === -1) {
            path5 += prefix;
            prefix = "";
          }
          if (path5) {
            result.push(path5);
            path5 = "";
          }
          result.push({
            name: name || key++,
            prefix,
            suffix: "",
            pattern: pattern || defaultPattern,
            modifier: tryConsume("MODIFIER") || ""
          });
          continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
          path5 += value;
          continue;
        }
        if (path5) {
          result.push(path5);
          path5 = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
          var prefix = consumeText();
          var name_1 = tryConsume("NAME") || "";
          var pattern_1 = tryConsume("PATTERN") || "";
          var suffix = consumeText();
          mustConsume("CLOSE");
          result.push({
            name: name_1 || (pattern_1 ? key++ : ""),
            pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
            prefix,
            suffix,
            modifier: tryConsume("MODIFIER") || ""
          });
          continue;
        }
        mustConsume("END");
      }
      return result;
    }
    exports.parse = parse;
    function compile(str, options) {
      return tokensToFunction(parse(str, options), options);
    }
    exports.compile = compile;
    function tokensToFunction(tokens, options) {
      if (options === void 0) {
        options = {};
      }
      var reFlags = flags(options);
      var _a = options.encode, encode = _a === void 0 ? function(x) {
        return x;
      } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
      var matches = tokens.map(function(token) {
        if (typeof token === "object") {
          return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
      });
      return function(data) {
        var path5 = "";
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (typeof token === "string") {
            path5 += token;
            continue;
          }
          var value = data ? data[token.name] : void 0;
          var optional = token.modifier === "?" || token.modifier === "*";
          var repeat = token.modifier === "*" || token.modifier === "+";
          if (Array.isArray(value)) {
            if (!repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but got an array');
            }
            if (value.length === 0) {
              if (optional)
                continue;
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }
            for (var j = 0; j < value.length; j++) {
              var segment = encode(value[j], token);
              if (validate && !matches[i].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
              }
              path5 += token.prefix + segment + token.suffix;
            }
            continue;
          }
          if (typeof value === "string" || typeof value === "number") {
            var segment = encode(String(value), token);
            if (validate && !matches[i].test(segment)) {
              throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
            }
            path5 += token.prefix + segment + token.suffix;
            continue;
          }
          if (optional)
            continue;
          var typeOfMessage = repeat ? "an array" : "a string";
          throw new TypeError('Expected "' + token.name + '" to be ' + typeOfMessage);
        }
        return path5;
      };
    }
    exports.tokensToFunction = tokensToFunction;
    function match(str, options) {
      var keys = [];
      var re = pathToRegexp(str, keys, options);
      return regexpToFunction(re, keys, options);
    }
    exports.match = match;
    function regexpToFunction(re, keys, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.decode, decode = _a === void 0 ? function(x) {
        return x;
      } : _a;
      return function(pathname) {
        var m = re.exec(pathname);
        if (!m)
          return false;
        var path5 = m[0], index = m.index;
        var params = /* @__PURE__ */ Object.create(null);
        var _loop_1 = function(i2) {
          if (m[i2] === void 0)
            return "continue";
          var key = keys[i2 - 1];
          if (key.modifier === "*" || key.modifier === "+") {
            params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
              return decode(value, key);
            });
          } else {
            params[key.name] = decode(m[i2], key);
          }
        };
        for (var i = 1; i < m.length; i++) {
          _loop_1(i);
        }
        return { path: path5, index, params };
      };
    }
    exports.regexpToFunction = regexpToFunction;
    function escapeString(str) {
      return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    function flags(options) {
      return options && options.sensitive ? "" : "i";
    }
    function regexpToRegexp(path5, keys) {
      if (!keys)
        return path5;
      var groups = path5.source.match(/\((?!\?)/g);
      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
          });
        }
      }
      return path5;
    }
    function arrayToRegexp(paths, keys, options) {
      var parts = paths.map(function(path5) {
        return pathToRegexp(path5, keys, options).source;
      });
      return new RegExp("(?:" + parts.join("|") + ")", flags(options));
    }
    function stringToRegexp(path5, keys, options) {
      return tokensToRegexp(parse(path5, options), keys, options);
    }
    function tokensToRegexp(tokens, keys, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
        return x;
      } : _d;
      var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
      var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
      var route = start ? "^" : "";
      for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
          route += escapeString(encode(token));
        } else {
          var prefix = escapeString(encode(token.prefix));
          var suffix = escapeString(encode(token.suffix));
          if (token.pattern) {
            if (keys)
              keys.push(token);
            if (prefix || suffix) {
              if (token.modifier === "+" || token.modifier === "*") {
                var mod = token.modifier === "*" ? "?" : "";
                route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
              } else {
                route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
              }
            } else {
              route += "(" + token.pattern + ")" + token.modifier;
            }
          } else {
            route += "(?:" + prefix + suffix + ")" + token.modifier;
          }
        }
      }
      if (end) {
        if (!strict)
          route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
      } else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : (
          // tslint:disable-next-line
          endToken === void 0
        );
        if (!strict) {
          route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
          route += "(?=" + delimiter + "|" + endsWith + ")";
        }
      }
      return new RegExp(route, flags(options));
    }
    exports.tokensToRegexp = tokensToRegexp;
    function pathToRegexp(path5, keys, options) {
      if (path5 instanceof RegExp)
        return regexpToRegexp(path5, keys);
      if (Array.isArray(path5))
        return arrayToRegexp(path5, keys, options);
      return stringToRegexp(path5, keys, options);
    }
    exports.pathToRegexp = pathToRegexp;
  }
});

// ../routing-utils/dist/superstatic.js
var require_superstatic = __commonJS({
  "../routing-utils/dist/superstatic.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var superstatic_exports = {};
    __export2(superstatic_exports, {
      collectHasSegments: () => collectHasSegments,
      convertCleanUrls: () => convertCleanUrls,
      convertHeaders: () => convertHeaders2,
      convertRedirects: () => convertRedirects2,
      convertRewrites: () => convertRewrites2,
      convertTrailingSlash: () => convertTrailingSlash,
      getCleanUrls: () => getCleanUrls,
      sourceToRegex: () => sourceToRegex
    });
    module2.exports = __toCommonJS2(superstatic_exports);
    var import_url3 = require("url");
    var import_path_to_regexp = require_dist();
    var UN_NAMED_SEGMENT = "__UN_NAMED_SEGMENT__";
    function getCleanUrls(filePaths) {
      const htmlFiles = filePaths.map(toRoute).filter((f) => f.endsWith(".html")).map((f) => ({
        html: f,
        clean: f.slice(0, -5)
      }));
      return htmlFiles;
    }
    function convertCleanUrls(cleanUrls, trailingSlash, status = 308) {
      const routes = [];
      if (cleanUrls) {
        const loc = trailingSlash ? "/$1/" : "/$1";
        routes.push({
          src: "^/(?:(.+)/)?index(?:\\.html)?/?$",
          headers: { Location: loc },
          status
        });
        routes.push({
          src: "^/(.*)\\.html/?$",
          headers: { Location: loc },
          status
        });
      }
      return routes;
    }
    function convertRedirects2(redirects, defaultStatus = 308) {
      return redirects.map((r) => {
        const { src, segments } = sourceToRegex(r.source);
        const hasSegments = collectHasSegments(r.has);
        normalizeHasKeys(r.has);
        normalizeHasKeys(r.missing);
        try {
          const loc = replaceSegments(segments, hasSegments, r.destination, true);
          let status;
          if (typeof r.permanent === "boolean") {
            status = r.permanent ? 308 : 307;
          } else if (r.statusCode) {
            status = r.statusCode;
          } else {
            status = defaultStatus;
          }
          const route = {
            src,
            headers: { Location: loc },
            status
          };
          if (r.has) {
            route.has = r.has;
          }
          if (r.missing) {
            route.missing = r.missing;
          }
          return route;
        } catch (e) {
          throw new Error(`Failed to parse redirect: ${JSON.stringify(r)}`);
        }
      });
    }
    function convertRewrites2(rewrites, internalParamNames) {
      return rewrites.map((r) => {
        const { src, segments } = sourceToRegex(r.source);
        const hasSegments = collectHasSegments(r.has);
        normalizeHasKeys(r.has);
        normalizeHasKeys(r.missing);
        try {
          const dest = replaceSegments(
            segments,
            hasSegments,
            r.destination,
            false,
            internalParamNames
          );
          const route = { src, dest, check: true };
          if (r.has) {
            route.has = r.has;
          }
          if (r.missing) {
            route.missing = r.missing;
          }
          if (r.statusCode) {
            route.status = r.statusCode;
          }
          return route;
        } catch (e) {
          throw new Error(`Failed to parse rewrite: ${JSON.stringify(r)}`);
        }
      });
    }
    function convertHeaders2(headers) {
      return headers.map((h) => {
        const obj = {};
        const { src, segments } = sourceToRegex(h.source);
        const hasSegments = collectHasSegments(h.has);
        normalizeHasKeys(h.has);
        normalizeHasKeys(h.missing);
        const namedSegments = segments.filter((name) => name !== UN_NAMED_SEGMENT);
        const indexes = {};
        segments.forEach((name, index) => {
          indexes[name] = toSegmentDest(index);
        });
        hasSegments.forEach((name) => {
          indexes[name] = "$" + name;
        });
        h.headers.forEach(({ key, value }) => {
          if (namedSegments.length > 0 || hasSegments.length > 0) {
            if (key.includes(":")) {
              key = safelyCompile(key, indexes);
            }
            if (value.includes(":")) {
              value = safelyCompile(value, indexes);
            }
          }
          obj[key] = value;
        });
        const route = {
          src,
          headers: obj,
          continue: true
        };
        if (h.has) {
          route.has = h.has;
        }
        if (h.missing) {
          route.missing = h.missing;
        }
        return route;
      });
    }
    function convertTrailingSlash(enable, status = 308) {
      const routes = [];
      if (enable) {
        routes.push({
          src: "^/\\.well-known(?:/.*)?$"
        });
        routes.push({
          src: "^/((?:[^/]+/)*[^/\\.]+)$",
          headers: { Location: "/$1/" },
          status
        });
        routes.push({
          src: "^/((?:[^/]+/)*[^/]+\\.\\w+)/$",
          headers: { Location: "/$1" },
          status
        });
      } else {
        routes.push({
          src: "^/(.*)\\/$",
          headers: { Location: "/$1" },
          status
        });
      }
      return routes;
    }
    function sourceToRegex(source) {
      const keys = [];
      const r = (0, import_path_to_regexp.pathToRegexp)(source, keys, {
        strict: true,
        sensitive: true,
        delimiter: "/"
      });
      const segments = keys.map((k) => k.name).map((name) => {
        if (typeof name !== "string") {
          return UN_NAMED_SEGMENT;
        }
        return name;
      });
      return { src: r.source, segments };
    }
    var namedGroupsRegex = /\(\?<([a-zA-Z][a-zA-Z0-9]*)>/g;
    var normalizeHasKeys = (hasItems = []) => {
      for (const hasItem of hasItems) {
        if ("key" in hasItem && hasItem.type === "header") {
          hasItem.key = hasItem.key.toLowerCase();
        }
      }
      return hasItems;
    };
    function collectHasSegments(has) {
      const hasSegments = /* @__PURE__ */ new Set();
      for (const hasItem of has || []) {
        if (!hasItem.value && "key" in hasItem) {
          hasSegments.add(hasItem.key);
        }
        if (hasItem.value) {
          for (const match of hasItem.value.matchAll(namedGroupsRegex)) {
            if (match[1]) {
              hasSegments.add(match[1]);
            }
          }
          if (hasItem.type === "host") {
            hasSegments.add("host");
          }
        }
      }
      return [...hasSegments];
    }
    var escapeSegment = (str, segmentName) => str.replace(new RegExp(`:${segmentName}`, "g"), `__ESC_COLON_${segmentName}`);
    var unescapeSegments = (str) => str.replace(/__ESC_COLON_/gi, ":");
    function replaceSegments(segments, hasItemSegments, destination, isRedirect, internalParamNames) {
      const namedSegments = segments.filter((name) => name !== UN_NAMED_SEGMENT);
      const canNeedReplacing = destination.includes(":") && namedSegments.length > 0 || hasItemSegments.length > 0 || !isRedirect;
      if (!canNeedReplacing) {
        return destination;
      }
      let escapedDestination = destination;
      const indexes = {};
      segments.forEach((name, index) => {
        indexes[name] = toSegmentDest(index);
        escapedDestination = escapeSegment(escapedDestination, name);
      });
      hasItemSegments.forEach((name) => {
        indexes[name] = "$" + name;
        escapedDestination = escapeSegment(escapedDestination, name);
      });
      const parsedDestination = (0, import_url3.parse)(escapedDestination, true);
      delete parsedDestination.href;
      delete parsedDestination.path;
      delete parsedDestination.search;
      delete parsedDestination.host;
      let { pathname, hash, query, hostname, ...rest } = parsedDestination;
      pathname = unescapeSegments(pathname || "");
      hash = unescapeSegments(hash || "");
      hostname = unescapeSegments(hostname || "");
      let destParams = /* @__PURE__ */ new Set();
      const pathnameKeys = [];
      const hashKeys = [];
      const hostnameKeys = [];
      try {
        (0, import_path_to_regexp.pathToRegexp)(pathname, pathnameKeys);
        (0, import_path_to_regexp.pathToRegexp)(hash || "", hashKeys);
        (0, import_path_to_regexp.pathToRegexp)(hostname || "", hostnameKeys);
      } catch (_) {
      }
      destParams = new Set(
        [...pathnameKeys, ...hashKeys, ...hostnameKeys].map((key) => key.name).filter((val) => typeof val === "string")
      );
      pathname = safelyCompile(pathname, indexes, true);
      hash = hash ? safelyCompile(hash, indexes, true) : null;
      hostname = hostname ? safelyCompile(hostname, indexes, true) : null;
      for (const [key, strOrArray] of Object.entries(query)) {
        if (Array.isArray(strOrArray)) {
          query[key] = strOrArray.map(
            (str) => safelyCompile(unescapeSegments(str), indexes, true)
          );
        } else {
          query[key] = safelyCompile(
            unescapeSegments(strOrArray),
            indexes,
            true
          );
        }
      }
      const paramKeys = Object.keys(indexes);
      const needsQueryUpdating = (
        // we do not consider an internal param since it is added automatically
        !isRedirect && !paramKeys.some(
          (param) => !(internalParamNames && internalParamNames.includes(param)) && destParams.has(param)
        )
      );
      if (needsQueryUpdating) {
        for (const param of paramKeys) {
          if (!(param in query) && param !== UN_NAMED_SEGMENT) {
            query[param] = indexes[param];
          }
        }
      }
      destination = (0, import_url3.format)({
        ...rest,
        hostname,
        pathname,
        query,
        hash
      });
      return destination.replace(/%24/g, "$");
    }
    function safelyCompile(value, indexes, attemptDirectCompile) {
      if (!value) {
        return value;
      }
      if (attemptDirectCompile) {
        try {
          return (0, import_path_to_regexp.compile)(value, { validate: false })(indexes);
        } catch (e) {
        }
      }
      for (const key of Object.keys(indexes)) {
        if (value.includes(`:${key}`)) {
          value = value.replace(
            new RegExp(`:${key}\\*`, "g"),
            `:${key}--ESCAPED_PARAM_ASTERISK`
          ).replace(
            new RegExp(`:${key}\\?`, "g"),
            `:${key}--ESCAPED_PARAM_QUESTION`
          ).replace(new RegExp(`:${key}\\+`, "g"), `:${key}--ESCAPED_PARAM_PLUS`).replace(
            new RegExp(`:${key}(?!\\w)`, "g"),
            `--ESCAPED_PARAM_COLON${key}`
          );
        }
      }
      value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, "\\$1").replace(/--ESCAPED_PARAM_PLUS/g, "+").replace(/--ESCAPED_PARAM_COLON/g, ":").replace(/--ESCAPED_PARAM_QUESTION/g, "?").replace(/--ESCAPED_PARAM_ASTERISK/g, "*");
      return (0, import_path_to_regexp.compile)(`/${value}`, { validate: false })(indexes).slice(1);
    }
    function toSegmentDest(index) {
      const i = index + 1;
      return "$" + i.toString();
    }
    function toRoute(filePath) {
      return filePath.startsWith("/") ? filePath : "/" + filePath;
    }
  }
});

// ../../node_modules/.pnpm/async-sema@3.0.1/node_modules/async-sema/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/async-sema@3.0.1/node_modules/async-sema/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __importDefault(require("events"));
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (let j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
      }
    }
    function pow2AtLeast(n) {
      n = n >>> 0;
      n = n - 1;
      n = n | n >> 1;
      n = n | n >> 2;
      n = n | n >> 4;
      n = n | n >> 8;
      n = n | n >> 16;
      return n + 1;
    }
    function getCapacity(capacity) {
      return pow2AtLeast(Math.min(Math.max(16, capacity), 1073741824));
    }
    var Deque = class {
      constructor(capacity) {
        this._capacity = getCapacity(capacity);
        this._length = 0;
        this._front = 0;
        this.arr = [];
      }
      push(item) {
        const length = this._length;
        this.checkCapacity(length + 1);
        const i = this._front + length & this._capacity - 1;
        this.arr[i] = item;
        this._length = length + 1;
        return length + 1;
      }
      pop() {
        const length = this._length;
        if (length === 0) {
          return void 0;
        }
        const i = this._front + length - 1 & this._capacity - 1;
        const ret = this.arr[i];
        this.arr[i] = void 0;
        this._length = length - 1;
        return ret;
      }
      shift() {
        const length = this._length;
        if (length === 0) {
          return void 0;
        }
        const front = this._front;
        const ret = this.arr[front];
        this.arr[front] = void 0;
        this._front = front + 1 & this._capacity - 1;
        this._length = length - 1;
        return ret;
      }
      get length() {
        return this._length;
      }
      checkCapacity(size) {
        if (this._capacity < size) {
          this.resizeTo(getCapacity(this._capacity * 1.5 + 16));
        }
      }
      resizeTo(capacity) {
        const oldCapacity = this._capacity;
        this._capacity = capacity;
        const front = this._front;
        const length = this._length;
        if (front + length > oldCapacity) {
          const moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this.arr, 0, this.arr, oldCapacity, moveItemsCount);
        }
      }
    };
    var ReleaseEmitter = class extends events_1.default {
    };
    function isFn(x) {
      return typeof x === "function";
    }
    function defaultInit() {
      return "1";
    }
    var Sema4 = class {
      constructor(nr, { initFn = defaultInit, pauseFn, resumeFn, capacity = 10 } = {}) {
        if (isFn(pauseFn) !== isFn(resumeFn)) {
          throw new Error("pauseFn and resumeFn must be both set for pausing");
        }
        this.nrTokens = nr;
        this.free = new Deque(nr);
        this.waiting = new Deque(capacity);
        this.releaseEmitter = new ReleaseEmitter();
        this.noTokens = initFn === defaultInit;
        this.pauseFn = pauseFn;
        this.resumeFn = resumeFn;
        this.paused = false;
        this.releaseEmitter.on("release", (token) => {
          const p = this.waiting.shift();
          if (p) {
            p.resolve(token);
          } else {
            if (this.resumeFn && this.paused) {
              this.paused = false;
              this.resumeFn();
            }
            this.free.push(token);
          }
        });
        for (let i = 0; i < nr; i++) {
          this.free.push(initFn());
        }
      }
      async acquire() {
        let token = this.free.pop();
        if (token !== void 0) {
          return token;
        }
        return new Promise((resolve, reject) => {
          if (this.pauseFn && !this.paused) {
            this.paused = true;
            this.pauseFn();
          }
          this.waiting.push({ resolve, reject });
        });
      }
      release(token) {
        this.releaseEmitter.emit("release", this.noTokens ? "1" : token);
      }
      drain() {
        const a = new Array(this.nrTokens);
        for (let i = 0; i < this.nrTokens; i++) {
          a[i] = this.acquire();
        }
        return Promise.all(a);
      }
      nrWaiting() {
        return this.waiting.length;
      }
    };
    exports.Sema = Sema4;
    function RateLimit(rps, { timeUnit = 1e3, uniformDistribution = false } = {}) {
      const sema = new Sema4(uniformDistribution ? 1 : rps);
      const delay = uniformDistribution ? timeUnit / rps : timeUnit;
      return async function rl() {
        await sema.acquire();
        setTimeout(() => sema.release(), delay);
      };
    }
    exports.RateLimit = RateLimit;
  }
});

// ../../node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js"(exports, module2) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// ../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js
var require_p_try = __commonJS({
  "../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js"(exports, module2) {
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve) => {
      resolve(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});

// ../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js"(exports, module2) {
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});

// ../../node_modules/.pnpm/p-locate@4.1.0/node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "../../node_modules/.pnpm/p-locate@4.1.0/node_modules/p-locate/index.js"(exports, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options) => {
      options = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options
      };
      const limit = pLimit(options.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error) {
        if (error instanceof EndError) {
          return error.value;
        }
        throw error;
      }
    };
    module2.exports = pLocate;
    module2.exports.default = pLocate;
  }
});

// ../../node_modules/.pnpm/locate-path@5.0.0/node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "../../node_modules/.pnpm/locate-path@5.0.0/node_modules/locate-path/index.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var fs5 = require("fs");
    var { promisify: promisify2 } = require("util");
    var pLocate = require_p_locate();
    var fsStat = promisify2(fs5.stat);
    var fsLStat = promisify2(fs5.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({ type }) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat2) => type === void 0 || stat2[typeMappings[type]]();
    module2.exports = async (paths, options) => {
      options = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat2 = await statFn(path5.resolve(options.cwd, path_));
          return matchType(options.type, stat2);
        } catch (_) {
          return false;
        }
      }, options);
    };
    module2.exports.sync = (paths, options) => {
      options = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fs5.statSync : fs5.lstatSync;
      for (const path_ of paths) {
        try {
          const stat2 = statFn(path5.resolve(options.cwd, path_));
          if (matchType(options.type, stat2)) {
            return path_;
          }
        } catch (_) {
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js"(exports, module2) {
    "use strict";
    var fs5 = require("fs");
    var { promisify: promisify2 } = require("util");
    var pAccess = promisify2(fs5.access);
    module2.exports = async (path5) => {
      try {
        await pAccess(path5);
        return true;
      } catch (_) {
        return false;
      }
    };
    module2.exports.sync = (path5) => {
      try {
        fs5.accessSync(path5);
        return true;
      } catch (_) {
        return false;
      }
    };
  }
});

// ../../node_modules/.pnpm/find-up@4.1.0/node_modules/find-up/index.js
var require_find_up = __commonJS({
  "../../node_modules/.pnpm/find-up@4.1.0/node_modules/find-up/index.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var locatePath = require_locate_path();
    var pathExists2 = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options = {}) => {
      let directory = path5.resolve(options.cwd || "");
      const { root } = path5.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({ ...options, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path5.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path5.dirname(directory);
      }
    };
    module2.exports.sync = (name, options = {}) => {
      let directory = path5.resolve(options.cwd || "");
      const { root } = path5.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({ ...options, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path5.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path5.dirname(directory);
      }
    };
    module2.exports.exists = pathExists2;
    module2.exports.sync.exists = pathExists2.sync;
    module2.exports.stop = stop;
  }
});

// ../../node_modules/.pnpm/universalify@2.0.0/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/.pnpm/universalify@2.0.0/node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            fn.call(
              this,
              ...args,
              (err, res) => err != null ? reject(err) : resolve(res)
            );
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs5) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs5);
      }
      if (!fs5.lutimes) {
        patchLutimes(fs5);
      }
      fs5.chown = chownFix(fs5.chown);
      fs5.fchown = chownFix(fs5.fchown);
      fs5.lchown = chownFix(fs5.lchown);
      fs5.chmod = chmodFix(fs5.chmod);
      fs5.fchmod = chmodFix(fs5.fchmod);
      fs5.lchmod = chmodFix(fs5.lchmod);
      fs5.chownSync = chownFixSync(fs5.chownSync);
      fs5.fchownSync = chownFixSync(fs5.fchownSync);
      fs5.lchownSync = chownFixSync(fs5.lchownSync);
      fs5.chmodSync = chmodFixSync(fs5.chmodSync);
      fs5.fchmodSync = chmodFixSync(fs5.fchmodSync);
      fs5.lchmodSync = chmodFixSync(fs5.lchmodSync);
      fs5.stat = statFix(fs5.stat);
      fs5.fstat = statFix(fs5.fstat);
      fs5.lstat = statFix(fs5.lstat);
      fs5.statSync = statFixSync(fs5.statSync);
      fs5.fstatSync = statFixSync(fs5.fstatSync);
      fs5.lstatSync = statFixSync(fs5.lstatSync);
      if (fs5.chmod && !fs5.lchmod) {
        fs5.lchmod = function(path5, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs5.lchmodSync = function() {
        };
      }
      if (fs5.chown && !fs5.lchown) {
        fs5.lchown = function(path5, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs5.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs5.rename = typeof fs5.rename !== "function" ? fs5.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs5.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs5.rename);
      }
      fs5.read = typeof fs5.read !== "function" ? fs5.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs5.read);
      fs5.readSync = typeof fs5.readSync !== "function" ? fs5.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs5, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs5.readSync);
      function patchLchmod(fs6) {
        fs6.lchmod = function(path5, mode, callback) {
          fs6.open(
            path5,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs6.fchmod(fd, mode, function(err2) {
                fs6.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs6.lchmodSync = function(path5, mode) {
          var fd = fs6.openSync(path5, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs6.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs6.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs6.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs6) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs6.futimes) {
          fs6.lutimes = function(path5, at, mt, cb) {
            fs6.open(path5, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs6.futimes(fd, at, mt, function(er2) {
                fs6.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs6.lutimesSync = function(path5, at, mt) {
            var fd = fs6.openSync(path5, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs6.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs6.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs6.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs6.futimes) {
          fs6.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs6.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs5, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs5, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs5, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs5, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs5, target, options, callback) : orig.call(fs5, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs5, target, options) : orig.call(fs5, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs5) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path5, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path5, options);
        Stream.call(this);
        var self = this;
        this.path = path5;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs5.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path5, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path5, options);
        Stream.call(this);
        this.path = path5;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs5.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs5 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug4 = noop;
    if (util.debuglog)
      debug4 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug4 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs5[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs5, queue);
      fs5.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs5, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs5.close);
      fs5.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs5, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs5.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug4(fs5[gracefulQueue]);
          require("assert").equal(fs5[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs5[gracefulQueue]);
    }
    module2.exports = patch(clone(fs5));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs5.__patched) {
      module2.exports = patch(fs5);
      fs5.__patched = true;
    }
    function patch(fs6) {
      polyfills(fs6);
      fs6.gracefulify = patch;
      fs6.createReadStream = createReadStream;
      fs6.createWriteStream = createWriteStream;
      var fs$readFile = fs6.readFile;
      fs6.readFile = readFile3;
      function readFile3(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path5, options, cb);
        function go$readFile(path6, options2, cb2, startTime) {
          return fs$readFile(path6, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path6, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs6.writeFile;
      fs6.writeFile = writeFile2;
      function writeFile2(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path5, data, options, cb);
        function go$writeFile(path6, data2, options2, cb2, startTime) {
          return fs$writeFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs6.appendFile;
      if (fs$appendFile)
        fs6.appendFile = appendFile;
      function appendFile(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path5, data, options, cb);
        function go$appendFile(path6, data2, options2, cb2, startTime) {
          return fs$appendFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs6.copyFile;
      if (fs$copyFile)
        fs6.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs6.readdir;
      fs6.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, options2, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path5, options, cb);
        function fs$readdirCallback(path6, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path6, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs6);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs6.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs6.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs6, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs6, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs6, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs6, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path5, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path5, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path5, options) {
        return new fs6.ReadStream(path5, options);
      }
      function createWriteStream(path5, options) {
        return new fs6.WriteStream(path5, options);
      }
      var fs$open = fs6.open;
      fs6.open = open;
      function open(path5, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path5, flags, mode, cb);
        function go$open(path6, flags2, mode2, cb2, startTime) {
          return fs$open(path6, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path6, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs6;
    }
    function enqueue(elem) {
      debug4("ENQUEUE", elem[0].name, elem[1]);
      fs5[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs5[gracefulQueue].length; ++i) {
        if (fs5[gracefulQueue][i].length > 2) {
          fs5[gracefulQueue][i][3] = now;
          fs5[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs5[gracefulQueue].length === 0)
        return;
      var elem = fs5[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug4("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug4("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug4("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs5[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs5 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs5[key] === "function";
    });
    Object.assign(exports, fs5);
    api.forEach((method) => {
      exports[method] = u(fs5[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs5.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs5.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs5.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs5.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs5.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.readv(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs5.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs5.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs5.realpath.native === "function") {
      exports.realpath.native = u(fs5.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path5.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module2) {
    "use strict";
    var fs5 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs5.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs5.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/path-exists/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    function pathExists2(path5) {
      return fs5.access(path5).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists2),
      pathExistsSync: fs5.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/util/utimes.js"(exports, module2) {
    "use strict";
    var fs5 = require_fs();
    var u = require_universalify().fromPromise;
    async function utimesMillis(path5, atime, mtime) {
      const fd = await fs5.open(path5, "r+");
      let closeErr = null;
      try {
        await fs5.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs5.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path5, atime, mtime) {
      const fd = fs5.openSync(path5, "r+");
      fs5.futimesSync(fd, atime, mtime);
      return fs5.closeSync(fd);
    }
    module2.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/util/stat.js"(exports, module2) {
    "use strict";
    var fs5 = require_fs();
    var path5 = require("path");
    var u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs5.stat(file, { bigint: true }) : (file) => fs5.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs5.statSync(file, { bigint: true }) : (file) => fs5.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path5.basename(src);
          const destBaseName = path5.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path5.basename(src);
          const destBaseName = path5.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path5.resolve(path5.dirname(src));
      const destParent = path5.resolve(path5.dirname(dest));
      if (destParent === srcParent || destParent === path5.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = await fs5.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path5.resolve(path5.dirname(src));
      const destParent = path5.resolve(path5.dirname(dest));
      if (destParent === srcParent || destParent === path5.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs5.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path5.resolve(src).split(path5.sep).filter((i) => i);
      const destArr = path5.resolve(dest).split(path5.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/copy.js"(exports, module2) {
    "use strict";
    var fs5 = require_fs();
    var path5 = require("path");
    var { mkdirs } = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists2();
    var { utimesMillis } = require_utimes();
    var stat2 = require_stat();
    async function copy(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat2.checkPaths(src, dest, "copy", opts);
      await stat2.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include)
        return;
      const destParent = path5.dirname(dest);
      const dirExists = await pathExists2(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter)
        return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs5.stat : fs5.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs5.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile(srcStat, src, dest, opts) {
      await fs5.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs5.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs5.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs5.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs5.mkdir(dest);
      }
      const items = await fs5.readdir(src);
      await Promise.all(items.map(async (item) => {
        const srcItem = path5.join(src, item);
        const destItem = path5.join(dest, item);
        const include = await runFilter(srcItem, destItem, opts);
        if (!include)
          return;
        const { destStat: destStat2 } = await stat2.checkPaths(srcItem, destItem, "copy", opts);
        return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
      }));
      if (!destStat) {
        await fs5.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs5.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs5.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs5.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN")
          return fs5.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path5.resolve(process.cwd(), resolvedDest);
      }
      if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs5.unlink(dest);
      return fs5.symlink(resolvedSrc, dest);
    }
    module2.exports = copy;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat2 = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat2.checkPathsSync(src, dest, "copy", opts);
      stat2.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path5.dirname(dest);
      if (!fs5.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs5.statSync : fs5.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs5.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs5.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs5.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs5.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs5.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs5.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path5.join(src, item);
      const destItem = path5.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      const { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs5.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs5.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs5.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs5.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path5.resolve(process.cwd(), resolvedDest);
        }
        if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs5.unlinkSync(dest);
      return fs5.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/remove/index.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove2(path5, callback) {
      fs5.rm(path5, { recursive: true, force: true }, callback);
    }
    function removeSync(path5) {
      fs5.rmSync(path5, { recursive: true, force: true });
    }
    module2.exports = {
      remove: u(remove2),
      removeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/empty/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    var path5 = require("path");
    var mkdir = require_mkdirs();
    var remove2 = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs5.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove2.remove(path5.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs5.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path5.join(dir, item);
        remove2.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/file.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path5 = require("path");
    var fs5 = require_fs();
    var mkdir = require_mkdirs();
    async function createFile(file) {
      let stats;
      try {
        stats = await fs5.stat(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path5.dirname(file);
      let dirStats = null;
      try {
        dirStats = await fs5.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs5.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs5.writeFile(file, "");
      } else {
        await fs5.readdir(dir);
      }
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs5.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path5.dirname(file);
      try {
        if (!fs5.statSync(dir).isDirectory()) {
          fs5.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs5.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/link.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path5 = require("path");
    var fs5 = require_fs();
    var mkdir = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists2();
    var { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs5.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs5.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
      const dir = path5.dirname(dstpath);
      const dirExists = await pathExists2(dir);
      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }
      await fs5.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs5.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs5.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path5.dirname(dstpath);
      const dirExists = fs5.existsSync(dir);
      if (dirExists)
        return fs5.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs5.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var fs5 = require_fs();
    var { pathExists: pathExists2 } = require_path_exists2();
    var u = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path5.isAbsolute(srcpath)) {
        try {
          await fs5.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path5.dirname(dstpath);
      const relativeToDst = path5.join(dstdir, srcpath);
      const exists = await pathExists2(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs5.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path5.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path5.isAbsolute(srcpath)) {
        const exists2 = fs5.existsSync(srcpath);
        if (!exists2)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path5.dirname(dstpath);
      const relativeToDst = path5.join(dstdir, srcpath);
      const exists = fs5.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs5.existsSync(srcpath);
      if (!srcExists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path5.relative(dstdir, srcpath)
      };
    }
    module2.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module2) {
    "use strict";
    var fs5 = require_fs();
    var u = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type)
        return type;
      let stats;
      try {
        stats = await fs5.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type)
        return type;
      let stats;
      try {
        stats = fs5.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path5 = require("path");
    var fs5 = require_fs();
    var { mkdirs, mkdirsSync } = require_mkdirs();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
    var { symlinkType, symlinkTypeSync } = require_symlink_type();
    var { pathExists: pathExists2 } = require_path_exists2();
    var { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs5.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs5.stat(srcpath),
          fs5.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path5.dirname(dstpath);
      if (!await pathExists2(dir)) {
        await mkdirs(dir);
      }
      return fs5.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs5.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs5.statSync(srcpath);
        const dstStat = fs5.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path5.dirname(dstpath);
      const exists = fs5.existsSync(dir);
      if (exists)
        return fs5.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs5.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/index.js"(exports, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports, module2) {
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs5 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs5.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile3 = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs5 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs5.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs5 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs5.writeFile)(file, str, options);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs5 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs5.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile3,
      readFileSync,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/output-file/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    var path5 = require("path");
    var mkdir = require_mkdirs();
    var pathExists2 = require_path_exists2().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path5.dirname(file);
      if (!await pathExists2(dir)) {
        await mkdir.mkdirs(dir);
      }
      return fs5.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args) {
      const dir = path5.dirname(file);
      if (!fs5.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs5.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/output-json.js"(exports, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/move.js"(exports, module2) {
    "use strict";
    var fs5 = require_fs();
    var path5 = require("path");
    var { copy } = require_copy2();
    var { remove: remove2 } = require_remove();
    var { mkdirp } = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists2();
    var stat2 = require_stat();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat2.checkPaths(src, dest, "move", opts);
      await stat2.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path5.dirname(dest);
      const parsedParentPath = path5.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove2(dest);
        } else if (await pathExists2(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs5.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy(src, dest, opts);
      return remove2(src);
    }
    module2.exports = move;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/move-sync.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat2 = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat2.checkPathsSync(src, dest, "move", opts);
      stat2.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path5.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path5.dirname(dest);
      const parsedPath = path5.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs5.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs5.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists2(),
      ...require_remove()
    };
  }
});

// ../../node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js
var require_semver = __commonJS({
  "../../node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"(exports, module2) {
    exports = module2.exports = SemVer;
    var debug4;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug4 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug4 = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug4(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports.parse = parse;
    function parse(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version2, options) {
      var v = parse(version2, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version2, options) {
      var s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        if (version2.loose === options.loose) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError("Invalid Version: " + version2);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version2, options);
      }
      debug4("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version2.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version2);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug4("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug4("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug4("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version2, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug4("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug4("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      debug4("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug4("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug4("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug4("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug4("caret", comp);
      comp = replaceTildes(comp, options);
      debug4("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug4("xrange", comp);
      comp = replaceStars(comp, options);
      debug4("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug4("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug4("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug4("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug4("caret", comp, options);
      var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug4("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug4("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug4("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug4("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug4("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug4("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug4("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug4("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version2, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug4(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version2, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version2, range, options) {
      return outside(version2, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version2, range, options) {
      return outside(version2, range, ">", options);
    }
    exports.outside = outside;
    function outside(version2, range, hilo, options) {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version2, options) {
      var parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version2, options) {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version2.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// ../../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "../../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js"(exports, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc322() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc322.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc322.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc322;
  }
});

// ../../node_modules/.pnpm/text-table@0.2.0/node_modules/text-table/index.js
var require_text_table = __commonJS({
  "../../node_modules/.pnpm/text-table@0.2.0/node_modules/text-table/index.js"(exports, module2) {
    module2.exports = function(rows_, opts) {
      if (!opts)
        opts = {};
      var hsep = opts.hsep === void 0 ? "  " : opts.hsep;
      var align = opts.align || [];
      var stringLength = opts.stringLength || function(s) {
        return String(s).length;
      };
      var dotsizes = reduce(rows_, function(acc, row) {
        forEach(row, function(c, ix) {
          var n = dotindex(c);
          if (!acc[ix] || n > acc[ix])
            acc[ix] = n;
        });
        return acc;
      }, []);
      var rows = map(rows_, function(row) {
        return map(row, function(c_, ix) {
          var c = String(c_);
          if (align[ix] === ".") {
            var index = dotindex(c);
            var size = dotsizes[ix] + (/\./.test(c) ? 1 : 2) - (stringLength(c) - index);
            return c + Array(size).join(" ");
          } else
            return c;
        });
      });
      var sizes = reduce(rows, function(acc, row) {
        forEach(row, function(c, ix) {
          var n = stringLength(c);
          if (!acc[ix] || n > acc[ix])
            acc[ix] = n;
        });
        return acc;
      }, []);
      return map(rows, function(row) {
        return map(row, function(c, ix) {
          var n = sizes[ix] - stringLength(c) || 0;
          var s = Array(Math.max(n + 1, 1)).join(" ");
          if (align[ix] === "r" || align[ix] === ".") {
            return s + c;
          }
          if (align[ix] === "c") {
            return Array(Math.ceil(n / 2 + 1)).join(" ") + c + Array(Math.floor(n / 2 + 1)).join(" ");
          }
          return c + s;
        }).join(hsep).replace(/\s+$/, "");
      }).join("\n");
    };
    function dotindex(c) {
      var m = /\.[^.]*$/.exec(c);
      return m ? m.index + 1 : c.length;
    }
    function reduce(xs, f, init) {
      if (xs.reduce)
        return xs.reduce(f, init);
      var i = 0;
      var acc = arguments.length >= 3 ? init : xs[i++];
      for (; i < xs.length; i++) {
        f(acc, xs[i], i);
      }
      return acc;
    }
    function forEach(xs, f) {
      if (xs.forEach)
        return xs.forEach(f);
      for (var i = 0; i < xs.length; i++) {
        f.call(xs, xs[i], i);
      }
    }
    function map(xs, f) {
      if (xs.map)
        return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f.call(xs, xs[i], i));
      }
      return res;
    }
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/Source.js
var require_Source = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/Source.js"(exports, module2) {
    "use strict";
    var Source3 = class {
      source() {
        throw new Error("Abstract");
      }
      buffer() {
        const source = this.source();
        if (Buffer.isBuffer(source))
          return source;
        return Buffer.from(source, "utf-8");
      }
      size() {
        return this.buffer().length;
      }
      map(options) {
        return null;
      }
      sourceAndMap(options) {
        return {
          source: this.source(),
          map: this.map(options)
        };
      }
      updateHash(hash) {
        throw new Error("Abstract");
      }
    };
    module2.exports = Source3;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js
var require_getGeneratedSourceInfo = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js"(exports, module2) {
    "use strict";
    var CHAR_CODE_NEW_LINE = "\n".charCodeAt(0);
    var getGeneratedSourceInfo = (source) => {
      if (source === void 0) {
        return {};
      }
      const lastLineStart = source.lastIndexOf("\n");
      if (lastLineStart === -1) {
        return {
          generatedLine: 1,
          generatedColumn: source.length,
          source
        };
      }
      let generatedLine = 2;
      for (let i = 0; i < lastLineStart; i++) {
        if (source.charCodeAt(i) === CHAR_CODE_NEW_LINE)
          generatedLine++;
      }
      return {
        generatedLine,
        generatedColumn: source.length - lastLineStart - 1,
        source
      };
    };
    module2.exports = getGeneratedSourceInfo;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoLines.js
var require_splitIntoLines = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoLines.js"(exports, module2) {
    var splitIntoLines = (str) => {
      const results = [];
      const len = str.length;
      let i = 0;
      for (; i < len; ) {
        const cc = str.charCodeAt(i);
        if (cc === 10) {
          results.push("\n");
          i++;
        } else {
          let j = i + 1;
          while (j < len && str.charCodeAt(j) !== 10)
            j++;
          results.push(str.slice(i, j + 1));
          i = j + 1;
        }
      }
      return results;
    };
    module2.exports = splitIntoLines;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js
var require_streamChunksOfRawSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js"(exports, module2) {
    "use strict";
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfRawSource = (source, onChunk, onSource, onName) => {
      let line = 1;
      const matches = splitIntoLines(source);
      let match;
      for (match of matches) {
        onChunk(match, line, 0, -1, -1, -1, -1);
        line++;
      }
      return matches.length === 0 || match.endsWith("\n") ? {
        generatedLine: matches.length + 1,
        generatedColumn: 0
      } : {
        generatedLine: matches.length,
        generatedColumn: match.length
      };
    };
    module2.exports = (source, onChunk, onSource, onName, finalSource) => {
      return finalSource ? getGeneratedSourceInfo(source) : streamChunksOfRawSource(source, onChunk, onSource, onName);
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/RawSource.js
var require_RawSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/RawSource.js"(exports, module2) {
    "use strict";
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var Source3 = require_Source();
    var RawSource = class extends Source3 {
      constructor(value, convertToString = false) {
        super();
        const isBuffer = Buffer.isBuffer(value);
        if (!isBuffer && typeof value !== "string") {
          throw new TypeError("argument 'value' must be either string of Buffer");
        }
        this._valueIsBuffer = !convertToString && isBuffer;
        this._value = convertToString && isBuffer ? void 0 : value;
        this._valueAsBuffer = isBuffer ? value : void 0;
        this._valueAsString = isBuffer ? void 0 : value;
      }
      isBuffer() {
        return this._valueIsBuffer;
      }
      source() {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        return this._value;
      }
      buffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        return this._valueAsBuffer;
      }
      map(options) {
        return null;
      }
      /**
       * @param {object} options options
       * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
       * @param {function(number, string, string)} onSource called for each source
       * @param {function(number, string)} onName called for each name
       * @returns {void}
       */
      streamChunks(options, onChunk, onSource, onName) {
        if (this._value === void 0) {
          this._value = Buffer.from(this._valueAsBuffer, "utf-8");
        }
        if (this._valueAsString === void 0) {
          this._valueAsString = typeof this._value === "string" ? this._value : this._value.toString("utf-8");
        }
        return streamChunksOfRawSource(
          this._valueAsString,
          onChunk,
          onSource,
          onName,
          !!(options && options.finalSource)
        );
      }
      updateHash(hash) {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        hash.update("RawSource");
        hash.update(this._valueAsBuffer);
      }
    };
    module2.exports = RawSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js
var require_createMappingsSerializer = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js"(exports, module2) {
    "use strict";
    var ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
      ""
    );
    var CONTINUATION_BIT = 32;
    var createMappingsSerializer = (options) => {
      const linesOnly = options && options.columns === false;
      return linesOnly ? createLinesOnlyMappingsSerializer() : createFullMappingsSerializer();
    };
    var createFullMappingsSerializer = () => {
      let currentLine = 1;
      let currentColumn = 0;
      let currentSourceIndex = 0;
      let currentOriginalLine = 1;
      let currentOriginalColumn = 0;
      let currentNameIndex = 0;
      let activeMapping = false;
      let activeName = false;
      let initial = true;
      return (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (activeMapping && currentLine === generatedLine) {
          if (sourceIndex === currentSourceIndex && originalLine === currentOriginalLine && originalColumn === currentOriginalColumn && !activeName && nameIndex < 0) {
            return "";
          }
        } else {
          if (sourceIndex < 0) {
            return "";
          }
        }
        let str;
        if (currentLine < generatedLine) {
          str = ";".repeat(generatedLine - currentLine);
          currentLine = generatedLine;
          currentColumn = 0;
          initial = false;
        } else if (initial) {
          str = "";
          initial = false;
        } else {
          str = ",";
        }
        const writeValue = (value) => {
          const sign = value >>> 31 & 1;
          const mask = value >> 31;
          const absValue = value + mask ^ mask;
          let data = absValue << 1 | sign;
          for (; ; ) {
            const sextet = data & 31;
            data >>= 5;
            if (data === 0) {
              str += ALPHABET[sextet];
              break;
            } else {
              str += ALPHABET[sextet | CONTINUATION_BIT];
            }
          }
        };
        writeValue(generatedColumn - currentColumn);
        currentColumn = generatedColumn;
        if (sourceIndex >= 0) {
          activeMapping = true;
          if (sourceIndex === currentSourceIndex) {
            str += "A";
          } else {
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
          }
          writeValue(originalLine - currentOriginalLine);
          currentOriginalLine = originalLine;
          if (originalColumn === currentOriginalColumn) {
            str += "A";
          } else {
            writeValue(originalColumn - currentOriginalColumn);
            currentOriginalColumn = originalColumn;
          }
          if (nameIndex >= 0) {
            writeValue(nameIndex - currentNameIndex);
            currentNameIndex = nameIndex;
            activeName = true;
          } else {
            activeName = false;
          }
        } else {
          activeMapping = false;
        }
        return str;
      };
    };
    var createLinesOnlyMappingsSerializer = () => {
      let lastWrittenLine = 0;
      let currentLine = 1;
      let currentSourceIndex = 0;
      let currentOriginalLine = 1;
      return (generatedLine, _generatedColumn, sourceIndex, originalLine, _originalColumn, _nameIndex) => {
        if (sourceIndex < 0) {
          return "";
        }
        if (lastWrittenLine === generatedLine) {
          return "";
        }
        let str;
        const writeValue = (value) => {
          const sign = value >>> 31 & 1;
          const mask = value >> 31;
          const absValue = value + mask ^ mask;
          let data = absValue << 1 | sign;
          for (; ; ) {
            const sextet = data & 31;
            data >>= 5;
            if (data === 0) {
              str += ALPHABET[sextet];
              break;
            } else {
              str += ALPHABET[sextet | CONTINUATION_BIT];
            }
          }
        };
        lastWrittenLine = generatedLine;
        if (generatedLine === currentLine + 1) {
          currentLine = generatedLine;
          if (sourceIndex === currentSourceIndex) {
            currentSourceIndex = sourceIndex;
            if (originalLine === currentOriginalLine + 1) {
              currentOriginalLine = originalLine;
              return ";AACA";
            } else {
              str = ";AA";
              writeValue(originalLine - currentOriginalLine);
              currentOriginalLine = originalLine;
              return str + "A";
            }
          } else {
            str = ";A";
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
            writeValue(originalLine - currentOriginalLine);
            currentOriginalLine = originalLine;
            return str + "A";
          }
        } else {
          str = ";".repeat(generatedLine - currentLine);
          currentLine = generatedLine;
          if (sourceIndex === currentSourceIndex) {
            currentSourceIndex = sourceIndex;
            if (originalLine === currentOriginalLine + 1) {
              currentOriginalLine = originalLine;
              return str + "AACA";
            } else {
              str += "AA";
              writeValue(originalLine - currentOriginalLine);
              currentOriginalLine = originalLine;
              return str + "A";
            }
          } else {
            str += "A";
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
            writeValue(originalLine - currentOriginalLine);
            currentOriginalLine = originalLine;
            return str + "A";
          }
        }
      };
    };
    module2.exports = createMappingsSerializer;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js
var require_getFromStreamChunks = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js"(exports) {
    "use strict";
    var createMappingsSerializer = require_createMappingsSerializer();
    exports.getSourceAndMap = (inputSource, options) => {
      let code = "";
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(options);
      const { source } = inputSource.streamChunks(
        Object.assign({}, options, { finalSource: true }),
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (chunk !== void 0)
            code += chunk;
          mappings += addMapping(
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
        }
      );
      return {
        source: source !== void 0 ? source : code,
        map: mappings.length > 0 ? {
          version: 3,
          file: "x",
          mappings,
          sources,
          sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
          names
        } : null
      };
    };
    exports.getMap = (source, options) => {
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(options);
      source.streamChunks(
        Object.assign({}, options, { source: false, finalSource: true }),
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          mappings += addMapping(
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
        }
      );
      return mappings.length > 0 ? {
        version: 3,
        file: "x",
        mappings,
        sources,
        sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
        names
      } : null;
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js
var require_splitIntoPotentialTokens = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js"(exports, module2) {
    var splitIntoPotentialTokens = (str) => {
      const len = str.length;
      if (len === 0)
        return null;
      const results = [];
      let i = 0;
      for (; i < len; ) {
        const s = i;
        block: {
          let cc = str.charCodeAt(i);
          while (cc !== 10 && cc !== 59 && cc !== 123 && cc !== 125) {
            if (++i >= len)
              break block;
            cc = str.charCodeAt(i);
          }
          while (cc === 59 || cc === 32 || cc === 123 || cc === 125 || cc === 13 || cc === 9) {
            if (++i >= len)
              break block;
            cc = str.charCodeAt(i);
          }
          if (cc === 10) {
            i++;
          }
        }
        results.push(str.slice(s, i));
      }
      return results;
    };
    module2.exports = splitIntoPotentialTokens;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/OriginalSource.js
var require_OriginalSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/OriginalSource.js"(exports, module2) {
    "use strict";
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var splitIntoLines = require_splitIntoLines();
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var Source3 = require_Source();
    var splitIntoPotentialTokens = require_splitIntoPotentialTokens();
    var OriginalSource2 = class extends Source3 {
      constructor(value, name) {
        super();
        const isBuffer = Buffer.isBuffer(value);
        this._value = isBuffer ? void 0 : value;
        this._valueAsBuffer = isBuffer ? value : void 0;
        this._name = name;
      }
      getName() {
        return this._name;
      }
      source() {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        return this._value;
      }
      buffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        return this._valueAsBuffer;
      }
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      /**
       * @param {object} options options
       * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
       * @param {function(number, string, string)} onSource called for each source
       * @param {function(number, string)} onName called for each name
       * @returns {void}
       */
      streamChunks(options, onChunk, onSource, onName) {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        onSource(0, this._name, this._value);
        const finalSource = !!(options && options.finalSource);
        if (!options || options.columns !== false) {
          const matches = splitIntoPotentialTokens(this._value);
          let line = 1;
          let column = 0;
          if (matches !== null) {
            for (const match of matches) {
              const isEndOfLine = match.endsWith("\n");
              if (isEndOfLine && match.length === 1) {
                if (!finalSource)
                  onChunk(match, line, column, -1, -1, -1, -1);
              } else {
                const chunk = finalSource ? void 0 : match;
                onChunk(chunk, line, column, 0, line, column, -1);
              }
              if (isEndOfLine) {
                line++;
                column = 0;
              } else {
                column += match.length;
              }
            }
          }
          return {
            generatedLine: line,
            generatedColumn: column,
            source: finalSource ? this._value : void 0
          };
        } else if (finalSource) {
          const result = getGeneratedSourceInfo(this._value);
          const { generatedLine, generatedColumn } = result;
          if (generatedColumn === 0) {
            for (let line = 1; line < generatedLine; line++)
              onChunk(void 0, line, 0, 0, line, 0, -1);
          } else {
            for (let line = 1; line <= generatedLine; line++)
              onChunk(void 0, line, 0, 0, line, 0, -1);
          }
          return result;
        } else {
          let line = 1;
          const matches = splitIntoLines(this._value);
          let match;
          for (match of matches) {
            onChunk(finalSource ? void 0 : match, line, 0, 0, line, 0, -1);
            line++;
          }
          return matches.length === 0 || match.endsWith("\n") ? {
            generatedLine: matches.length + 1,
            generatedColumn: 0,
            source: finalSource ? this._value : void 0
          } : {
            generatedLine: matches.length,
            generatedColumn: match.length,
            source: finalSource ? this._value : void 0
          };
        }
      }
      updateHash(hash) {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        hash.update("OriginalSource");
        hash.update(this._valueAsBuffer);
        hash.update(this._name || "");
      }
    };
    module2.exports = OriginalSource2;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getSource.js
var require_getSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getSource.js"(exports, module2) {
    "use strict";
    var getSource = (sourceMap, index) => {
      if (index < 0)
        return null;
      const { sourceRoot, sources } = sourceMap;
      const source = sources[index];
      if (!sourceRoot)
        return source;
      if (sourceRoot.endsWith("/"))
        return sourceRoot + source;
      return sourceRoot + "/" + source;
    };
    module2.exports = getSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/readMappings.js
var require_readMappings = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/readMappings.js"(exports, module2) {
    "use strict";
    var ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var CONTINUATION_BIT = 32;
    var END_SEGMENT_BIT = 64;
    var NEXT_LINE = END_SEGMENT_BIT | 1;
    var INVALID = END_SEGMENT_BIT | 2;
    var DATA_MASK = 31;
    var ccToValue = new Uint8Array("z".charCodeAt(0) + 1);
    {
      ccToValue.fill(INVALID);
      for (let i = 0; i < ALPHABET.length; i++) {
        ccToValue[ALPHABET.charCodeAt(i)] = i;
      }
      ccToValue[",".charCodeAt(0)] = END_SEGMENT_BIT;
      ccToValue[";".charCodeAt(0)] = NEXT_LINE;
    }
    var ccMax = ccToValue.length - 1;
    var readMappings = (mappings, onMapping) => {
      const currentData = new Uint32Array([0, 0, 1, 0, 0]);
      let currentDataPos = 0;
      let currentValue = 0;
      let currentValuePos = 0;
      let generatedLine = 1;
      let generatedColumn = -1;
      for (let i = 0; i < mappings.length; i++) {
        const cc = mappings.charCodeAt(i);
        if (cc > ccMax)
          continue;
        const value = ccToValue[cc];
        if ((value & END_SEGMENT_BIT) !== 0) {
          if (currentData[0] > generatedColumn) {
            if (currentDataPos === 1) {
              onMapping(generatedLine, currentData[0], -1, -1, -1, -1);
            } else if (currentDataPos === 4) {
              onMapping(
                generatedLine,
                currentData[0],
                currentData[1],
                currentData[2],
                currentData[3],
                -1
              );
            } else if (currentDataPos === 5) {
              onMapping(
                generatedLine,
                currentData[0],
                currentData[1],
                currentData[2],
                currentData[3],
                currentData[4]
              );
            }
            generatedColumn = currentData[0];
          }
          currentDataPos = 0;
          if (value === NEXT_LINE) {
            generatedLine++;
            currentData[0] = 0;
            generatedColumn = -1;
          }
        } else if ((value & CONTINUATION_BIT) === 0) {
          currentValue |= value << currentValuePos;
          const finalValue = currentValue & 1 ? -(currentValue >> 1) : currentValue >> 1;
          currentData[currentDataPos++] += finalValue;
          currentValuePos = 0;
          currentValue = 0;
        } else {
          currentValue |= (value & DATA_MASK) << currentValuePos;
          currentValuePos += 5;
        }
      }
      if (currentDataPos === 1) {
        onMapping(generatedLine, currentData[0], -1, -1, -1, -1);
      } else if (currentDataPos === 4) {
        onMapping(
          generatedLine,
          currentData[0],
          currentData[1],
          currentData[2],
          currentData[3],
          -1
        );
      } else if (currentDataPos === 5) {
        onMapping(
          generatedLine,
          currentData[0],
          currentData[1],
          currentData[2],
          currentData[3],
          currentData[4]
        );
      }
    };
    module2.exports = readMappings;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js
var require_streamChunksOfSourceMap = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js"(exports, module2) {
    "use strict";
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var getSource = require_getSource();
    var readMappings = require_readMappings();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfSourceMapFull = (source, sourceMap, onChunk, onSource, onName) => {
      const lines = splitIntoLines(source);
      if (lines.length === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, names, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      if (names) {
        for (let i = 0; i < names.length; i++) {
          onName(i, names[i]);
        }
      }
      const lastLine = lines[lines.length - 1];
      const lastNewLine = lastLine.endsWith("\n");
      const finalLine = lastNewLine ? lines.length + 1 : lines.length;
      const finalColumn = lastNewLine ? 0 : lastLine.length;
      let currentGeneratedLine = 1;
      let currentGeneratedColumn = 0;
      let mappingActive = false;
      let activeMappingSourceIndex = -1;
      let activeMappingOriginalLine = -1;
      let activeMappingOriginalColumn = -1;
      let activeMappingNameIndex = -1;
      const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (mappingActive && currentGeneratedLine <= lines.length) {
          let chunk;
          const mappingLine = currentGeneratedLine;
          const mappingColumn = currentGeneratedColumn;
          const line = lines[currentGeneratedLine - 1];
          if (generatedLine !== currentGeneratedLine) {
            chunk = line.slice(currentGeneratedColumn);
            currentGeneratedLine++;
            currentGeneratedColumn = 0;
          } else {
            chunk = line.slice(currentGeneratedColumn, generatedColumn);
            currentGeneratedColumn = generatedColumn;
          }
          if (chunk) {
            onChunk(
              chunk,
              mappingLine,
              mappingColumn,
              activeMappingSourceIndex,
              activeMappingOriginalLine,
              activeMappingOriginalColumn,
              activeMappingNameIndex
            );
          }
          mappingActive = false;
        }
        if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {
          if (currentGeneratedLine <= lines.length) {
            const chunk = lines[currentGeneratedLine - 1].slice(
              currentGeneratedColumn
            );
            onChunk(
              chunk,
              currentGeneratedLine,
              currentGeneratedColumn,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
          currentGeneratedColumn = 0;
        }
        while (generatedLine > currentGeneratedLine) {
          if (currentGeneratedLine <= lines.length) {
            onChunk(
              lines[currentGeneratedLine - 1],
              currentGeneratedLine,
              0,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
        }
        if (generatedColumn > currentGeneratedColumn) {
          if (currentGeneratedLine <= lines.length) {
            const chunk = lines[currentGeneratedLine - 1].slice(
              currentGeneratedColumn,
              generatedColumn
            );
            onChunk(
              chunk,
              currentGeneratedLine,
              currentGeneratedColumn,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedColumn = generatedColumn;
        }
        if (sourceIndex >= 0 && (generatedLine < finalLine || generatedLine === finalLine && generatedColumn < finalColumn)) {
          mappingActive = true;
          activeMappingSourceIndex = sourceIndex;
          activeMappingOriginalLine = originalLine;
          activeMappingOriginalColumn = originalColumn;
          activeMappingNameIndex = nameIndex;
        }
      };
      readMappings(mappings, onMapping);
      onMapping(finalLine, finalColumn, -1, -1, -1, -1);
      return {
        generatedLine: finalLine,
        generatedColumn: finalColumn
      };
    };
    var streamChunksOfSourceMapLinesFull = (source, sourceMap, onChunk, onSource, _onName) => {
      const lines = splitIntoLines(source);
      if (lines.length === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      let currentGeneratedLine = 1;
      const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {
        if (sourceIndex < 0 || generatedLine < currentGeneratedLine || generatedLine > lines.length) {
          return;
        }
        while (generatedLine > currentGeneratedLine) {
          if (currentGeneratedLine <= lines.length) {
            onChunk(
              lines[currentGeneratedLine - 1],
              currentGeneratedLine,
              0,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
        }
        if (generatedLine <= lines.length) {
          onChunk(
            lines[generatedLine - 1],
            generatedLine,
            0,
            sourceIndex,
            originalLine,
            originalColumn,
            -1
          );
          currentGeneratedLine++;
        }
      };
      readMappings(mappings, onMapping);
      for (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {
        onChunk(
          lines[currentGeneratedLine - 1],
          currentGeneratedLine,
          0,
          -1,
          -1,
          -1,
          -1
        );
      }
      const lastLine = lines[lines.length - 1];
      const lastNewLine = lastLine.endsWith("\n");
      const finalLine = lastNewLine ? lines.length + 1 : lines.length;
      const finalColumn = lastNewLine ? 0 : lastLine.length;
      return {
        generatedLine: finalLine,
        generatedColumn: finalColumn
      };
    };
    var streamChunksOfSourceMapFinal = (source, sourceMap, onChunk, onSource, onName) => {
      const result = getGeneratedSourceInfo(source);
      const { generatedLine: finalLine, generatedColumn: finalColumn } = result;
      if (finalLine === 1 && finalColumn === 0)
        return result;
      const { sources, sourcesContent, names, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      if (names) {
        for (let i = 0; i < names.length; i++) {
          onName(i, names[i]);
        }
      }
      let mappingActiveLine = 0;
      const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (generatedLine >= finalLine && (generatedColumn >= finalColumn || generatedLine > finalLine)) {
          return;
        }
        if (sourceIndex >= 0) {
          onChunk(
            void 0,
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
          mappingActiveLine = generatedLine;
        } else if (mappingActiveLine === generatedLine) {
          onChunk(void 0, generatedLine, generatedColumn, -1, -1, -1, -1);
          mappingActiveLine = 0;
        }
      };
      readMappings(mappings, onMapping);
      return result;
    };
    var streamChunksOfSourceMapLinesFinal = (source, sourceMap, onChunk, onSource, _onName) => {
      const result = getGeneratedSourceInfo(source);
      const { generatedLine, generatedColumn } = result;
      if (generatedLine === 1 && generatedColumn === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      const finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;
      let currentGeneratedLine = 1;
      const onMapping = (generatedLine2, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {
        if (sourceIndex >= 0 && currentGeneratedLine <= generatedLine2 && generatedLine2 <= finalLine) {
          onChunk(
            void 0,
            generatedLine2,
            0,
            sourceIndex,
            originalLine,
            originalColumn,
            -1
          );
          currentGeneratedLine = generatedLine2 + 1;
        }
      };
      readMappings(mappings, onMapping);
      return result;
    };
    module2.exports = (source, sourceMap, onChunk, onSource, onName, finalSource, columns) => {
      if (columns) {
        return finalSource ? streamChunksOfSourceMapFinal(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        ) : streamChunksOfSourceMapFull(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        );
      } else {
        return finalSource ? streamChunksOfSourceMapLinesFinal(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        ) : streamChunksOfSourceMapLinesFull(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js
var require_streamChunksOfCombinedSourceMap = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js"(exports, module2) {
    "use strict";
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfCombinedSourceMap = (source, sourceMap, innerSourceName, innerSource, innerSourceMap, removeInnerSource, onChunk, onSource, onName, finalSource, columns) => {
      let sourceMapping = /* @__PURE__ */ new Map();
      let nameMapping = /* @__PURE__ */ new Map();
      const sourceIndexMapping = [];
      const nameIndexMapping = [];
      const nameIndexValueMapping = [];
      let innerSourceIndex = -2;
      const innerSourceIndexMapping = [];
      const innerSourceIndexValueMapping = [];
      const innerSourceContents = [];
      const innerSourceContentLines = [];
      const innerNameIndexMapping = [];
      const innerNameIndexValueMapping = [];
      const innerSourceMapLineData = [];
      const findInnerMapping = (line, column) => {
        if (line > innerSourceMapLineData.length)
          return -1;
        const { mappingsData } = innerSourceMapLineData[line - 1];
        let l = 0;
        let r = mappingsData.length / 5;
        while (l < r) {
          let m = l + r >> 1;
          if (mappingsData[m * 5] <= column) {
            l = m + 1;
          } else {
            r = m;
          }
        }
        if (l === 0)
          return -1;
        return l - 1;
      };
      return streamChunksOfSourceMap(
        source,
        sourceMap,
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (sourceIndex === innerSourceIndex) {
            const idx = findInnerMapping(originalLine, originalColumn);
            if (idx !== -1) {
              const { chunks, mappingsData } = innerSourceMapLineData[originalLine - 1];
              const mi = idx * 5;
              const innerSourceIndex2 = mappingsData[mi + 1];
              const innerOriginalLine = mappingsData[mi + 2];
              let innerOriginalColumn = mappingsData[mi + 3];
              let innerNameIndex = mappingsData[mi + 4];
              if (innerSourceIndex2 >= 0) {
                const innerChunk = chunks[idx];
                const innerGeneratedColumn = mappingsData[mi];
                const locationInChunk = originalColumn - innerGeneratedColumn;
                if (locationInChunk > 0) {
                  let originalSourceLines = innerSourceIndex2 < innerSourceContentLines.length ? innerSourceContentLines[innerSourceIndex2] : null;
                  if (originalSourceLines === void 0) {
                    const originalSource = innerSourceContents[innerSourceIndex2];
                    originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;
                    innerSourceContentLines[innerSourceIndex2] = originalSourceLines;
                  }
                  if (originalSourceLines !== null) {
                    const originalChunk = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(
                      innerOriginalColumn,
                      innerOriginalColumn + locationInChunk
                    ) : "";
                    if (innerChunk.slice(0, locationInChunk) === originalChunk) {
                      innerOriginalColumn += locationInChunk;
                      innerNameIndex = -1;
                    }
                  }
                }
                let sourceIndex2 = innerSourceIndex2 < innerSourceIndexMapping.length ? innerSourceIndexMapping[innerSourceIndex2] : -2;
                if (sourceIndex2 === -2) {
                  const [source2, sourceContent] = innerSourceIndex2 < innerSourceIndexValueMapping.length ? innerSourceIndexValueMapping[innerSourceIndex2] : [null, void 0];
                  let globalIndex = sourceMapping.get(source2);
                  if (globalIndex === void 0) {
                    sourceMapping.set(source2, globalIndex = sourceMapping.size);
                    onSource(globalIndex, source2, sourceContent);
                  }
                  sourceIndex2 = globalIndex;
                  innerSourceIndexMapping[innerSourceIndex2] = sourceIndex2;
                }
                let finalNameIndex = -1;
                if (innerNameIndex >= 0) {
                  finalNameIndex = innerNameIndex < innerNameIndexMapping.length ? innerNameIndexMapping[innerNameIndex] : -2;
                  if (finalNameIndex === -2) {
                    const name = innerNameIndex < innerNameIndexValueMapping.length ? innerNameIndexValueMapping[innerNameIndex] : void 0;
                    if (name) {
                      let globalIndex = nameMapping.get(name);
                      if (globalIndex === void 0) {
                        nameMapping.set(name, globalIndex = nameMapping.size);
                        onName(globalIndex, name);
                      }
                      finalNameIndex = globalIndex;
                    } else {
                      finalNameIndex = -1;
                    }
                    innerNameIndexMapping[innerNameIndex] = finalNameIndex;
                  }
                } else if (nameIndex >= 0) {
                  let originalSourceLines = innerSourceContentLines[innerSourceIndex2];
                  if (originalSourceLines === void 0) {
                    const originalSource = innerSourceContents[innerSourceIndex2];
                    originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;
                    innerSourceContentLines[innerSourceIndex2] = originalSourceLines;
                  }
                  if (originalSourceLines !== null) {
                    const name = nameIndexValueMapping[nameIndex];
                    const originalName = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(
                      innerOriginalColumn,
                      innerOriginalColumn + name.length
                    ) : "";
                    if (name === originalName) {
                      finalNameIndex = nameIndex < nameIndexMapping.length ? nameIndexMapping[nameIndex] : -2;
                      if (finalNameIndex === -2) {
                        const name2 = nameIndexValueMapping[nameIndex];
                        if (name2) {
                          let globalIndex = nameMapping.get(name2);
                          if (globalIndex === void 0) {
                            nameMapping.set(name2, globalIndex = nameMapping.size);
                            onName(globalIndex, name2);
                          }
                          finalNameIndex = globalIndex;
                        } else {
                          finalNameIndex = -1;
                        }
                        nameIndexMapping[nameIndex] = finalNameIndex;
                      }
                    }
                  }
                }
                onChunk(
                  chunk,
                  generatedLine,
                  generatedColumn,
                  sourceIndex2,
                  innerOriginalLine,
                  innerOriginalColumn,
                  finalNameIndex
                );
                return;
              }
            }
            if (removeInnerSource) {
              onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
              return;
            } else {
              if (sourceIndexMapping[sourceIndex] === -2) {
                let globalIndex = sourceMapping.get(innerSourceName);
                if (globalIndex === void 0) {
                  sourceMapping.set(source, globalIndex = sourceMapping.size);
                  onSource(globalIndex, innerSourceName, innerSource);
                }
                sourceIndexMapping[sourceIndex] = globalIndex;
              }
            }
          }
          const finalSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];
          if (finalSourceIndex < 0) {
            onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
          } else {
            let finalNameIndex = -1;
            if (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {
              finalNameIndex = nameIndexMapping[nameIndex];
              if (finalNameIndex === -2) {
                const name = nameIndexValueMapping[nameIndex];
                let globalIndex = nameMapping.get(name);
                if (globalIndex === void 0) {
                  nameMapping.set(name, globalIndex = nameMapping.size);
                  onName(globalIndex, name);
                }
                finalNameIndex = globalIndex;
                nameIndexMapping[nameIndex] = finalNameIndex;
              }
            }
            onChunk(
              chunk,
              generatedLine,
              generatedColumn,
              finalSourceIndex,
              originalLine,
              originalColumn,
              finalNameIndex
            );
          }
        },
        (i, source2, sourceContent) => {
          if (source2 === innerSourceName) {
            innerSourceIndex = i;
            if (innerSource !== void 0)
              sourceContent = innerSource;
            else
              innerSource = sourceContent;
            sourceIndexMapping[i] = -2;
            streamChunksOfSourceMap(
              sourceContent,
              innerSourceMap,
              (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
                while (innerSourceMapLineData.length < generatedLine) {
                  innerSourceMapLineData.push({
                    mappingsData: [],
                    chunks: []
                  });
                }
                const data = innerSourceMapLineData[generatedLine - 1];
                data.mappingsData.push(
                  generatedColumn,
                  sourceIndex,
                  originalLine,
                  originalColumn,
                  nameIndex
                );
                data.chunks.push(chunk);
              },
              (i2, source3, sourceContent2) => {
                innerSourceContents[i2] = sourceContent2;
                innerSourceContentLines[i2] = void 0;
                innerSourceIndexMapping[i2] = -2;
                innerSourceIndexValueMapping[i2] = [source3, sourceContent2];
              },
              (i2, name) => {
                innerNameIndexMapping[i2] = -2;
                innerNameIndexValueMapping[i2] = name;
              },
              false,
              columns
            );
          } else {
            let globalIndex = sourceMapping.get(source2);
            if (globalIndex === void 0) {
              sourceMapping.set(source2, globalIndex = sourceMapping.size);
              onSource(globalIndex, source2, sourceContent);
            }
            sourceIndexMapping[i] = globalIndex;
          }
        },
        (i, name) => {
          nameIndexMapping[i] = -2;
          nameIndexValueMapping[i] = name;
        },
        finalSource,
        columns
      );
    };
    module2.exports = streamChunksOfCombinedSourceMap;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SourceMapSource.js
var require_SourceMapSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SourceMapSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var streamChunksOfCombinedSourceMap = require_streamChunksOfCombinedSourceMap();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var SourceMapSource2 = class extends Source3 {
      constructor(value, name, sourceMap, originalSource, innerSourceMap, removeOriginalSource) {
        super();
        const valueIsBuffer = Buffer.isBuffer(value);
        this._valueAsString = valueIsBuffer ? void 0 : value;
        this._valueAsBuffer = valueIsBuffer ? value : void 0;
        this._name = name;
        this._hasSourceMap = !!sourceMap;
        const sourceMapIsBuffer = Buffer.isBuffer(sourceMap);
        const sourceMapIsString = typeof sourceMap === "string";
        this._sourceMapAsObject = sourceMapIsBuffer || sourceMapIsString ? void 0 : sourceMap;
        this._sourceMapAsString = sourceMapIsString ? sourceMap : void 0;
        this._sourceMapAsBuffer = sourceMapIsBuffer ? sourceMap : void 0;
        this._hasOriginalSource = !!originalSource;
        const originalSourceIsBuffer = Buffer.isBuffer(originalSource);
        this._originalSourceAsString = originalSourceIsBuffer ? void 0 : originalSource;
        this._originalSourceAsBuffer = originalSourceIsBuffer ? originalSource : void 0;
        this._hasInnerSourceMap = !!innerSourceMap;
        const innerSourceMapIsBuffer = Buffer.isBuffer(innerSourceMap);
        const innerSourceMapIsString = typeof innerSourceMap === "string";
        this._innerSourceMapAsObject = innerSourceMapIsBuffer || innerSourceMapIsString ? void 0 : innerSourceMap;
        this._innerSourceMapAsString = innerSourceMapIsString ? innerSourceMap : void 0;
        this._innerSourceMapAsBuffer = innerSourceMapIsBuffer ? innerSourceMap : void 0;
        this._removeOriginalSource = removeOriginalSource;
      }
      _ensureValueBuffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._valueAsString, "utf-8");
        }
      }
      _ensureValueString() {
        if (this._valueAsString === void 0) {
          this._valueAsString = this._valueAsBuffer.toString("utf-8");
        }
      }
      _ensureOriginalSourceBuffer() {
        if (this._originalSourceAsBuffer === void 0 && this._hasOriginalSource) {
          this._originalSourceAsBuffer = Buffer.from(
            this._originalSourceAsString,
            "utf-8"
          );
        }
      }
      _ensureOriginalSourceString() {
        if (this._originalSourceAsString === void 0 && this._hasOriginalSource) {
          this._originalSourceAsString = this._originalSourceAsBuffer.toString(
            "utf-8"
          );
        }
      }
      _ensureInnerSourceMapObject() {
        if (this._innerSourceMapAsObject === void 0 && this._hasInnerSourceMap) {
          this._ensureInnerSourceMapString();
          this._innerSourceMapAsObject = JSON.parse(this._innerSourceMapAsString);
        }
      }
      _ensureInnerSourceMapBuffer() {
        if (this._innerSourceMapAsBuffer === void 0 && this._hasInnerSourceMap) {
          this._ensureInnerSourceMapString();
          this._innerSourceMapAsBuffer = Buffer.from(
            this._innerSourceMapAsString,
            "utf-8"
          );
        }
      }
      _ensureInnerSourceMapString() {
        if (this._innerSourceMapAsString === void 0 && this._hasInnerSourceMap) {
          if (this._innerSourceMapAsBuffer !== void 0) {
            this._innerSourceMapAsString = this._innerSourceMapAsBuffer.toString(
              "utf-8"
            );
          } else {
            this._innerSourceMapAsString = JSON.stringify(
              this._innerSourceMapAsObject
            );
          }
        }
      }
      _ensureSourceMapObject() {
        if (this._sourceMapAsObject === void 0) {
          this._ensureSourceMapString();
          this._sourceMapAsObject = JSON.parse(this._sourceMapAsString);
        }
      }
      _ensureSourceMapBuffer() {
        if (this._sourceMapAsBuffer === void 0) {
          this._ensureSourceMapString();
          this._sourceMapAsBuffer = Buffer.from(this._sourceMapAsString, "utf-8");
        }
      }
      _ensureSourceMapString() {
        if (this._sourceMapAsString === void 0) {
          if (this._sourceMapAsBuffer !== void 0) {
            this._sourceMapAsString = this._sourceMapAsBuffer.toString("utf-8");
          } else {
            this._sourceMapAsString = JSON.stringify(this._sourceMapAsObject);
          }
        }
      }
      getArgsAsBuffers() {
        this._ensureValueBuffer();
        this._ensureSourceMapBuffer();
        this._ensureOriginalSourceBuffer();
        this._ensureInnerSourceMapBuffer();
        return [
          this._valueAsBuffer,
          this._name,
          this._sourceMapAsBuffer,
          this._originalSourceAsBuffer,
          this._innerSourceMapAsBuffer,
          this._removeOriginalSource
        ];
      }
      buffer() {
        this._ensureValueBuffer();
        return this._valueAsBuffer;
      }
      source() {
        this._ensureValueString();
        return this._valueAsString;
      }
      map(options) {
        if (!this._hasInnerSourceMap) {
          this._ensureSourceMapObject();
          return this._sourceMapAsObject;
        }
        return getMap(this, options);
      }
      sourceAndMap(options) {
        if (!this._hasInnerSourceMap) {
          this._ensureValueString();
          this._ensureSourceMapObject();
          return {
            source: this._valueAsString,
            map: this._sourceMapAsObject
          };
        }
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        this._ensureValueString();
        this._ensureSourceMapObject();
        this._ensureOriginalSourceString();
        if (this._hasInnerSourceMap) {
          this._ensureInnerSourceMapObject();
          return streamChunksOfCombinedSourceMap(
            this._valueAsString,
            this._sourceMapAsObject,
            this._name,
            this._originalSourceAsString,
            this._innerSourceMapAsObject,
            this._removeOriginalSource,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        } else {
          return streamChunksOfSourceMap(
            this._valueAsString,
            this._sourceMapAsObject,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        }
      }
      updateHash(hash) {
        this._ensureValueBuffer();
        this._ensureSourceMapBuffer();
        this._ensureOriginalSourceBuffer();
        this._ensureInnerSourceMapBuffer();
        hash.update("SourceMapSource");
        hash.update(this._valueAsBuffer);
        hash.update(this._sourceMapAsBuffer);
        if (this._hasOriginalSource) {
          hash.update(this._originalSourceAsBuffer);
        }
        if (this._hasInnerSourceMap) {
          hash.update(this._innerSourceMapAsBuffer);
        }
        hash.update(this._removeOriginalSource ? "true" : "false");
      }
    };
    module2.exports = SourceMapSource2;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunks.js
var require_streamChunks = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunks.js"(exports, module2) {
    "use strict";
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    module2.exports = (source, options, onChunk, onSource, onName) => {
      if (typeof source.streamChunks === "function") {
        return source.streamChunks(options, onChunk, onSource, onName);
      } else {
        const sourceAndMap = source.sourceAndMap(options);
        if (sourceAndMap.map) {
          return streamChunksOfSourceMap(
            sourceAndMap.source,
            sourceAndMap.map,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        } else {
          return streamChunksOfRawSource(
            sourceAndMap.source,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource)
          );
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js
var require_streamAndGetSourceAndMap = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js"(exports, module2) {
    "use strict";
    var createMappingsSerializer = require_createMappingsSerializer();
    var streamChunks = require_streamChunks();
    var streamAndGetSourceAndMap = (inputSource, options, onChunk, onSource, onName) => {
      let code = "";
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(
        Object.assign({}, options, { columns: true })
      );
      const finalSource = !!(options && options.finalSource);
      const { generatedLine, generatedColumn, source } = streamChunks(
        inputSource,
        options,
        (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (chunk !== void 0)
            code += chunk;
          mappings += addMapping(
            generatedLine2,
            generatedColumn2,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
          return onChunk(
            finalSource ? void 0 : chunk,
            generatedLine2,
            generatedColumn2,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
          return onSource(sourceIndex, source2, sourceContent);
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
          return onName(nameIndex, name);
        }
      );
      const resultSource = source !== void 0 ? source : code;
      return {
        result: {
          generatedLine,
          generatedColumn,
          source: finalSource ? resultSource : void 0
        },
        source: resultSource,
        map: mappings.length > 0 ? {
          version: 3,
          file: "x",
          mappings,
          sources,
          sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
          names
        } : null
      };
    };
    module2.exports = streamAndGetSourceAndMap;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CachedSource.js
var require_CachedSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CachedSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var streamAndGetSourceAndMap = require_streamAndGetSourceAndMap();
    var mapToBufferedMap = (map) => {
      if (typeof map !== "object" || !map)
        return map;
      const bufferedMap = Object.assign({}, map);
      if (map.mappings) {
        bufferedMap.mappings = Buffer.from(map.mappings, "utf-8");
      }
      if (map.sourcesContent) {
        bufferedMap.sourcesContent = map.sourcesContent.map(
          (str) => str && Buffer.from(str, "utf-8")
        );
      }
      return bufferedMap;
    };
    var bufferedMapToMap = (bufferedMap) => {
      if (typeof bufferedMap !== "object" || !bufferedMap)
        return bufferedMap;
      const map = Object.assign({}, bufferedMap);
      if (bufferedMap.mappings) {
        map.mappings = bufferedMap.mappings.toString("utf-8");
      }
      if (bufferedMap.sourcesContent) {
        map.sourcesContent = bufferedMap.sourcesContent.map(
          (buffer) => buffer && buffer.toString("utf-8")
        );
      }
      return map;
    };
    var CachedSource = class extends Source3 {
      constructor(source, cachedData) {
        super();
        this._source = source;
        this._cachedSourceType = cachedData ? cachedData.source : void 0;
        this._cachedSource = void 0;
        this._cachedBuffer = cachedData ? cachedData.buffer : void 0;
        this._cachedSize = cachedData ? cachedData.size : void 0;
        this._cachedMaps = cachedData ? cachedData.maps : /* @__PURE__ */ new Map();
        this._cachedHashUpdate = cachedData ? cachedData.hash : void 0;
      }
      getCachedData() {
        const bufferedMaps = /* @__PURE__ */ new Map();
        for (const pair of this._cachedMaps) {
          let cacheEntry = pair[1];
          if (cacheEntry.bufferedMap === void 0) {
            cacheEntry.bufferedMap = mapToBufferedMap(
              this._getMapFromCacheEntry(cacheEntry)
            );
          }
          bufferedMaps.set(pair[0], {
            map: void 0,
            bufferedMap: cacheEntry.bufferedMap
          });
        }
        if (this._cachedSource) {
          this.buffer();
        }
        return {
          buffer: this._cachedBuffer,
          source: this._cachedSourceType !== void 0 ? this._cachedSourceType : typeof this._cachedSource === "string" ? true : Buffer.isBuffer(this._cachedSource) ? false : void 0,
          size: this._cachedSize,
          maps: bufferedMaps,
          hash: this._cachedHashUpdate
        };
      }
      originalLazy() {
        return this._source;
      }
      original() {
        if (typeof this._source === "function")
          this._source = this._source();
        return this._source;
      }
      source() {
        const source = this._getCachedSource();
        if (source !== void 0)
          return source;
        return this._cachedSource = this.original().source();
      }
      _getMapFromCacheEntry(cacheEntry) {
        if (cacheEntry.map !== void 0) {
          return cacheEntry.map;
        } else if (cacheEntry.bufferedMap !== void 0) {
          return cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap);
        }
      }
      _getCachedSource() {
        if (this._cachedSource !== void 0)
          return this._cachedSource;
        if (this._cachedBuffer && this._cachedSourceType !== void 0) {
          return this._cachedSource = this._cachedSourceType ? this._cachedBuffer.toString("utf-8") : this._cachedBuffer;
        }
      }
      buffer() {
        if (this._cachedBuffer !== void 0)
          return this._cachedBuffer;
        if (this._cachedSource !== void 0) {
          if (Buffer.isBuffer(this._cachedSource)) {
            return this._cachedBuffer = this._cachedSource;
          }
          return this._cachedBuffer = Buffer.from(this._cachedSource, "utf-8");
        }
        if (typeof this.original().buffer === "function") {
          return this._cachedBuffer = this.original().buffer();
        }
        const bufferOrString = this.source();
        if (Buffer.isBuffer(bufferOrString)) {
          return this._cachedBuffer = bufferOrString;
        }
        return this._cachedBuffer = Buffer.from(bufferOrString, "utf-8");
      }
      size() {
        if (this._cachedSize !== void 0)
          return this._cachedSize;
        if (this._cachedBuffer !== void 0) {
          return this._cachedSize = this._cachedBuffer.length;
        }
        const source = this._getCachedSource();
        if (source !== void 0) {
          return this._cachedSize = Buffer.byteLength(source);
        }
        return this._cachedSize = this.original().size();
      }
      sourceAndMap(options) {
        const key = options ? JSON.stringify(options) : "{}";
        const cacheEntry = this._cachedMaps.get(key);
        if (cacheEntry !== void 0) {
          const map2 = this._getMapFromCacheEntry(cacheEntry);
          return { source: this.source(), map: map2 };
        }
        let source = this._getCachedSource();
        let map;
        if (source !== void 0) {
          map = this.original().map(options);
        } else {
          const sourceAndMap = this.original().sourceAndMap(options);
          source = sourceAndMap.source;
          map = sourceAndMap.map;
          this._cachedSource = source;
        }
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return { source, map };
      }
      streamChunks(options, onChunk, onSource, onName) {
        const key = options ? JSON.stringify(options) : "{}";
        if (this._cachedMaps.has(key) && (this._cachedBuffer !== void 0 || this._cachedSource !== void 0)) {
          const { source: source2, map: map2 } = this.sourceAndMap(options);
          if (map2) {
            return streamChunksOfSourceMap(
              source2,
              map2,
              onChunk,
              onSource,
              onName,
              !!(options && options.finalSource),
              true
            );
          } else {
            return streamChunksOfRawSource(
              source2,
              onChunk,
              onSource,
              onName,
              !!(options && options.finalSource)
            );
          }
        }
        const { result, source, map } = streamAndGetSourceAndMap(
          this.original(),
          options,
          onChunk,
          onSource,
          onName
        );
        this._cachedSource = source;
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return result;
      }
      map(options) {
        const key = options ? JSON.stringify(options) : "{}";
        const cacheEntry = this._cachedMaps.get(key);
        if (cacheEntry !== void 0) {
          return this._getMapFromCacheEntry(cacheEntry);
        }
        const map = this.original().map(options);
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return map;
      }
      updateHash(hash) {
        if (this._cachedHashUpdate !== void 0) {
          for (const item of this._cachedHashUpdate)
            hash.update(item);
          return;
        }
        const update = [];
        let currentString = void 0;
        const tracker = {
          update: (item) => {
            if (typeof item === "string" && item.length < 10240) {
              if (currentString === void 0) {
                currentString = item;
              } else {
                currentString += item;
                if (currentString.length > 102400) {
                  update.push(Buffer.from(currentString));
                  currentString = void 0;
                }
              }
            } else {
              if (currentString !== void 0) {
                update.push(Buffer.from(currentString));
                currentString = void 0;
              }
              update.push(item);
            }
          }
        };
        this.original().updateHash(tracker);
        if (currentString !== void 0) {
          update.push(Buffer.from(currentString));
        }
        for (const item of update)
          hash.update(item);
        this._cachedHashUpdate = update;
      }
    };
    module2.exports = CachedSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ConcatSource.js
var require_ConcatSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ConcatSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var RawSource = require_RawSource();
    var streamChunks = require_streamChunks();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var stringsAsRawSources = /* @__PURE__ */ new WeakSet();
    var ConcatSource3 = class _ConcatSource extends Source3 {
      constructor() {
        super();
        this._children = [];
        for (let i = 0; i < arguments.length; i++) {
          const item = arguments[i];
          if (item instanceof _ConcatSource) {
            for (const child of item._children) {
              this._children.push(child);
            }
          } else {
            this._children.push(item);
          }
        }
        this._isOptimized = arguments.length === 0;
      }
      getChildren() {
        if (!this._isOptimized)
          this._optimize();
        return this._children;
      }
      add(item) {
        if (item instanceof _ConcatSource) {
          for (const child of item._children) {
            this._children.push(child);
          }
        } else {
          this._children.push(item);
        }
        this._isOptimized = false;
      }
      addAllSkipOptimizing(items) {
        for (const item of items) {
          this._children.push(item);
        }
      }
      buffer() {
        if (!this._isOptimized)
          this._optimize();
        const buffers = [];
        for (const child of this._children) {
          if (typeof child.buffer === "function") {
            buffers.push(child.buffer());
          } else {
            const bufferOrString = child.source();
            if (Buffer.isBuffer(bufferOrString)) {
              buffers.push(bufferOrString);
            } else {
              buffers.push(Buffer.from(bufferOrString, "utf-8"));
            }
          }
        }
        return Buffer.concat(buffers);
      }
      source() {
        if (!this._isOptimized)
          this._optimize();
        let source = "";
        for (const child of this._children) {
          source += child.source();
        }
        return source;
      }
      size() {
        if (!this._isOptimized)
          this._optimize();
        let size = 0;
        for (const child of this._children) {
          size += child.size();
        }
        return size;
      }
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        if (!this._isOptimized)
          this._optimize();
        if (this._children.length === 1)
          return this._children[0].streamChunks(options, onChunk, onSource, onName);
        let currentLineOffset = 0;
        let currentColumnOffset = 0;
        let sourceMapping = /* @__PURE__ */ new Map();
        let nameMapping = /* @__PURE__ */ new Map();
        const finalSource = !!(options && options.finalSource);
        let code = "";
        let needToCloseMapping = false;
        for (const item of this._children) {
          const sourceIndexMapping = [];
          const nameIndexMapping = [];
          let lastMappingLine = 0;
          const { generatedLine, generatedColumn, source } = streamChunks(
            item,
            options,
            // eslint-disable-next-line no-loop-func
            (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
              const line = generatedLine2 + currentLineOffset;
              const column = generatedLine2 === 1 ? generatedColumn2 + currentColumnOffset : generatedColumn2;
              if (needToCloseMapping) {
                if (generatedLine2 !== 1 || generatedColumn2 !== 0) {
                  onChunk(
                    void 0,
                    currentLineOffset + 1,
                    currentColumnOffset,
                    -1,
                    -1,
                    -1,
                    -1
                  );
                }
                needToCloseMapping = false;
              }
              const resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];
              const resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];
              lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine2;
              if (finalSource) {
                if (chunk !== void 0)
                  code += chunk;
                if (resultSourceIndex >= 0) {
                  onChunk(
                    void 0,
                    line,
                    column,
                    resultSourceIndex,
                    originalLine,
                    originalColumn,
                    resultNameIndex
                  );
                }
              } else {
                if (resultSourceIndex < 0) {
                  onChunk(chunk, line, column, -1, -1, -1, -1);
                } else {
                  onChunk(
                    chunk,
                    line,
                    column,
                    resultSourceIndex,
                    originalLine,
                    originalColumn,
                    resultNameIndex
                  );
                }
              }
            },
            (i, source2, sourceContent) => {
              let globalIndex = sourceMapping.get(source2);
              if (globalIndex === void 0) {
                sourceMapping.set(source2, globalIndex = sourceMapping.size);
                onSource(globalIndex, source2, sourceContent);
              }
              sourceIndexMapping[i] = globalIndex;
            },
            (i, name) => {
              let globalIndex = nameMapping.get(name);
              if (globalIndex === void 0) {
                nameMapping.set(name, globalIndex = nameMapping.size);
                onName(globalIndex, name);
              }
              nameIndexMapping[i] = globalIndex;
            }
          );
          if (source !== void 0)
            code += source;
          if (needToCloseMapping) {
            if (generatedLine !== 1 || generatedColumn !== 0) {
              onChunk(
                void 0,
                currentLineOffset + 1,
                currentColumnOffset,
                -1,
                -1,
                -1,
                -1
              );
              needToCloseMapping = false;
            }
          }
          if (generatedLine > 1) {
            currentColumnOffset = generatedColumn;
          } else {
            currentColumnOffset += generatedColumn;
          }
          needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine;
          currentLineOffset += generatedLine - 1;
        }
        return {
          generatedLine: currentLineOffset + 1,
          generatedColumn: currentColumnOffset,
          source: finalSource ? code : void 0
        };
      }
      updateHash(hash) {
        if (!this._isOptimized)
          this._optimize();
        hash.update("ConcatSource");
        for (const item of this._children) {
          item.updateHash(hash);
        }
      }
      _optimize() {
        const newChildren = [];
        let currentString = void 0;
        let currentRawSources = void 0;
        const addStringToRawSources = (string) => {
          if (currentRawSources === void 0) {
            currentRawSources = string;
          } else if (Array.isArray(currentRawSources)) {
            currentRawSources.push(string);
          } else {
            currentRawSources = [
              typeof currentRawSources === "string" ? currentRawSources : currentRawSources.source(),
              string
            ];
          }
        };
        const addSourceToRawSources = (source) => {
          if (currentRawSources === void 0) {
            currentRawSources = source;
          } else if (Array.isArray(currentRawSources)) {
            currentRawSources.push(source.source());
          } else {
            currentRawSources = [
              typeof currentRawSources === "string" ? currentRawSources : currentRawSources.source(),
              source.source()
            ];
          }
        };
        const mergeRawSources = () => {
          if (Array.isArray(currentRawSources)) {
            const rawSource = new RawSource(currentRawSources.join(""));
            stringsAsRawSources.add(rawSource);
            newChildren.push(rawSource);
          } else if (typeof currentRawSources === "string") {
            const rawSource = new RawSource(currentRawSources);
            stringsAsRawSources.add(rawSource);
            newChildren.push(rawSource);
          } else {
            newChildren.push(currentRawSources);
          }
        };
        for (const child of this._children) {
          if (typeof child === "string") {
            if (currentString === void 0) {
              currentString = child;
            } else {
              currentString += child;
            }
          } else {
            if (currentString !== void 0) {
              addStringToRawSources(currentString);
              currentString = void 0;
            }
            if (stringsAsRawSources.has(child)) {
              addSourceToRawSources(child);
            } else {
              if (currentRawSources !== void 0) {
                mergeRawSources();
                currentRawSources = void 0;
              }
              newChildren.push(child);
            }
          }
        }
        if (currentString !== void 0) {
          addStringToRawSources(currentString);
        }
        if (currentRawSources !== void 0) {
          mergeRawSources();
        }
        this._children = newChildren;
        this._isOptimized = true;
      }
    };
    module2.exports = ConcatSource3;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ReplaceSource.js
var require_ReplaceSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ReplaceSource.js"(exports, module2) {
    "use strict";
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var streamChunks = require_streamChunks();
    var Source3 = require_Source();
    var splitIntoLines = require_splitIntoLines();
    var hasStableSort = typeof process === "object" && process.versions && typeof process.versions.v8 === "string" && !/^[0-6]\./.test(process.versions.v8);
    var MAX_SOURCE_POSITION = 536870912;
    var Replacement = class {
      constructor(start, end, content, name) {
        this.start = start;
        this.end = end;
        this.content = content;
        this.name = name;
        if (!hasStableSort) {
          this.index = -1;
        }
      }
    };
    var ReplaceSource = class extends Source3 {
      constructor(source, name) {
        super();
        this._source = source;
        this._name = name;
        this._replacements = [];
        this._isSorted = true;
      }
      getName() {
        return this._name;
      }
      getReplacements() {
        this._sortReplacements();
        return this._replacements;
      }
      replace(start, end, newValue, name) {
        if (typeof newValue !== "string")
          throw new Error(
            "insertion must be a string, but is a " + typeof newValue
          );
        this._replacements.push(new Replacement(start, end, newValue, name));
        this._isSorted = false;
      }
      insert(pos, newValue, name) {
        if (typeof newValue !== "string")
          throw new Error(
            "insertion must be a string, but is a " + typeof newValue + ": " + newValue
          );
        this._replacements.push(new Replacement(pos, pos - 1, newValue, name));
        this._isSorted = false;
      }
      source() {
        if (this._replacements.length === 0) {
          return this._source.source();
        }
        let current = this._source.source();
        let pos = 0;
        const result = [];
        this._sortReplacements();
        for (const replacement of this._replacements) {
          const start = Math.floor(replacement.start);
          const end = Math.floor(replacement.end + 1);
          if (pos < start) {
            const offset = start - pos;
            result.push(current.slice(0, offset));
            current = current.slice(offset);
            pos = start;
          }
          result.push(replacement.content);
          if (pos < end) {
            const offset = end - pos;
            current = current.slice(offset);
            pos = end;
          }
        }
        result.push(current);
        return result.join("");
      }
      map(options) {
        if (this._replacements.length === 0) {
          return this._source.map(options);
        }
        return getMap(this, options);
      }
      sourceAndMap(options) {
        if (this._replacements.length === 0) {
          return this._source.sourceAndMap(options);
        }
        return getSourceAndMap(this, options);
      }
      original() {
        return this._source;
      }
      _sortReplacements() {
        if (this._isSorted)
          return;
        if (hasStableSort) {
          this._replacements.sort(function(a, b) {
            const diff1 = a.start - b.start;
            if (diff1 !== 0)
              return diff1;
            const diff2 = a.end - b.end;
            if (diff2 !== 0)
              return diff2;
            return 0;
          });
        } else {
          this._replacements.forEach((repl, i) => repl.index = i);
          this._replacements.sort(function(a, b) {
            const diff1 = a.start - b.start;
            if (diff1 !== 0)
              return diff1;
            const diff2 = a.end - b.end;
            if (diff2 !== 0)
              return diff2;
            return a.index - b.index;
          });
        }
        this._isSorted = true;
      }
      streamChunks(options, onChunk, onSource, onName) {
        this._sortReplacements();
        const repls = this._replacements;
        let pos = 0;
        let i = 0;
        let replacmentEnd = -1;
        let nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;
        let generatedLineOffset = 0;
        let generatedColumnOffset = 0;
        let generatedColumnOffsetLine = 0;
        const sourceContents = [];
        const nameMapping = /* @__PURE__ */ new Map();
        const nameIndexMapping = [];
        const checkOriginalContent = (sourceIndex, line2, column, expectedChunk) => {
          let content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : void 0;
          if (content === void 0)
            return false;
          if (typeof content === "string") {
            content = splitIntoLines(content);
            sourceContents[sourceIndex] = content;
          }
          const contentLine = line2 <= content.length ? content[line2 - 1] : null;
          if (contentLine === null)
            return false;
          return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;
        };
        let { generatedLine, generatedColumn } = streamChunks(
          this._source,
          Object.assign({}, options, { finalSource: false }),
          (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
            let chunkPos = 0;
            let endPos = pos + chunk.length;
            if (replacmentEnd > pos) {
              if (replacmentEnd >= endPos) {
                const line3 = generatedLine2 + generatedLineOffset;
                if (chunk.endsWith("\n")) {
                  generatedLineOffset--;
                  if (generatedColumnOffsetLine === line3) {
                    generatedColumnOffset += generatedColumn2;
                  }
                } else if (generatedColumnOffsetLine === line3) {
                  generatedColumnOffset -= chunk.length;
                } else {
                  generatedColumnOffset = -chunk.length;
                  generatedColumnOffsetLine = line3;
                }
                pos = endPos;
                return;
              }
              chunkPos = replacmentEnd - pos;
              if (checkOriginalContent(
                sourceIndex,
                originalLine,
                originalColumn,
                chunk.slice(0, chunkPos)
              )) {
                originalColumn += chunkPos;
              }
              pos += chunkPos;
              const line2 = generatedLine2 + generatedLineOffset;
              if (generatedColumnOffsetLine === line2) {
                generatedColumnOffset -= chunkPos;
              } else {
                generatedColumnOffset = -chunkPos;
                generatedColumnOffsetLine = line2;
              }
              generatedColumn2 += chunkPos;
            }
            if (nextReplacement < endPos) {
              do {
                let line2 = generatedLine2 + generatedLineOffset;
                if (nextReplacement > pos) {
                  const offset2 = nextReplacement - pos;
                  const chunkSlice = chunk.slice(chunkPos, chunkPos + offset2);
                  onChunk(
                    chunkSlice,
                    line2,
                    generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]
                  );
                  generatedColumn2 += offset2;
                  chunkPos += offset2;
                  pos = nextReplacement;
                  if (checkOriginalContent(
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    chunkSlice
                  )) {
                    originalColumn += chunkSlice.length;
                  }
                }
                const { content, name } = repls[i];
                let matches2 = splitIntoLines(content);
                let replacementNameIndex = nameIndex;
                if (sourceIndex >= 0 && name) {
                  let globalIndex = nameMapping.get(name);
                  if (globalIndex === void 0) {
                    globalIndex = nameMapping.size;
                    nameMapping.set(name, globalIndex);
                    onName(globalIndex, name);
                  }
                  replacementNameIndex = globalIndex;
                }
                for (let m = 0; m < matches2.length; m++) {
                  const contentLine = matches2[m];
                  onChunk(
                    contentLine,
                    line2,
                    generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    replacementNameIndex
                  );
                  replacementNameIndex = -1;
                  if (m === matches2.length - 1 && !contentLine.endsWith("\n")) {
                    if (generatedColumnOffsetLine === line2) {
                      generatedColumnOffset += contentLine.length;
                    } else {
                      generatedColumnOffset = contentLine.length;
                      generatedColumnOffsetLine = line2;
                    }
                  } else {
                    generatedLineOffset++;
                    line2++;
                    generatedColumnOffset = -generatedColumn2;
                    generatedColumnOffsetLine = line2;
                  }
                }
                replacmentEnd = Math.max(
                  replacmentEnd,
                  Math.floor(repls[i].end + 1)
                );
                i++;
                nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;
                const offset = chunk.length - endPos + replacmentEnd - chunkPos;
                if (offset > 0) {
                  if (replacmentEnd >= endPos) {
                    let line4 = generatedLine2 + generatedLineOffset;
                    if (chunk.endsWith("\n")) {
                      generatedLineOffset--;
                      if (generatedColumnOffsetLine === line4) {
                        generatedColumnOffset += generatedColumn2;
                      }
                    } else if (generatedColumnOffsetLine === line4) {
                      generatedColumnOffset -= chunk.length - chunkPos;
                    } else {
                      generatedColumnOffset = chunkPos - chunk.length;
                      generatedColumnOffsetLine = line4;
                    }
                    pos = endPos;
                    return;
                  }
                  const line3 = generatedLine2 + generatedLineOffset;
                  if (checkOriginalContent(
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    chunk.slice(chunkPos, chunkPos + offset)
                  )) {
                    originalColumn += offset;
                  }
                  chunkPos += offset;
                  pos += offset;
                  if (generatedColumnOffsetLine === line3) {
                    generatedColumnOffset -= offset;
                  } else {
                    generatedColumnOffset = -offset;
                    generatedColumnOffsetLine = line3;
                  }
                  generatedColumn2 += offset;
                }
              } while (nextReplacement < endPos);
            }
            if (chunkPos < chunk.length) {
              const chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);
              const line2 = generatedLine2 + generatedLineOffset;
              onChunk(
                chunkSlice,
                line2,
                generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                sourceIndex,
                originalLine,
                originalColumn,
                nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]
              );
            }
            pos = endPos;
          },
          (sourceIndex, source, sourceContent) => {
            while (sourceContents.length < sourceIndex)
              sourceContents.push(void 0);
            sourceContents[sourceIndex] = sourceContent;
            onSource(sourceIndex, source, sourceContent);
          },
          (nameIndex, name) => {
            let globalIndex = nameMapping.get(name);
            if (globalIndex === void 0) {
              globalIndex = nameMapping.size;
              nameMapping.set(name, globalIndex);
              onName(globalIndex, name);
            }
            nameIndexMapping[nameIndex] = globalIndex;
          }
        );
        let remainer = "";
        for (; i < repls.length; i++) {
          remainer += repls[i].content;
        }
        let line = generatedLine + generatedLineOffset;
        let matches = splitIntoLines(remainer);
        for (let m = 0; m < matches.length; m++) {
          const contentLine = matches[m];
          onChunk(
            contentLine,
            line,
            generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0),
            -1,
            -1,
            -1,
            -1
          );
          if (m === matches.length - 1 && !contentLine.endsWith("\n")) {
            if (generatedColumnOffsetLine === line) {
              generatedColumnOffset += contentLine.length;
            } else {
              generatedColumnOffset = contentLine.length;
              generatedColumnOffsetLine = line;
            }
          } else {
            generatedLineOffset++;
            line++;
            generatedColumnOffset = -generatedColumn;
            generatedColumnOffsetLine = line;
          }
        }
        return {
          generatedLine: line,
          generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)
        };
      }
      updateHash(hash) {
        this._sortReplacements();
        hash.update("ReplaceSource");
        this._source.updateHash(hash);
        hash.update(this._name || "");
        for (const repl of this._replacements) {
          hash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);
        }
      }
    };
    module2.exports = ReplaceSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/PrefixSource.js
var require_PrefixSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/PrefixSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var RawSource = require_RawSource();
    var streamChunks = require_streamChunks();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var REPLACE_REGEX = /\n(?=.|\s)/g;
    var PrefixSource = class extends Source3 {
      constructor(prefix, source) {
        super();
        this._source = typeof source === "string" || Buffer.isBuffer(source) ? new RawSource(source, true) : source;
        this._prefix = prefix;
      }
      getPrefix() {
        return this._prefix;
      }
      original() {
        return this._source;
      }
      source() {
        const node = this._source.source();
        const prefix = this._prefix;
        return prefix + node.replace(REPLACE_REGEX, "\n" + prefix);
      }
      // TODO efficient buffer() implementation
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        const prefix = this._prefix;
        const prefixOffset = prefix.length;
        const linesOnly = !!(options && options.columns === false);
        const { generatedLine, generatedColumn, source } = streamChunks(
          this._source,
          options,
          (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
            if (generatedColumn2 !== 0) {
              generatedColumn2 += prefixOffset;
            } else if (chunk !== void 0) {
              if (linesOnly || sourceIndex < 0) {
                chunk = prefix + chunk;
              } else if (prefixOffset > 0) {
                onChunk(prefix, generatedLine2, generatedColumn2, -1, -1, -1, -1);
                generatedColumn2 += prefixOffset;
              }
            } else if (!linesOnly) {
              generatedColumn2 += prefixOffset;
            }
            onChunk(
              chunk,
              generatedLine2,
              generatedColumn2,
              sourceIndex,
              originalLine,
              originalColumn,
              nameIndex
            );
          },
          onSource,
          onName
        );
        return {
          generatedLine,
          generatedColumn: generatedColumn === 0 ? 0 : prefixOffset + generatedColumn,
          source: source !== void 0 ? prefix + source.replace(REPLACE_REGEX, "\n" + prefix) : void 0
        };
      }
      updateHash(hash) {
        hash.update("PrefixSource");
        this._source.updateHash(hash);
        hash.update(this._prefix);
      }
    };
    module2.exports = PrefixSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SizeOnlySource.js
var require_SizeOnlySource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SizeOnlySource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var SizeOnlySource = class extends Source3 {
      constructor(size) {
        super();
        this._size = size;
      }
      _error() {
        return new Error(
          "Content and Map of this Source is not available (only size() is supported)"
        );
      }
      size() {
        return this._size;
      }
      source() {
        throw this._error();
      }
      buffer() {
        throw this._error();
      }
      map(options) {
        throw this._error();
      }
      updateHash() {
        throw this._error();
      }
    };
    module2.exports = SizeOnlySource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CompatSource.js
var require_CompatSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CompatSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var CompatSource = class _CompatSource extends Source3 {
      static from(sourceLike) {
        return sourceLike instanceof Source3 ? sourceLike : new _CompatSource(sourceLike);
      }
      constructor(sourceLike) {
        super();
        this._sourceLike = sourceLike;
      }
      source() {
        return this._sourceLike.source();
      }
      buffer() {
        if (typeof this._sourceLike.buffer === "function") {
          return this._sourceLike.buffer();
        }
        return super.buffer();
      }
      size() {
        if (typeof this._sourceLike.size === "function") {
          return this._sourceLike.size();
        }
        return super.size();
      }
      map(options) {
        if (typeof this._sourceLike.map === "function") {
          return this._sourceLike.map(options);
        }
        return super.map(options);
      }
      sourceAndMap(options) {
        if (typeof this._sourceLike.sourceAndMap === "function") {
          return this._sourceLike.sourceAndMap(options);
        }
        return super.sourceAndMap(options);
      }
      updateHash(hash) {
        if (typeof this._sourceLike.updateHash === "function") {
          return this._sourceLike.updateHash(hash);
        }
        if (typeof this._sourceLike.map === "function") {
          throw new Error(
            "A Source-like object with a 'map' method must also provide an 'updateHash' method"
          );
        }
        hash.update(this.buffer());
      }
    };
    module2.exports = CompatSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/index.js"(exports) {
    var defineExport = (name, fn) => {
      let value;
      Object.defineProperty(exports, name, {
        get: () => {
          if (fn !== void 0) {
            value = fn();
            fn = void 0;
          }
          return value;
        },
        configurable: true
      });
    };
    defineExport("Source", () => require_Source());
    defineExport("RawSource", () => require_RawSource());
    defineExport("OriginalSource", () => require_OriginalSource());
    defineExport("SourceMapSource", () => require_SourceMapSource());
    defineExport("CachedSource", () => require_CachedSource());
    defineExport("ConcatSource", () => require_ConcatSource());
    defineExport("ReplaceSource", () => require_ReplaceSource());
    defineExport("PrefixSource", () => require_PrefixSource());
    defineExport("SizeOnlySource", () => require_SizeOnlySource());
    defineExport("CompatSource", () => require_CompatSource());
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      let encoded = "";
      let digit;
      let vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      }
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      const match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      let url3 = "";
      if (aParsedUrl.scheme) {
        url3 += aParsedUrl.scheme + ":";
      }
      url3 += "//";
      if (aParsedUrl.auth) {
        url3 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url3 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url3 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url3 += aParsedUrl.path;
      }
      return url3;
    }
    exports.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      const cache = [];
      return function(input) {
        for (let i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            const temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        const result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      let path5 = aPath;
      const url3 = urlParse(aPath);
      if (url3) {
        if (!url3.path) {
          return aPath;
        }
        path5 = url3.path;
      }
      const isAbsolute = exports.isAbsolute(path5);
      const parts = [];
      let start = 0;
      let i = 0;
      while (true) {
        start = i;
        i = path5.indexOf("/", start);
        if (i === -1) {
          parts.push(path5.slice(start));
          break;
        } else {
          parts.push(path5.slice(start, i));
          while (i < path5.length && path5[i] === "/") {
            i++;
          }
        }
      }
      let up = 0;
      for (i = parts.length - 1; i >= 0; i--) {
        const part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path5 = parts.join("/");
      if (path5 === "") {
        path5 = isAbsolute ? "/" : ".";
      }
      if (url3) {
        url3.path = path5;
        return urlGenerate(url3);
      }
      return path5;
    });
    exports.normalize = normalize;
    function join2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      const aPathUrl = urlParse(aPath);
      const aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      const joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join2;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      let level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        const index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      const obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      const length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (let i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      let cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      let cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      let cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        const parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          const index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join2(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/array-set.js"(exports) {
    var ArraySet = class _ArraySet {
      constructor() {
        this._array = [];
        this._set = /* @__PURE__ */ new Map();
      }
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      static fromArray(aArray, aAllowDuplicates) {
        const set = new _ArraySet();
        for (let i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      }
      /**
       * Return how many unique items are in this ArraySet. If duplicates have been
       * added, than those do not count towards the size.
       *
       * @returns Number
       */
      size() {
        return this._set.size;
      }
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      add(aStr, aAllowDuplicates) {
        const isDuplicate = this.has(aStr);
        const idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set.set(aStr, idx);
        }
      }
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      has(aStr) {
        return this._set.has(aStr);
      }
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      indexOf(aStr) {
        const idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
        throw new Error('"' + aStr + '" is not in the set.');
      }
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      }
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      toArray() {
        return this._array.slice();
      }
    };
    exports.ArraySet = ArraySet;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      const lineA = mappingA.generatedLine;
      const lineB = mappingB.generatedLine;
      const columnA = mappingA.generatedColumn;
      const columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    var MappingList = class {
      constructor() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      unsortedForEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      }
      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      }
      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      }
    };
    exports.MappingList = MappingList;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    var SourceMapGenerator2 = class _SourceMapGenerator {
      constructor(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      static fromSourceMap(aSourceMapConsumer) {
        const sourceRoot = aSourceMapConsumer.sourceRoot;
        const generator = new _SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          const newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          let sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          const content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      }
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      addMapping(aArgs) {
        const generated = util.getArg(aArgs, "generated");
        const original = util.getArg(aArgs, "original", null);
        let source = util.getArg(aArgs, "source", null);
        let name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      }
      /**
       * Set the source content for a source file.
       */
      setSourceContent(aSourceFile, aSourceContent) {
        let source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      }
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        let sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        const sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        const newSources = this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;
        const newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            const original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          const source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          const name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(srcFile) {
          const content = aSourceMapConsumer.sourceContentFor(srcFile);
          if (content != null) {
            if (aSourceMapPath != null) {
              srcFile = util.join(aSourceMapPath, srcFile);
            }
            if (sourceRoot != null) {
              srcFile = util.relative(sourceRoot, srcFile);
            }
            this.setSourceContent(srcFile, content);
          }
        }, this);
      }
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      _validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      }
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      _serializeMappings() {
        let previousGeneratedColumn = 0;
        let previousGeneratedLine = 1;
        let previousOriginalColumn = 0;
        let previousOriginalLine = 0;
        let previousName = 0;
        let previousSource = 0;
        let result = "";
        let next;
        let mapping;
        let nameIdx;
        let sourceIdx;
        const mappings = this._mappings.toArray();
        for (let i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      }
      _generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          const key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      }
      /**
       * Externalize the source map.
       */
      toJSON() {
        const map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      }
      /**
       * Render the source map being generated to a string.
       */
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
    SourceMapGenerator2.prototype._version = 3;
    exports.SourceMapGenerator = SourceMapGenerator2;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      const mid = Math.floor((aHigh - aLow) / 2) + aLow;
      const cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        }
        return mid;
      }
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      }
      return aLow < 0 ? -1 : aLow;
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      let index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/read-wasm.js
var require_read_wasm = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/read-wasm.js"(exports, module2) {
    var isBrowserEnvironment = function() {
      return typeof window !== "undefined" && this === window;
    }.call();
    if (isBrowserEnvironment) {
      let mappingsWasm = null;
      module2.exports = function readWasm() {
        if (typeof mappingsWasm === "string") {
          return fetch(mappingsWasm).then((response) => response.arrayBuffer());
        }
        if (mappingsWasm instanceof ArrayBuffer) {
          return Promise.resolve(mappingsWasm);
        }
        throw new Error("You must provide the string URL or ArrayBuffer contents of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer");
      };
      module2.exports.initialize = (input) => mappingsWasm = input;
    } else {
      const fs5 = require("fs");
      const path5 = require("path");
      module2.exports = function readWasm() {
        return new Promise((resolve, reject) => {
          const wasmPath = path5.join(__dirname, "mappings.wasm");
          fs5.readFile(wasmPath, null, (error, data) => {
            if (error) {
              reject(error);
              return;
            }
            resolve(data.buffer);
          });
        });
      };
      module2.exports.initialize = (_) => {
        console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
      };
    }
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/wasm.js
var require_wasm = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/wasm.js"(exports, module2) {
    var readWasm = require_read_wasm();
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.lastGeneratedColumn = null;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var cachedWasm = null;
    module2.exports = function wasm() {
      if (cachedWasm) {
        return cachedWasm;
      }
      const callbackStack = [];
      cachedWasm = readWasm().then((buffer) => {
        return WebAssembly.instantiate(buffer, {
          env: {
            mapping_callback(generatedLine, generatedColumn, hasLastGeneratedColumn, lastGeneratedColumn, hasOriginal, source, originalLine, originalColumn, hasName, name) {
              const mapping = new Mapping();
              mapping.generatedLine = generatedLine + 1;
              mapping.generatedColumn = generatedColumn;
              if (hasLastGeneratedColumn) {
                mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
              }
              if (hasOriginal) {
                mapping.source = source;
                mapping.originalLine = originalLine + 1;
                mapping.originalColumn = originalColumn;
                if (hasName) {
                  mapping.name = name;
                }
              }
              callbackStack[callbackStack.length - 1](mapping);
            },
            start_all_generated_locations_for() {
              console.time("all_generated_locations_for");
            },
            end_all_generated_locations_for() {
              console.timeEnd("all_generated_locations_for");
            },
            start_compute_column_spans() {
              console.time("compute_column_spans");
            },
            end_compute_column_spans() {
              console.timeEnd("compute_column_spans");
            },
            start_generated_location_for() {
              console.time("generated_location_for");
            },
            end_generated_location_for() {
              console.timeEnd("generated_location_for");
            },
            start_original_location_for() {
              console.time("original_location_for");
            },
            end_original_location_for() {
              console.timeEnd("original_location_for");
            },
            start_parse_mappings() {
              console.time("parse_mappings");
            },
            end_parse_mappings() {
              console.timeEnd("parse_mappings");
            },
            start_sort_by_generated_location() {
              console.time("sort_by_generated_location");
            },
            end_sort_by_generated_location() {
              console.timeEnd("sort_by_generated_location");
            },
            start_sort_by_original_location() {
              console.time("sort_by_original_location");
            },
            end_sort_by_original_location() {
              console.timeEnd("sort_by_original_location");
            }
          }
        });
      }).then((Wasm) => {
        return {
          exports: Wasm.instance.exports,
          withMappingCallback: (mappingCallback, f) => {
            callbackStack.push(mappingCallback);
            try {
              f();
            } finally {
              callbackStack.pop();
            }
          }
        };
      }).then(null, (e) => {
        cachedWasm = null;
        throw e;
      });
      return cachedWasm;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var readWasm = require_read_wasm();
    var wasm = require_wasm();
    var INTERNAL = Symbol("smcInternal");
    var SourceMapConsumer2 = class _SourceMapConsumer {
      constructor(aSourceMap, aSourceMapURL) {
        if (aSourceMap == INTERNAL) {
          return Promise.resolve(this);
        }
        return _factory(aSourceMap, aSourceMapURL);
      }
      static initialize(opts) {
        readWasm.initialize(opts["lib/mappings.wasm"]);
      }
      static fromSourceMap(aSourceMap, aSourceMapURL) {
        return _factoryBSM(aSourceMap, aSourceMapURL);
      }
      /**
       * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`
       * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async
       * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait
       * for `f` to complete, call `destroy` on the consumer, and return `f`'s return
       * value.
       *
       * You must not use the consumer after `f` completes!
       *
       * By using `with`, you do not have to remember to manually call `destroy` on
       * the consumer, since it will be called automatically once `f` completes.
       *
       * ```js
       * const xSquared = await SourceMapConsumer.with(
       *   myRawSourceMap,
       *   null,
       *   async function (consumer) {
       *     // Use `consumer` inside here and don't worry about remembering
       *     // to call `destroy`.
       *
       *     const x = await whatever(consumer);
       *     return x * x;
       *   }
       * );
       *
       * // You may not use that `consumer` anymore out here; it has
       * // been destroyed. But you can use `xSquared`.
       * console.log(xSquared);
       * ```
       */
      static async with(rawSourceMap, sourceMapUrl, f) {
        const consumer = await new _SourceMapConsumer(rawSourceMap, sourceMapUrl);
        try {
          return await f(consumer);
        } finally {
          consumer.destroy();
        }
      }
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      _parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      }
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      eachMapping(aCallback, aContext, aOrder) {
        throw new Error("Subclasses must implement eachMapping");
      }
      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a either the line we are searching for or the next
       * closest line that has any mappings. Otherwise, returns all mappings
       * corresponding to the given line and either the column we are searching for
       * or the next closest column that has any offsets.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number is 1-based.
       *   - column: Optional. the column number in the original source.
       *    The column number is 0-based.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *    line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *    The column number is 0-based.
       */
      allGeneratedPositionsFor(aArgs) {
        throw new Error("Subclasses must implement allGeneratedPositionsFor");
      }
      destroy() {
        throw new Error("Subclasses must implement destroy");
      }
    };
    SourceMapConsumer2.prototype._version = 3;
    SourceMapConsumer2.GENERATED_ORDER = 1;
    SourceMapConsumer2.ORIGINAL_ORDER = 2;
    SourceMapConsumer2.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer2.LEAST_UPPER_BOUND = 2;
    exports.SourceMapConsumer = SourceMapConsumer2;
    var BasicSourceMapConsumer = class _BasicSourceMapConsumer extends SourceMapConsumer2 {
      constructor(aSourceMap, aSourceMapURL) {
        return super(INTERNAL).then((that) => {
          let sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          const version2 = util.getArg(sourceMap, "version");
          let sources = util.getArg(sourceMap, "sources");
          const names = util.getArg(sourceMap, "names", []);
          let sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
          const sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
          const mappings = util.getArg(sourceMap, "mappings");
          const file = util.getArg(sourceMap, "file", null);
          if (version2 != that._version) {
            throw new Error("Unsupported version: " + version2);
          }
          if (sourceRoot) {
            sourceRoot = util.normalize(sourceRoot);
          }
          sources = sources.map(String).map(util.normalize).map(function(source) {
            return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
          });
          that._names = ArraySet.fromArray(names.map(String), true);
          that._sources = ArraySet.fromArray(sources, true);
          that._absoluteSources = that._sources.toArray().map(function(s) {
            return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
          });
          that.sourceRoot = sourceRoot;
          that.sourcesContent = sourcesContent;
          that._mappings = mappings;
          that._sourceMapURL = aSourceMapURL;
          that.file = file;
          that._computedColumnSpans = false;
          that._mappingsPtr = 0;
          that._wasm = null;
          return wasm().then((w) => {
            that._wasm = w;
            return that;
          });
        });
      }
      /**
       * Utility function to find the index of a source.  Returns -1 if not
       * found.
       */
      _findSourceIndex(aSource) {
        let relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        for (let i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      }
      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @param String aSourceMapURL
       *        The URL at which the source map can be found (optional)
       * @returns BasicSourceMapConsumer
       */
      static fromSourceMap(aSourceMap, aSourceMapURL) {
        return new _BasicSourceMapConsumer(aSourceMap.toString());
      }
      get sources() {
        return this._absoluteSources.slice();
      }
      _getMappingsPtr() {
        if (this._mappingsPtr === 0) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this._mappingsPtr;
      }
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      _parseMappings(aStr, aSourceRoot) {
        const size = aStr.length;
        const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);
        const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);
        for (let i = 0; i < size; i++) {
          mappingsBuf[i] = aStr.charCodeAt(i);
        }
        const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);
        if (!mappingsPtr) {
          const error = this._wasm.exports.get_last_error();
          let msg = `Error parsing mappings (code ${error}): `;
          switch (error) {
            case 1:
              msg += "the mappings contained a negative line, column, source index, or name index";
              break;
            case 2:
              msg += "the mappings contained a number larger than 2**32";
              break;
            case 3:
              msg += "reached EOF while in the middle of parsing a VLQ";
              break;
            case 4:
              msg += "invalid base 64 character while parsing a VLQ";
              break;
            default:
              msg += "unknown error code";
              break;
          }
          throw new Error(msg);
        }
        this._mappingsPtr = mappingsPtr;
      }
      eachMapping(aCallback, aContext, aOrder) {
        const context = aContext || null;
        const order = aOrder || SourceMapConsumer2.GENERATED_ORDER;
        const sourceRoot = this.sourceRoot;
        this._wasm.withMappingCallback(
          (mapping) => {
            if (mapping.source !== null) {
              mapping.source = this._sources.at(mapping.source);
              mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);
              if (mapping.name !== null) {
                mapping.name = this._names.at(mapping.name);
              }
            }
            aCallback.call(context, mapping);
          },
          () => {
            switch (order) {
              case SourceMapConsumer2.GENERATED_ORDER:
                this._wasm.exports.by_generated_location(this._getMappingsPtr());
                break;
              case SourceMapConsumer2.ORIGINAL_ORDER:
                this._wasm.exports.by_original_location(this._getMappingsPtr());
                break;
              default:
                throw new Error("Unknown order of iteration.");
            }
          }
        );
      }
      allGeneratedPositionsFor(aArgs) {
        let source = util.getArg(aArgs, "source");
        const originalLine = util.getArg(aArgs, "line");
        const originalColumn = aArgs.column || 0;
        source = this._findSourceIndex(source);
        if (source < 0) {
          return [];
        }
        if (originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        const mappings = [];
        this._wasm.withMappingCallback(
          (m) => {
            let lastColumn = m.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            mappings.push({
              line: m.generatedLine,
              column: m.generatedColumn,
              lastColumn
            });
          },
          () => {
            this._wasm.exports.all_generated_locations_for(
              this._getMappingsPtr(),
              source,
              originalLine - 1,
              "column" in aArgs,
              originalColumn
            );
          }
        );
        return mappings;
      }
      destroy() {
        if (this._mappingsPtr !== 0) {
          this._wasm.exports.free_mappings(this._mappingsPtr);
          this._mappingsPtr = 0;
        }
      }
      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      computeColumnSpans() {
        if (this._computedColumnSpans) {
          return;
        }
        this._wasm.exports.compute_column_spans(this._getMappingsPtr());
        this._computedColumnSpans = true;
      }
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      originalPositionFor(aArgs) {
        const needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        if (needle.generatedLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.generatedColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        let bias = util.getArg(aArgs, "bias", SourceMapConsumer2.GREATEST_LOWER_BOUND);
        if (bias == null) {
          bias = SourceMapConsumer2.GREATEST_LOWER_BOUND;
        }
        let mapping;
        this._wasm.withMappingCallback((m) => mapping = m, () => {
          this._wasm.exports.original_location_for(
            this._getMappingsPtr(),
            needle.generatedLine - 1,
            needle.generatedColumn,
            bias
          );
        });
        if (mapping) {
          if (mapping.generatedLine === needle.generatedLine) {
            let source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            let name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      }
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        const index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        let relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        let url3;
        if (this.sourceRoot != null && (url3 = util.urlParse(this.sourceRoot))) {
          const fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url3.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url3.path || url3.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        }
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      generatedPositionFor(aArgs) {
        let source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        const needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        if (needle.originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        let bias = util.getArg(aArgs, "bias", SourceMapConsumer2.GREATEST_LOWER_BOUND);
        if (bias == null) {
          bias = SourceMapConsumer2.GREATEST_LOWER_BOUND;
        }
        let mapping;
        this._wasm.withMappingCallback((m) => mapping = m, () => {
          this._wasm.exports.generated_location_for(
            this._getMappingsPtr(),
            needle.source,
            needle.originalLine - 1,
            needle.originalColumn,
            bias
          );
        });
        if (mapping) {
          if (mapping.source === needle.source) {
            let lastColumn = mapping.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
    };
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer2;
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    var IndexedSourceMapConsumer = class extends SourceMapConsumer2 {
      constructor(aSourceMap, aSourceMapURL) {
        return super(INTERNAL).then((that) => {
          let sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          const version2 = util.getArg(sourceMap, "version");
          const sections = util.getArg(sourceMap, "sections");
          if (version2 != that._version) {
            throw new Error("Unsupported version: " + version2);
          }
          that._sources = new ArraySet();
          that._names = new ArraySet();
          that.__generatedMappings = null;
          that.__originalMappings = null;
          that.__generatedMappingsUnsorted = null;
          that.__originalMappingsUnsorted = null;
          let lastOffset = {
            line: -1,
            column: 0
          };
          return Promise.all(sections.map((s) => {
            if (s.url) {
              throw new Error("Support for url field in sections not implemented.");
            }
            const offset = util.getArg(s, "offset");
            const offsetLine = util.getArg(offset, "line");
            const offsetColumn = util.getArg(offset, "column");
            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
              throw new Error("Section offsets must be ordered and non-overlapping.");
            }
            lastOffset = offset;
            const cons = new SourceMapConsumer2(util.getArg(s, "map"), aSourceMapURL);
            return cons.then((consumer) => {
              return {
                generatedOffset: {
                  // The offset fields are 0-based, but we use 1-based indices when
                  // encoding/decoding from VLQ.
                  generatedLine: offsetLine + 1,
                  generatedColumn: offsetColumn + 1
                },
                consumer
              };
            });
          })).then((s) => {
            that._sections = s;
            return that;
          });
        });
      }
      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
      get _generatedMappings() {
        if (!this.__generatedMappings) {
          this._sortGeneratedMappings();
        }
        return this.__generatedMappings;
      }
      get _originalMappings() {
        if (!this.__originalMappings) {
          this._sortOriginalMappings();
        }
        return this.__originalMappings;
      }
      get _generatedMappingsUnsorted() {
        if (!this.__generatedMappingsUnsorted) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappingsUnsorted;
      }
      get _originalMappingsUnsorted() {
        if (!this.__originalMappingsUnsorted) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappingsUnsorted;
      }
      _sortGeneratedMappings() {
        const mappings = this._generatedMappingsUnsorted;
        mappings.sort(util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = mappings;
      }
      _sortOriginalMappings() {
        const mappings = this._originalMappingsUnsorted;
        mappings.sort(util.compareByOriginalPositions);
        this.__originalMappings = mappings;
      }
      /**
       * The list of original sources.
       */
      get sources() {
        const sources = [];
        for (let i = 0; i < this._sections.length; i++) {
          for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      originalPositionFor(aArgs) {
        const needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        const sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(aNeedle, section2) {
            const cmp = aNeedle.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return aNeedle.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        const section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      }
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      }
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      sourceContentFor(aSource, nullOnMissing) {
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          const content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        }
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      generatedPositionFor(aArgs) {
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          const generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            const ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      }
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      _parseMappings(aStr, aSourceRoot) {
        const generatedMappings = this.__generatedMappingsUnsorted = [];
        const originalMappings = this.__originalMappingsUnsorted = [];
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          const sectionMappings = [];
          section.consumer.eachMapping((m) => sectionMappings.push(m));
          for (let j = 0; j < sectionMappings.length; j++) {
            const mapping = sectionMappings[j];
            let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            let name = null;
            if (mapping.name) {
              this._names.add(mapping.name);
              name = this._names.indexOf(mapping.name);
            }
            const adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              originalMappings.push(adjustedMapping);
            }
          }
        }
      }
      eachMapping(aCallback, aContext, aOrder) {
        const context = aContext || null;
        const order = aOrder || SourceMapConsumer2.GENERATED_ORDER;
        let mappings;
        switch (order) {
          case SourceMapConsumer2.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer2.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        const sourceRoot = this.sourceRoot;
        mappings.map(function(mapping) {
          let source = null;
          if (mapping.source !== null) {
            source = this._sources.at(mapping.source);
            source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          }
          return {
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context);
      }
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      _findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      }
      allGeneratedPositionsFor(aArgs) {
        const line = util.getArg(aArgs, "line");
        const needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        if (needle.originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        const mappings = [];
        let index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          let mapping = this._originalMappings[index];
          if (aArgs.column === void 0) {
            const originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              let lastColumn = mapping.lastGeneratedColumn;
              if (this._computedColumnSpans && lastColumn === null) {
                lastColumn = Infinity;
              }
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            const originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              let lastColumn = mapping.lastGeneratedColumn;
              if (this._computedColumnSpans && lastColumn === null) {
                lastColumn = Infinity;
              }
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      }
      destroy() {
        for (let i = 0; i < this._sections.length; i++) {
          this._sections[i].consumer.destroy();
        }
      }
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    function _factory(aSourceMap, aSourceMapURL) {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      const consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      return Promise.resolve(consumer);
    }
    function _factoryBSM(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    }
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator2 = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    var SourceNode = class _SourceNode {
      constructor(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        const node = new _SourceNode();
        const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        let remainingLinesIndex = 0;
        const shiftNextLine = function() {
          const lineContents = getNextLine();
          const newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        let lastGeneratedLine = 1, lastGeneratedColumn = 0;
        let lastMapping = null;
        let nextLine;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              nextLine = remainingLines[remainingLinesIndex] || "";
              const code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          const content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            const source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new _SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      }
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      }
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (let i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      }
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      walk(aFn) {
        let chunk;
        for (let i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      join(aSep) {
        let newChildren;
        let i;
        const len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      }
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      replaceRight(aPattern, aReplacement) {
        const lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      }
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      }
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      walkSourceContents(aFn) {
        for (let i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        const sources = Object.keys(this.sourceContents);
        for (let i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      }
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      toString() {
        let str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      }
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      toStringWithSourceMap(aArgs) {
        const generated = {
          code: "",
          line: 1,
          column: 0
        };
        const map = new SourceMapGenerator2(aArgs);
        let sourceMappingActive = false;
        let lastOriginalSource = null;
        let lastOriginalLine = null;
        let lastOriginalColumn = null;
        let lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (let idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map };
      }
    };
    exports.SourceNode = SourceNode;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// ../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/.pnpm/convert-source-map@1.8.0/node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS({
  "../../node_modules/.pnpm/convert-source-map@1.8.0/node_modules/convert-source-map/index.js"(exports) {
    "use strict";
    var fs5 = require("fs");
    var path5 = require("path");
    var SafeBuffer = require_safe_buffer();
    Object.defineProperty(exports, "commentRegex", {
      get: function getCommentRegex() {
        return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
      }
    });
    Object.defineProperty(exports, "mapFileCommentRegex", {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
      }
    });
    function decodeBase64(base64) {
      return (SafeBuffer.Buffer.from(base64, "base64") || "").toString();
    }
    function stripComment(sm) {
      return sm.split(",").pop();
    }
    function readFromFileMap(sm, dir) {
      var r = exports.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      var filepath = path5.resolve(dir, filename);
      try {
        return fs5.readFileSync(filepath, "utf8");
      } catch (e) {
        throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e);
      }
    }
    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.isFileComment)
        sm = readFromFileMap(sm, opts.commentFileDir);
      if (opts.hasComment)
        sm = stripComment(sm);
      if (opts.isEncoded)
        sm = decodeBase64(sm);
      if (opts.isJSON || opts.isEncoded)
        sm = JSON.parse(sm);
      this.sourcemap = sm;
    }
    Converter.prototype.toJSON = function(space) {
      return JSON.stringify(this.sourcemap, null, space);
    };
    Converter.prototype.toBase64 = function() {
      var json = this.toJSON();
      return (SafeBuffer.Buffer.from(json, "utf8") || "").toString("base64");
    };
    Converter.prototype.toComment = function(options) {
      var base64 = this.toBase64();
      var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
    Converter.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    };
    Converter.prototype.addProperty = function(key, value) {
      if (this.sourcemap.hasOwnProperty(key))
        throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value);
    };
    Converter.prototype.setProperty = function(key, value) {
      this.sourcemap[key] = value;
      return this;
    };
    Converter.prototype.getProperty = function(key) {
      return this.sourcemap[key];
    };
    exports.fromObject = function(obj) {
      return new Converter(obj);
    };
    exports.fromJSON = function(json) {
      return new Converter(json, { isJSON: true });
    };
    exports.fromBase64 = function(base64) {
      return new Converter(base64, { isEncoded: true });
    };
    exports.fromComment = function(comment) {
      comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
      return new Converter(comment, { isEncoded: true, hasComment: true });
    };
    exports.fromMapFileComment = function(comment, dir) {
      return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
    };
    exports.fromSource = function(content) {
      var m = content.match(exports.commentRegex);
      return m ? exports.fromComment(m.pop()) : null;
    };
    exports.fromMapFileSource = function(content, dir) {
      var m = content.match(exports.mapFileCommentRegex);
      return m ? exports.fromMapFileComment(m.pop(), dir) : null;
    };
    exports.removeComments = function(src) {
      return src.replace(exports.commentRegex, "");
    };
    exports.removeMapFileComments = function(src) {
      return src.replace(exports.mapFileCommentRegex, "");
    };
    exports.generateMapFileComment = function(file, options) {
      var data = "sourceMappingURL=" + file;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
  }
});

// ../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js
var require_bytes = __commonJS({
  "../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js"(exports, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format;
    module2.exports.parse = parse;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options) {
      if (typeof value === "string") {
        return parse(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// dist/___get-nextjs-edge-function.js
var require_get_nextjs_edge_function = __commonJS({
  "dist/___get-nextjs-edge-function.js"(exports, module2) {
    "use strict";
    module2.exports = 'var d=Object.defineProperty;var m=e=>d(e,"__esModule",{value:!0});var y=(e,r)=>{m(e);for(var t in r)d(e,t,{get:r[t],enumerable:!0})};y(exports,{default:()=>x});function h(e){let r={};return e&&e.forEach((t,i)=>{r[i]=t,i.toLowerCase()==="set-cookie"&&(r[i]=C(t))}),r}function C(e){let r=[],t=0,i,a,p,n,s;function c(){for(;t<e.length&&/\\s/.test(e.charAt(t));)t+=1;return t<e.length}function o(){return a=e.charAt(t),a!=="="&&a!==";"&&a!==","}for(;t<e.length;){for(i=t,s=!1;c();)if(a=e.charAt(t),a===","){for(p=t,t+=1,c(),n=t;t<e.length&&o();)t+=1;t<e.length&&e.charAt(t)==="="?(s=!0,t=n,r.push(e.substring(i,p)),i=t):t=p+1}else t+=1;(!s||t>=e.length)&&r.push(e.substring(i,e.length))}return r}function x(e){let r=e.staticRoutes.map(i=>({regexp:new RegExp(i.namedRegex),page:i.page})),t=e.dynamicRoutes?.map(i=>({regexp:new RegExp(i.namedRegex),page:i.page}))||[];return async function(a,p){let n=new URL(a.url).pathname,s={};if(e.nextConfig?.basePath&&n.startsWith(e.nextConfig.basePath)&&(n=n.replace(e.nextConfig.basePath,"")||"/"),e.nextConfig?.i18n)for(let o of e.nextConfig.i18n.locales){let g=new RegExp(`^/${o}($|/)`,"i");if(n.match(g)){n=n.replace(g,"/")||"/";break}}for(let o of r)if(o.regexp.exec(n)){s.name=o.page;break}if(!s.name){let o=R(n);for(let g of t||[]){if(o&&!R(g.page))continue;let f=g.regexp.exec(n);if(f){s={name:g.page,params:f.groups};break}}}let c=await _ENTRIES[`middleware_${e.name}`].default.call({},{request:{url:a.url,method:a.method,headers:h(a.headers),ip:u(a.headers,l.Ip),geo:{city:u(a.headers,l.City,!0),country:u(a.headers,l.Country,!0),latitude:u(a.headers,l.Latitude),longitude:u(a.headers,l.Longitude),region:u(a.headers,l.Region,!0)},nextConfig:e.nextConfig,page:s,body:a.body}});return p.waitUntil(c.waitUntil),c.response}}function u(e,r,t=!1){let i=e.get(r)||void 0;return t&&i?decodeURIComponent(i):i}function R(e){return e==="/api"||e.startsWith("/api/")}var l;(function(n){n.City="x-vercel-ip-city",n.Country="x-vercel-ip-country",n.Ip="x-real-ip",n.Latitude="x-vercel-ip-latitude",n.Longitude="x-vercel-ip-longitude",n.Region="x-vercel-ip-country-region"})(l||(l={}));\n';
  }
});

// ../../node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "../../node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var Module = require("module");
    var fs5 = require("fs");
    var resolveFrom2 = (fromDirectory, moduleId, silent) => {
      if (typeof fromDirectory !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDirectory = fs5.realpathSync(fromDirectory);
      } catch (error) {
        if (error.code === "ENOENT") {
          fromDirectory = path5.resolve(fromDirectory);
        } else if (silent) {
          return;
        } else {
          throw error;
        }
      }
      const fromFile = path5.join(fromDirectory, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (error) {
          return;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId);
    module2.exports.silent = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId, true);
  }
});

// ../../node_modules/.pnpm/pretty-bytes@5.3.0/node_modules/pretty-bytes/index.js
var require_pretty_bytes = __commonJS({
  "../../node_modules/.pnpm/pretty-bytes@5.3.0/node_modules/pretty-bytes/index.js"(exports, module2) {
    "use strict";
    var BYTE_UNITS = [
      "B",
      "kB",
      "MB",
      "GB",
      "TB",
      "PB",
      "EB",
      "ZB",
      "YB"
    ];
    var BIT_UNITS = [
      "b",
      "kbit",
      "Mbit",
      "Gbit",
      "Tbit",
      "Pbit",
      "Ebit",
      "Zbit",
      "Ybit"
    ];
    var toLocaleString = (number, locale) => {
      let result = number;
      if (typeof locale === "string") {
        result = number.toLocaleString(locale);
      } else if (locale === true) {
        result = number.toLocaleString();
      }
      return result;
    };
    module2.exports = (number, options) => {
      if (!Number.isFinite(number)) {
        throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
      }
      options = Object.assign({ bits: false }, options);
      const UNITS = options.bits ? BIT_UNITS : BYTE_UNITS;
      if (options.signed && number === 0) {
        return " 0 " + UNITS[0];
      }
      const isNegative = number < 0;
      const prefix = isNegative ? "-" : options.signed ? "+" : "";
      if (isNegative) {
        number = -number;
      }
      if (number < 1) {
        const numberString2 = toLocaleString(number, options.locale);
        return prefix + numberString2 + " " + UNITS[0];
      }
      const exponent = Math.min(Math.floor(Math.log10(number) / 3), UNITS.length - 1);
      number = Number((number / Math.pow(1e3, exponent)).toPrecision(3));
      const numberString = toLocaleString(number, options.locale);
      const unit = UNITS[exponent];
      return prefix + numberString + " " + unit;
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  MAX_AGE_ONE_YEAR: () => MAX_AGE_ONE_YEAR,
  build: () => build,
  diagnostics: () => diagnostics,
  htmlContentType: () => htmlContentType,
  prepareCache: () => prepareCache,
  version: () => version
});
module.exports = __toCommonJS(src_exports);
var import_build_utils3 = require("@vercel/build-utils");
var import_superstatic = __toESM(require_superstatic());
var import_nft2 = require("@vercel/nft");
var import_async_sema3 = __toESM(require_lib());
var import_escape_string_regexp3 = __toESM(require_escape_string_regexp());
var import_find_up = __toESM(require_find_up());
var import_fs_extra6 = __toESM(require_lib2());
var import_path5 = __toESM(require("path"));
var import_semver4 = __toESM(require_semver());
var import_url2 = __toESM(require("url"));

// src/create-serverless-config.ts
var import_fs_extra4 = __toESM(require_lib2());
var import_path3 = __toESM(require("path"));
var import_semver2 = __toESM(require_semver());

// src/utils.ts
var import_build_utils = require("@vercel/build-utils");
var import_async_sema = __toESM(require_lib());
var import_buffer_crc32 = __toESM(require_buffer_crc32());
var import_fs_extra3 = __toESM(require_lib2());
var import_path2 = __toESM(require("path"));
var import_semver = __toESM(require_semver());
var import_url = __toESM(require("url"));
var import_module = require("module");
var import_escape_string_regexp = __toESM(require_escape_string_regexp());
var import_text_table = __toESM(require_text_table());

// src/edge-function-source/get-edge-function-source.ts
var import_fs_extra2 = __toESM(require_lib2());
var import_webpack_sources2 = __toESM(require_lib3());

// src/sourcemapped.ts
var import_source_map = __toESM(require_source_map());
var import_convert_source_map = __toESM(require_convert_source_map());
var import_fs_extra = __toESM(require_lib2());
var import_webpack_sources = __toESM(require_lib3());
function sourcemapped(strings, ...sources) {
  const concat = new import_webpack_sources.ConcatSource();
  for (let i = 0; i < Math.max(strings.length, sources.length); i++) {
    const string = strings[i];
    const source = sources[i];
    if (string)
      concat.add(raw(string));
    if (source)
      concat.add(source);
  }
  return concat;
}
function raw(value) {
  return new import_webpack_sources.OriginalSource(value, "[native code]");
}
async function fileToSource(content, sourceName, fullFilePath) {
  const sourcemap = await getSourceMap(content, fullFilePath);
  const cleanContent = removeInlinedSourceMap(content);
  return sourcemap ? new import_webpack_sources.SourceMapSource(cleanContent, sourceName, sourcemap) : new import_webpack_sources.OriginalSource(cleanContent, sourceName);
}
async function getSourceMap(content, fullFilePath) {
  let map;
  try {
    if (fullFilePath && await import_fs_extra.default.pathExists(`${fullFilePath}.map`)) {
      const mapJson = await import_fs_extra.default.readFile(`${fullFilePath}.map`, "utf8");
      map = import_convert_source_map.default.fromJSON(mapJson).toObject();
    } else {
      map = import_convert_source_map.default.fromComment(content).toObject();
    }
  } catch {
    return null;
  }
  if ("sections" in map) {
    return flattenSourceMap(map);
  }
  return map;
}
async function flattenSourceMap(map) {
  return new import_source_map.SourceMapGenerator(await new import_source_map.SourceMapConsumer(map)).toJSON();
}
function stringifySourceMap(sourceMap) {
  if (!sourceMap)
    return;
  const obj = typeof sourceMap === "object" ? { ...sourceMap } : import_convert_source_map.default.fromJSON(sourceMap).toObject();
  delete obj.sourcesContent;
  return JSON.stringify(obj);
}
var SOURCE_MAP_COMMENT_REGEX = /^\s*?\/[/*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm;
function isValidSourceMapData(encoding, data) {
  if (encoding !== "base64") {
    return false;
  }
  data = data.replace(/\s/g, "").replace(/\*\//g, "");
  return /^[a-zA-Z0-9+=/]+$/.test(data);
}
function removeInlinedSourceMap(source) {
  for (const m of source.matchAll(SOURCE_MAP_COMMENT_REGEX)) {
    if (!isValidSourceMapData(m[4], m[5])) {
      continue;
    }
    source = source.replace(m[0], "");
  }
  return source;
}

// src/edge-function-source/get-edge-function-source.ts
var import_path = require("path");

// src/constants.ts
var KIB = 1024;
var MIB = 1024 * KIB;
var EDGE_FUNCTION_SIZE_LIMIT = 4 * MIB;
var DEFAULT_MAX_UNCOMPRESSED_LAMBDA_SIZE = 250 * MIB;
var LAMBDA_RESERVED_UNCOMPRESSED_SIZE = 25 * MIB;

// src/edge-function-source/get-edge-function-source.ts
var import_zlib = __toESM(require("zlib"));
var import_util = require("util");

// src/pretty-bytes.ts
var import_bytes = __toESM(require_bytes());
var prettyBytes = (n) => (0, import_bytes.default)(n, { unitSeparator: " " });

// src/edge-function-source/get-edge-function-source.ts
var import_get_nextjs_edge_function = __toESM(require_get_nextjs_edge_function());
var gzip = (0, import_util.promisify)(import_zlib.default.gzip);
async function getNextjsEdgeFunctionSource(filePaths, params, outputDir, wasm) {
  const chunks = new import_webpack_sources2.ConcatSource(raw(`globalThis._ENTRIES = {};`));
  for (const filePath of filePaths) {
    const fullFilePath = (0, import_path.join)(outputDir, filePath);
    const content = await (0, import_fs_extra2.readFile)(fullFilePath, "utf8");
    chunks.add(raw(`
/**/;`));
    chunks.add(await fileToSource(content, filePath, fullFilePath));
  }
  const text = chunks.source();
  const wasmFiles = (wasm ?? []).map(
    ({ filePath }) => (0, import_path.join)(outputDir, filePath)
  );
  await validateSize(text, wasmFiles);
  const getPageMatchCode = `(function () {
    const module = { exports: {}, loaded: false };
    const fn = (function(module,exports) {${import_get_nextjs_edge_function.default}
});
    fn(module, module.exports);
    return module.exports;
  })`;
  return sourcemapped`
  ${raw(getWasmImportStatements(wasm))}
  ${chunks};
  export default ${raw(getPageMatchCode)}.call({}).default(
    ${raw(JSON.stringify(params))}
  )`;
}
function getWasmImportStatements(wasm = []) {
  return wasm.filter(({ name }) => name.startsWith("wasm_")).map(({ name }) => {
    const pathname = `/wasm/${name}.wasm`;
    return `const ${name} = require(${JSON.stringify(pathname)});`;
  }).join("\n");
}
async function validateSize(script, wasmFiles) {
  const buffers = [Buffer.from(script, "utf8")];
  for (const filePath of wasmFiles) {
    buffers.push(await (0, import_fs_extra2.readFile)(filePath));
  }
  const content = Buffer.concat(buffers);
  const gzipped = await gzip(content);
  if (gzipped.length > EDGE_FUNCTION_SIZE_LIMIT) {
    throw new Error(
      `Exceeds maximum edge function size: ${prettyBytes(
        gzipped.length
      )} / ${prettyBytes(EDGE_FUNCTION_SIZE_LIMIT)}`
    );
  }
}

// src/utils.ts
var require_ = (0, import_module.createRequire)(__filename);
var RSC_CONTENT_TYPE = "x-component";
var RSC_PREFETCH_SUFFIX = ".prefetch.rsc";
var MAX_UNCOMPRESSED_LAMBDA_SIZE = !isNaN(
  Number(process.env.MAX_UNCOMPRESSED_LAMBDA_SIZE)
) ? Number(process.env.MAX_UNCOMPRESSED_LAMBDA_SIZE) : DEFAULT_MAX_UNCOMPRESSED_LAMBDA_SIZE;
var TEST_DYNAMIC_ROUTE = /\/\[[^\/]+?\](?=\/|$)/;
function isDynamicRoute(route) {
  route = route.startsWith("/") ? route : `/${route}`;
  return TEST_DYNAMIC_ROUTE.test(route);
}
function validateEntrypoint(entrypoint) {
  if (!/package\.json$/.exec(entrypoint) && !/next\.config\.js$/.exec(entrypoint)) {
    throw new import_build_utils.NowBuildError({
      message: 'Specified "src" for "@vercel/next" has to be "package.json" or "next.config.js"',
      code: "NEXT_INCORRECT_SRC"
    });
  }
}
function excludeFiles(files, matcher) {
  return Object.keys(files).reduce((newFiles, filePath) => {
    if (matcher(filePath)) {
      return newFiles;
    }
    return {
      ...newFiles,
      [filePath]: files[filePath]
    };
  }, {});
}
function normalizePackageJson(defaultPackageJson = {}) {
  const dependencies = {};
  const devDependencies = {
    ...defaultPackageJson.dependencies,
    ...defaultPackageJson.devDependencies
  };
  if (devDependencies.react) {
    dependencies.react = devDependencies.react;
    delete devDependencies.react;
  }
  if (devDependencies["react-dom"]) {
    dependencies["react-dom"] = devDependencies["react-dom"];
    delete devDependencies["react-dom"];
  }
  delete devDependencies["next-server"];
  return {
    ...defaultPackageJson,
    dependencies: {
      // react and react-dom can be overwritten
      react: "latest",
      "react-dom": "latest",
      ...dependencies,
      // override react if user provided it
      // next-server is forced to canary
      "next-server": "v7.0.2-canary.49"
    },
    devDependencies: {
      ...devDependencies,
      // next is forced to canary
      next: "v7.0.2-canary.49"
    },
    scripts: {
      ...defaultPackageJson.scripts,
      "now-build": "NODE_OPTIONS=--max_old_space_size=3000 next build --lambdas"
    }
  };
}
async function getNextConfig(workPath, entryPath) {
  const entryConfig = import_path2.default.join(entryPath, "./next.config.js");
  if (await import_fs_extra3.default.pathExists(entryConfig)) {
    return import_fs_extra3.default.readFile(entryConfig, "utf8");
  }
  const workConfig = import_path2.default.join(workPath, "./next.config.js");
  if (await import_fs_extra3.default.pathExists(workConfig)) {
    return import_fs_extra3.default.readFile(workConfig, "utf8");
  }
  return null;
}
function getImagesConfig(imagesManifest) {
  return imagesManifest?.images?.loader === "default" && imagesManifest.images?.unoptimized !== true ? {
    domains: imagesManifest.images.domains,
    sizes: imagesManifest.images.sizes,
    remotePatterns: imagesManifest.images.remotePatterns,
    minimumCacheTTL: imagesManifest.images.minimumCacheTTL,
    formats: imagesManifest.images.formats,
    dangerouslyAllowSVG: imagesManifest.images.dangerouslyAllowSVG,
    contentSecurityPolicy: imagesManifest.images.contentSecurityPolicy,
    contentDispositionType: imagesManifest.images.contentDispositionType
  } : void 0;
}
function normalizePage(page) {
  if (!page.startsWith("/")) {
    page = `/${page}`;
  }
  if (page === "/index") {
    page = "/";
  }
  return page;
}
async function getRoutesManifest(entryPath, outputDirectory, nextVersion) {
  const shouldHaveManifest = nextVersion && import_semver.default.gte(nextVersion, "9.1.4-canary.0");
  if (!shouldHaveManifest)
    return;
  const pathRoutesManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "routes-manifest.json"
  );
  const hasRoutesManifest = await import_fs_extra3.default.access(pathRoutesManifest).then(() => true).catch(() => false);
  if (shouldHaveManifest && !hasRoutesManifest) {
    throw new import_build_utils.NowBuildError({
      message: `The file "${pathRoutesManifest}" couldn't be found. This is often caused by a misconfiguration in your project.`,
      link: "https://err.sh/vercel/vercel/now-next-routes-manifest",
      code: "NEXT_NO_ROUTES_MANIFEST"
    });
  }
  const routesManifest = await import_fs_extra3.default.readJSON(pathRoutesManifest);
  for (const route of routesManifest.dataRoutes || []) {
    if (Array.isArray(route.routeKeys)) {
      delete route.routeKeys;
      delete route.namedDataRouteRegex;
    }
  }
  for (const route of routesManifest.dynamicRoutes || []) {
    if ("routeKeys" in route && Array.isArray(route.routeKeys)) {
      delete route.routeKeys;
      delete route.namedRegex;
    }
  }
  return routesManifest;
}
async function getDynamicRoutes({
  entryPath,
  entryDirectory,
  dynamicPages,
  isDev,
  routesManifest,
  omittedRoutes,
  canUsePreviewMode,
  bypassToken,
  isServerMode,
  dynamicMiddlewareRouteMap,
  isAppPPREnabled
}) {
  if (routesManifest) {
    switch (routesManifest.version) {
      case 1:
      case 2: {
        return routesManifest.dynamicRoutes.filter(({ page }) => canUsePreviewMode || !omittedRoutes?.has(page)).map(({ page, regex }) => {
          return {
            src: regex,
            dest: !isDev ? import_path2.default.posix.join("/", entryDirectory, page) : page,
            check: true,
            status: canUsePreviewMode && omittedRoutes?.has(page) ? 404 : void 0
          };
        });
      }
      case 3:
      case 4: {
        const routes2 = [];
        for (const dynamicRoute of routesManifest.dynamicRoutes) {
          if (!canUsePreviewMode && omittedRoutes?.has(dynamicRoute.page)) {
            continue;
          }
          const params = dynamicRoute;
          if ("isMiddleware" in params) {
            const route2 = dynamicMiddlewareRouteMap?.get(params.page);
            if (!route2) {
              throw new Error(
                `Could not find dynamic middleware route for ${params.page}`
              );
            }
            routes2.push(route2);
            continue;
          }
          const { page, namedRegex, regex, routeKeys } = params;
          const route = {
            src: namedRegex || regex,
            dest: `${!isDev ? import_path2.default.posix.join("/", entryDirectory, page) : page}${routeKeys ? `?${Object.keys(routeKeys).map((key) => `${routeKeys[key]}=$${key}`).join("&")}` : ""}`
          };
          if (!isServerMode) {
            route.check = true;
          }
          if (isServerMode && canUsePreviewMode && omittedRoutes?.has(page)) {
            route.has = [
              {
                type: "cookie",
                key: "__prerender_bypass",
                value: bypassToken || void 0
              },
              {
                type: "cookie",
                key: "__next_preview_data"
              }
            ];
          }
          if (isAppPPREnabled) {
            let dest = route.dest?.replace(/($|\?)/, ".prefetch.rsc$1");
            if (page === "/" || page === "/index") {
              dest = dest?.replace(/([^/]+\.prefetch\.rsc(\?.*|$))/, "__$1");
            }
            routes2.push({
              ...route,
              src: route.src.replace(
                new RegExp((0, import_escape_string_regexp.default)("(?:/)?$")),
                "(?:\\.prefetch\\.rsc)(?:/)?$"
              ),
              dest
            });
          }
          routes2.push({
            ...route,
            src: route.src.replace(
              new RegExp((0, import_escape_string_regexp.default)("(?:/)?$")),
              "(?:\\.rsc)(?:/)?$"
            ),
            dest: route.dest?.replace(/($|\?)/, ".rsc$1")
          });
          routes2.push(route);
        }
        return routes2;
      }
      default: {
        throw new import_build_utils.NowBuildError({
          message: "This version of `@vercel/next` does not support the version of Next.js you are trying to deploy.\nPlease upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen.",
          code: "NEXT_VERSION_UPGRADE"
        });
      }
    }
  }
  if (!dynamicPages.length) {
    return [];
  }
  let getRouteRegex = void 0;
  let getSortedRoutes;
  try {
    const resolved = require_.resolve("next-server/dist/lib/router/utils", {
      paths: [entryPath]
    });
    ({ getRouteRegex, getSortedRoutes } = require_(resolved));
    if (typeof getRouteRegex !== "function") {
      getRouteRegex = void 0;
    }
  } catch (_) {
  }
  if (!getRouteRegex || !getSortedRoutes) {
    try {
      const resolved = require_.resolve(
        "next/dist/next-server/lib/router/utils",
        { paths: [entryPath] }
      );
      ({ getRouteRegex, getSortedRoutes } = require_(resolved));
      if (typeof getRouteRegex !== "function") {
        getRouteRegex = void 0;
      }
    } catch (_) {
    }
  }
  if (!getRouteRegex || !getSortedRoutes) {
    throw new import_build_utils.NowBuildError({
      message: "Found usage of dynamic routes but not on a new enough version of Next.js.",
      code: "NEXT_DYNAMIC_ROUTES_OUTDATED"
    });
  }
  const pageMatchers = getSortedRoutes(dynamicPages).map((pageName) => ({
    pageName,
    matcher: getRouteRegex && getRouteRegex(pageName).re
  }));
  const routes = [];
  pageMatchers.forEach((pageMatcher) => {
    const dest = !isDev ? import_path2.default.posix.join("/", entryDirectory, pageMatcher.pageName) : pageMatcher.pageName;
    if (pageMatcher && pageMatcher.matcher) {
      routes.push({
        src: pageMatcher.matcher.source,
        dest,
        check: !isDev
      });
    }
  });
  return routes;
}
function localizeDynamicRoutes(dynamicRoutes, dynamicPrefix, entryDirectory, staticPages, prerenderManifest, routesManifest, isServerMode, isCorrectLocaleAPIRoutes, inversedAppPathRoutesManifest) {
  return dynamicRoutes.map((route) => {
    if (route.middleware !== void 0 || route.middlewarePath !== void 0)
      return route;
    const { i18n } = routesManifest || {};
    if (i18n) {
      const { pathname } = import_url.default.parse(route.dest);
      const pathnameNoPrefix = pathname?.replace(dynamicPrefix, "");
      const isFallback = prerenderManifest.fallbackRoutes[pathname];
      const isBlocking = prerenderManifest.blockingFallbackRoutes[pathname];
      const isApiRoute = pathnameNoPrefix === "/api" || pathnameNoPrefix?.startsWith("/api/");
      const isAutoExport = staticPages[addLocaleOrDefault(pathname, routesManifest).substring(1)];
      const isAppRoute = inversedAppPathRoutesManifest?.[pathnameNoPrefix || ""];
      const isLocalePrefixed = isFallback || isBlocking || isAutoExport || isServerMode;
      route.src = route.src.replace(
        "^",
        `^${dynamicPrefix ? `${dynamicPrefix}[/]?` : "[/]?"}(?${isLocalePrefixed ? "<nextLocale>" : ":"}${i18n.locales.map((locale) => (0, import_escape_string_regexp.default)(locale)).join("|")})?`
      );
      if (isLocalePrefixed && !(isCorrectLocaleAPIRoutes && isApiRoute) && !isAppRoute) {
        route.dest = route.dest.replace(
          `${import_path2.default.posix.join("/", entryDirectory, "/")}`,
          `${import_path2.default.posix.join("/", entryDirectory, "$nextLocale", "/")}`
        );
      }
    } else {
      route.src = route.src.replace("^", `^${dynamicPrefix}`);
    }
    return route;
  });
}
async function getImagesManifest(entryPath, outputDirectory) {
  const pathImagesManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "images-manifest.json"
  );
  const hasImagesManifest = await import_fs_extra3.default.access(pathImagesManifest).then(() => true).catch(() => false);
  if (!hasImagesManifest) {
    return void 0;
  }
  return import_fs_extra3.default.readJson(pathImagesManifest);
}
function filterStaticPages(staticPageFiles, dynamicPages, entryDirectory, htmlContentType2, prerenderManifest, routesManifest) {
  const staticPages = {};
  Object.keys(staticPageFiles).forEach((page) => {
    const pathname = page.replace(/\.html$/, "");
    const routeName = normalizeLocalePath(
      normalizePage(pathname),
      routesManifest?.i18n?.locales
    ).pathname;
    if (prerenderManifest.staticRoutes[routeName] || prerenderManifest.fallbackRoutes[routeName] || prerenderManifest.staticRoutes[normalizePage(pathname)] || prerenderManifest.fallbackRoutes[normalizePage(pathname)]) {
      return;
    }
    const staticRoute = import_path2.default.posix.join(entryDirectory, pathname);
    staticPages[staticRoute] = staticPageFiles[page];
    staticPages[staticRoute].contentType = htmlContentType2;
    if (isDynamicRoute(pathname)) {
      dynamicPages.push(routeName);
      return;
    }
  });
  return staticPages;
}
function getFilesMapFromReasons(fileList, reasons, ignoreFn) {
  const parentFilesMap = /* @__PURE__ */ new Map();
  function propagateToParents(parents, file, seen = /* @__PURE__ */ new Set()) {
    for (const parent of parents || []) {
      if (!seen.has(parent)) {
        seen.add(parent);
        let parentFiles = parentFilesMap.get(parent);
        if (!parentFiles) {
          parentFiles = /* @__PURE__ */ new Set();
          parentFilesMap.set(parent, parentFiles);
        }
        if (!ignoreFn?.(file, parent)) {
          parentFiles.add(file);
        }
        const parentReason = reasons.get(parent);
        if (parentReason?.parents) {
          propagateToParents(parentReason.parents, file, seen);
        }
      }
    }
  }
  for (const file of fileList) {
    const reason = reasons.get(file);
    const isInitial = reason?.type.length === 1 && reason.type.includes("initial");
    if (!reason || !reason.parents || isInitial && reason.parents.size === 0) {
      continue;
    }
    propagateToParents(reason.parents, file);
  }
  return parentFilesMap;
}
var collectTracedFiles = (baseDir, lstatResults, lstatSema, reasons, files) => async (file) => {
  const reason = reasons.get(file);
  if (reason && reason.type.includes("initial")) {
    return;
  }
  const filePath = import_path2.default.join(baseDir, file);
  if (!lstatResults[filePath]) {
    lstatResults[filePath] = lstatSema.acquire().then(() => (0, import_fs_extra3.lstat)(filePath)).finally(() => lstatSema.release());
  }
  const { mode } = await lstatResults[filePath];
  files[file] = new import_build_utils.FileFsRef({
    fsPath: import_path2.default.join(baseDir, file),
    mode
  });
};
var ExperimentalTraceVersion = `9.0.4-canary.1`;
async function createPseudoLayer(files) {
  const pseudoLayer = {};
  let pseudoLayerBytes = 0;
  for (const fileName of Object.keys(files)) {
    const file = files[fileName];
    if ((0, import_build_utils.isSymbolicLink)(file.mode)) {
      const symlinkTarget = await import_fs_extra3.default.readlink(file.fsPath);
      pseudoLayer[fileName] = {
        file,
        isSymlink: true,
        symlinkTarget
      };
    } else {
      const origBuffer = await (0, import_build_utils.streamToBuffer)(file.toStream());
      pseudoLayerBytes += origBuffer.byteLength;
      pseudoLayer[fileName] = {
        file,
        isSymlink: false,
        crc32: import_buffer_crc32.default.unsigned(origBuffer),
        uncompressedSize: origBuffer.byteLength
      };
    }
  }
  return { pseudoLayer, pseudoLayerBytes };
}
var createLambdaSema = new import_async_sema.Sema(1);
async function createLambdaFromPseudoLayers({
  files: baseFiles,
  layers,
  isStreaming,
  nextVersion,
  experimentalAllowBundling,
  ...lambdaOptions
}) {
  await createLambdaSema.acquire();
  const files = {};
  const addedFiles = /* @__PURE__ */ new Set();
  for (const layer of layers) {
    for (const seedKey of Object.keys(layer)) {
      if (addedFiles.has(seedKey)) {
        continue;
      }
      const item = layer[seedKey];
      files[seedKey] = item.file;
      addedFiles.add(seedKey);
    }
  }
  for (const fileName of Object.keys(baseFiles)) {
    if (addedFiles.has(fileName)) {
      continue;
    }
    const file = baseFiles[fileName];
    files[fileName] = file;
    addedFiles.add(fileName);
  }
  createLambdaSema.release();
  return new import_build_utils.NodejsLambda({
    ...lambdaOptions,
    ...isStreaming ? {
      supportsResponseStreaming: true
    } : {},
    files,
    shouldAddHelpers: false,
    shouldAddSourcemapSupport: false,
    supportsMultiPayloads: true,
    framework: {
      slug: "nextjs",
      version: nextVersion
    },
    experimentalAllowBundling
  });
}
async function getExportIntent(entryPath) {
  const pathExportMarker = import_path2.default.join(entryPath, ".next", "export-marker.json");
  const hasExportMarker = await import_fs_extra3.default.access(pathExportMarker, import_fs_extra3.default.constants.F_OK).then(() => true).catch(() => false);
  if (!hasExportMarker) {
    return false;
  }
  const manifest = JSON.parse(await import_fs_extra3.default.readFile(pathExportMarker, "utf8"));
  switch (manifest.version) {
    case 1: {
      if (manifest.hasExportPathMap !== true) {
        return false;
      }
      return { trailingSlash: manifest.exportTrailingSlash };
    }
    default: {
      return false;
    }
  }
}
async function getExportStatus(entryPath) {
  const pathExportDetail = import_path2.default.join(entryPath, ".next", "export-detail.json");
  const hasExportDetail = await import_fs_extra3.default.access(pathExportDetail, import_fs_extra3.default.constants.F_OK).then(() => true).catch(() => false);
  if (!hasExportDetail) {
    return false;
  }
  const manifest = JSON.parse(await import_fs_extra3.default.readFile(pathExportDetail, "utf8"));
  switch (manifest.version) {
    case 1: {
      return {
        success: !!manifest.success,
        outDirectory: manifest.outDirectory
      };
    }
    default: {
      return false;
    }
  }
}
async function getRequiredServerFilesManifest(entryPath, outputDirectory) {
  const pathRequiredServerFilesManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "required-server-files.json"
  );
  const hasManifest = await import_fs_extra3.default.access(pathRequiredServerFilesManifest, import_fs_extra3.default.constants.F_OK).then(() => true).catch(() => false);
  if (!hasManifest) {
    return false;
  }
  const manifestData = JSON.parse(
    await import_fs_extra3.default.readFile(pathRequiredServerFilesManifest, "utf8")
  );
  const requiredServerFiles = {
    files: [],
    ignore: [],
    config: {},
    appDir: manifestData.appDir,
    relativeAppDir: manifestData.relativeAppDir
  };
  switch (manifestData.version) {
    case 1: {
      requiredServerFiles.files = manifestData.files;
      requiredServerFiles.ignore = manifestData.ignore;
      requiredServerFiles.config = manifestData.config;
      requiredServerFiles.appDir = manifestData.appDir;
      break;
    }
    default: {
      throw new Error(
        `Invalid required-server-files manifest version ${manifestData.version}, please contact support if this error persists`
      );
    }
  }
  return requiredServerFiles;
}
async function getPrerenderManifest(entryPath, outputDirectory) {
  const pathPrerenderManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "prerender-manifest.json"
  );
  const hasManifest = await import_fs_extra3.default.access(pathPrerenderManifest, import_fs_extra3.default.constants.F_OK).then(() => true).catch(() => false);
  if (!hasManifest) {
    return {
      staticRoutes: {},
      blockingFallbackRoutes: {},
      fallbackRoutes: {},
      bypassToken: null,
      omittedRoutes: {},
      notFoundRoutes: [],
      isLocalePrefixed: false
    };
  }
  const manifest = JSON.parse(await import_fs_extra3.default.readFile(pathPrerenderManifest, "utf8"));
  switch (manifest.version) {
    case 1: {
      const routes = Object.keys(manifest.routes);
      const lazyRoutes = Object.keys(manifest.dynamicRoutes);
      const ret = {
        staticRoutes: {},
        blockingFallbackRoutes: {},
        fallbackRoutes: {},
        bypassToken: manifest.preview && manifest.preview.previewModeId || null,
        omittedRoutes: {},
        notFoundRoutes: [],
        isLocalePrefixed: false
      };
      routes.forEach((route) => {
        const { initialRevalidateSeconds, dataRoute, srcRoute } = manifest.routes[route];
        ret.staticRoutes[route] = {
          initialRevalidate: initialRevalidateSeconds === false ? false : Math.max(1, initialRevalidateSeconds),
          dataRoute,
          srcRoute,
          renderingMode: "STATIC" /* STATIC */
        };
      });
      lazyRoutes.forEach((lazyRoute) => {
        const { routeRegex, fallback, dataRoute, dataRouteRegex } = manifest.dynamicRoutes[lazyRoute];
        if (fallback) {
          ret.fallbackRoutes[lazyRoute] = {
            routeRegex,
            fallback,
            dataRoute,
            dataRouteRegex,
            renderingMode: "STATIC" /* STATIC */
          };
        } else {
          ret.blockingFallbackRoutes[lazyRoute] = {
            routeRegex,
            dataRoute,
            dataRouteRegex,
            renderingMode: "STATIC" /* STATIC */
          };
        }
      });
      return ret;
    }
    case 2:
    case 3:
    case 4: {
      const routes = Object.keys(manifest.routes);
      const lazyRoutes = Object.keys(manifest.dynamicRoutes);
      const ret = {
        staticRoutes: {},
        blockingFallbackRoutes: {},
        fallbackRoutes: {},
        bypassToken: manifest.preview.previewModeId,
        omittedRoutes: {},
        notFoundRoutes: [],
        isLocalePrefixed: manifest.version > 2
      };
      if (manifest.notFoundRoutes) {
        ret.notFoundRoutes.push(...manifest.notFoundRoutes);
      }
      routes.forEach((route) => {
        const { initialRevalidateSeconds, dataRoute, srcRoute } = manifest.routes[route];
        let initialStatus;
        let initialHeaders;
        let experimentalBypassFor;
        let prefetchDataRoute;
        let renderingMode;
        if (manifest.version === 4) {
          initialStatus = manifest.routes[route].initialStatus;
          initialHeaders = manifest.routes[route].initialHeaders;
          experimentalBypassFor = manifest.routes[route].experimentalBypassFor;
          prefetchDataRoute = manifest.routes[route].prefetchDataRoute;
          renderingMode = manifest.routes[route].renderingMode ?? (manifest.routes[route].experimentalPPR ? "PARTIALLY_STATIC" /* PARTIALLY_STATIC */ : "STATIC" /* STATIC */);
        } else {
          renderingMode = "STATIC" /* STATIC */;
        }
        ret.staticRoutes[route] = {
          initialRevalidate: initialRevalidateSeconds === false ? false : Math.max(1, initialRevalidateSeconds),
          dataRoute,
          prefetchDataRoute,
          srcRoute,
          initialStatus,
          initialHeaders,
          experimentalBypassFor,
          renderingMode
        };
      });
      lazyRoutes.forEach((lazyRoute) => {
        const { routeRegex, fallback, dataRoute, dataRouteRegex } = manifest.dynamicRoutes[lazyRoute];
        let experimentalBypassFor;
        let prefetchDataRoute;
        let prefetchDataRouteRegex;
        let fallbackStatus;
        let fallbackHeaders;
        let renderingMode = "STATIC" /* STATIC */;
        if (manifest.version === 4) {
          experimentalBypassFor = manifest.dynamicRoutes[lazyRoute].experimentalBypassFor;
          prefetchDataRoute = manifest.dynamicRoutes[lazyRoute].prefetchDataRoute;
          prefetchDataRouteRegex = manifest.dynamicRoutes[lazyRoute].prefetchDataRouteRegex;
          fallbackStatus = manifest.dynamicRoutes[lazyRoute].fallbackStatus;
          fallbackHeaders = manifest.dynamicRoutes[lazyRoute].fallbackHeaders;
          renderingMode = manifest.dynamicRoutes[lazyRoute].renderingMode ?? // By default, when the rendering mode isn't specified, fallback to
          // using the `experimentalPPR` flag.
          (manifest.dynamicRoutes[lazyRoute].experimentalPPR ? "PARTIALLY_STATIC" /* PARTIALLY_STATIC */ : "STATIC" /* STATIC */);
        }
        if (typeof fallback === "string") {
          ret.fallbackRoutes[lazyRoute] = {
            experimentalBypassFor,
            routeRegex,
            fallback,
            fallbackStatus,
            fallbackHeaders,
            dataRoute,
            dataRouteRegex,
            prefetchDataRoute,
            prefetchDataRouteRegex,
            renderingMode
          };
        } else if (fallback === null) {
          ret.blockingFallbackRoutes[lazyRoute] = {
            experimentalBypassFor,
            routeRegex,
            dataRoute,
            dataRouteRegex,
            prefetchDataRoute,
            prefetchDataRouteRegex,
            renderingMode
          };
        } else {
          ret.omittedRoutes[lazyRoute] = {
            experimentalBypassFor,
            routeRegex,
            dataRoute,
            dataRouteRegex,
            prefetchDataRoute,
            prefetchDataRouteRegex,
            renderingMode
          };
        }
      });
      return ret;
    }
    default: {
      return {
        staticRoutes: {},
        blockingFallbackRoutes: {},
        fallbackRoutes: {},
        bypassToken: null,
        omittedRoutes: {},
        notFoundRoutes: [],
        isLocalePrefixed: false
      };
    }
  }
}
var _usesSrcCache;
async function usesSrcDirectory(workPath) {
  if (!_usesSrcCache) {
    const sourcePages = import_path2.default.join(workPath, "src", "pages");
    try {
      if ((await import_fs_extra3.default.stat(sourcePages)).isDirectory()) {
        _usesSrcCache = true;
      }
    } catch (_err) {
      _usesSrcCache = false;
    }
  }
  if (!_usesSrcCache) {
    const sourceAppdir = import_path2.default.join(workPath, "src", "app");
    try {
      if ((await import_fs_extra3.default.stat(sourceAppdir)).isDirectory()) {
        _usesSrcCache = true;
      }
    } catch (_err) {
      _usesSrcCache = false;
    }
  }
  return Boolean(_usesSrcCache);
}
async function getSourceFilePathFromPage({
  workPath,
  page,
  pageExtensions
}) {
  const usesSrcDir = await usesSrcDirectory(workPath);
  const extensionsToTry = pageExtensions || ["js", "jsx", "ts", "tsx"];
  for (const pageType of ["pages", "app"]) {
    let fsPath = import_path2.default.join(workPath, pageType, page);
    if (usesSrcDir) {
      fsPath = import_path2.default.join(workPath, "src", pageType, page);
    }
    if (import_fs_extra3.default.existsSync(fsPath)) {
      return import_path2.default.relative(workPath, fsPath);
    }
    const extensionless = fsPath.replace(import_path2.default.extname(fsPath), "");
    for (const ext of extensionsToTry) {
      fsPath = `${extensionless}.${ext}`;
      if (pageType === "app" && extensionless === import_path2.default.join(workPath, `${usesSrcDir ? "src/" : ""}app/index`)) {
        fsPath = `${extensionless.replace(/index$/, "page")}.${ext}`;
      }
      if (import_fs_extra3.default.existsSync(fsPath)) {
        return import_path2.default.relative(workPath, fsPath);
      }
    }
    if (isDirectory(extensionless)) {
      if (pageType === "pages") {
        for (const ext of extensionsToTry) {
          fsPath = import_path2.default.join(extensionless, `index.${ext}`);
          if (import_fs_extra3.default.existsSync(fsPath)) {
            return import_path2.default.relative(workPath, fsPath);
          }
        }
      } else {
        for (const ext of extensionsToTry) {
          fsPath = import_path2.default.join(extensionless, `page.${ext}`);
          if (import_fs_extra3.default.existsSync(fsPath)) {
            return import_path2.default.relative(workPath, fsPath);
          }
          fsPath = import_path2.default.join(extensionless, `route.${ext}`);
          if (import_fs_extra3.default.existsSync(fsPath)) {
            return import_path2.default.relative(workPath, fsPath);
          }
        }
      }
    }
  }
  if (page === "/_not-found/page") {
    return "";
  }
  console.log(
    `WARNING: Unable to find source file for page ${page} with extensions: ${extensionsToTry.join(
      ", "
    )}, this can cause functions config from \`vercel.json\` to not be applied`
  );
  return "";
}
function isDirectory(path5) {
  return import_fs_extra3.default.existsSync(path5) && import_fs_extra3.default.lstatSync(path5).isDirectory();
}
function normalizeLocalePath(pathname, locales) {
  let detectedLocale;
  const pathnameParts = pathname.split("/");
  (locales || []).some((locale) => {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join("/") || "/";
      return true;
    }
    return false;
  });
  return {
    pathname,
    detectedLocale
  };
}
function addLocaleOrDefault(pathname, routesManifest, locale) {
  if (!routesManifest?.i18n)
    return pathname;
  if (!locale)
    locale = routesManifest.i18n.defaultLocale;
  return locale ? `/${locale}${pathname === "/index" ? "" : pathname}` : pathname;
}
async function getPageLambdaGroups({
  entryPath,
  config,
  functionsConfigManifest,
  pages,
  prerenderRoutes,
  experimentalPPRRoutes,
  pageTraces,
  compressedPages,
  tracedPseudoLayer,
  initialPseudoLayer,
  initialPseudoLayerUncompressed,
  internalPages,
  pageExtensions,
  inversedAppPathManifest,
  experimentalAllowBundling,
  isRouteHandlers
}) {
  const groups = [];
  for (const page of pages) {
    const newPages = [...internalPages, page];
    const routeName = normalizePage(page.replace(/\.js$/, ""));
    const isPrerenderRoute = prerenderRoutes.has(routeName);
    const isExperimentalPPR = experimentalPPRRoutes?.has(routeName) ?? false;
    let opts = {};
    if (functionsConfigManifest && functionsConfigManifest.functions[routeName]) {
      opts = functionsConfigManifest.functions[routeName];
    }
    if (config && config.functions) {
      const sourceFile = await getSourceFilePathFromPage({
        workPath: entryPath,
        page: normalizeSourceFilePageFromManifest(
          routeName,
          page,
          inversedAppPathManifest
        ),
        pageExtensions
      });
      const vercelConfigOpts = await (0, import_build_utils.getLambdaOptionsFromFunction)({
        sourceFile,
        config
      });
      opts = { ...vercelConfigOpts, ...opts };
    }
    let matchingGroup = experimentalAllowBundling ? void 0 : groups.find((group) => {
      const matches = group.maxDuration === opts.maxDuration && group.memory === opts.memory && group.isPrerenders === isPrerenderRoute && group.isExperimentalPPR === isExperimentalPPR;
      if (matches) {
        let newTracedFilesUncompressedSize = group.pseudoLayerUncompressedBytes;
        for (const newPage of newPages) {
          Object.keys(pageTraces[newPage] || {}).map((file) => {
            if (!group.pseudoLayer[file]) {
              const item = tracedPseudoLayer[file];
              newTracedFilesUncompressedSize += item.uncompressedSize || 0;
            }
          });
          newTracedFilesUncompressedSize += compressedPages[newPage].uncompressedSize;
        }
        const underUncompressedLimit = newTracedFilesUncompressedSize < MAX_UNCOMPRESSED_LAMBDA_SIZE - LAMBDA_RESERVED_UNCOMPRESSED_SIZE;
        return underUncompressedLimit;
      }
      return false;
    });
    if (matchingGroup) {
      matchingGroup.pages.push(page);
    } else {
      const newGroup = {
        pages: [page],
        ...opts,
        isPrerenders: isPrerenderRoute,
        isExperimentalPPR,
        isApiLambda: !!isApiPage(page) || !!isRouteHandlers,
        pseudoLayerBytes: initialPseudoLayer.pseudoLayerBytes,
        pseudoLayerUncompressedBytes: initialPseudoLayerUncompressed,
        pseudoLayer: Object.assign({}, initialPseudoLayer.pseudoLayer)
      };
      groups.push(newGroup);
      matchingGroup = newGroup;
    }
    for (const newPage of newPages) {
      Object.keys(pageTraces[newPage] || {}).map((file) => {
        const pseudoItem = tracedPseudoLayer[file];
        if (!matchingGroup.pseudoLayer[file]) {
          matchingGroup.pseudoLayer[file] = pseudoItem;
          matchingGroup.pseudoLayerUncompressedBytes += pseudoItem.uncompressedSize || 0;
        }
      });
      matchingGroup.pseudoLayerUncompressedBytes += compressedPages[newPage].uncompressedSize;
    }
  }
  return groups;
}
function normalizeSourceFilePageFromManifest(routeName, page, inversedAppPathManifest) {
  const pageFromManifest = inversedAppPathManifest?.[routeName];
  if (!pageFromManifest) {
    return page;
  }
  const metadataConventions = [
    "/favicon.",
    "/icon.",
    "/apple-icon.",
    "/opengraph-image.",
    "/twitter-image.",
    "/sitemap.",
    "/robots."
  ];
  const isSpecialFile = metadataConventions.some(
    (convention) => routeName.startsWith(convention)
  );
  if (isSpecialFile) {
    return routeName;
  }
  return pageFromManifest;
}
var outputFunctionFileSizeInfo = (pages, pseudoLayer, pseudoLayerUncompressedBytes, compressedPages) => {
  const exceededLimitOutput = [];
  console.log(
    `Serverless Function's page${pages.length === 1 ? "" : "s"}: ${pages.join(
      ", "
    )}`
  );
  exceededLimitOutput.push(["Large Dependencies", "Uncompressed size"]);
  const dependencies = {};
  for (const fileKey of Object.keys(pseudoLayer)) {
    if (!pseudoLayer[fileKey].isSymlink) {
      const fileItem = pseudoLayer[fileKey];
      const depKey = fileKey.split("/").slice(0, 3).join("/");
      if (!dependencies[depKey]) {
        dependencies[depKey] = {
          uncompressed: 0
        };
      }
      dependencies[depKey].uncompressed += fileItem.uncompressedSize;
    }
  }
  for (const page of pages) {
    dependencies[`pages/${page}`] = {
      uncompressed: compressedPages[page].uncompressedSize
    };
  }
  let numLargeDependencies = 0;
  Object.keys(dependencies).sort((a, b) => {
    const aDep = dependencies[a];
    const bDep = dependencies[b];
    if (aDep.uncompressed > bDep.uncompressed) {
      return -1;
    }
    if (aDep.uncompressed < bDep.uncompressed) {
      return 1;
    }
    return 0;
  }).forEach((depKey) => {
    const dep = dependencies[depKey];
    if (dep.uncompressed < 500 * KIB) {
      return;
    }
    exceededLimitOutput.push([depKey, prettyBytes(dep.uncompressed)]);
    numLargeDependencies += 1;
  });
  if (numLargeDependencies === 0) {
    exceededLimitOutput.push([
      "No large dependencies found (> 500KB compressed)"
    ]);
  }
  exceededLimitOutput.push([]);
  exceededLimitOutput.push([
    "All dependencies",
    prettyBytes(pseudoLayerUncompressedBytes)
  ]);
  console.log(
    (0, import_text_table.default)(exceededLimitOutput, {
      align: ["l", "r"]
    })
  );
};
var detectLambdaLimitExceeding = async (lambdaGroups, compressedPages) => {
  const UNCOMPRESSED_SIZE_LIMIT_CLOSE = MAX_UNCOMPRESSED_LAMBDA_SIZE - 5 * MIB;
  let numExceededLimit = 0;
  let numCloseToLimit = 0;
  let loggedHeadInfo = false;
  const filteredGroups = lambdaGroups.filter((group) => {
    const exceededLimit = group.pseudoLayerUncompressedBytes > MAX_UNCOMPRESSED_LAMBDA_SIZE;
    const closeToLimit = group.pseudoLayerUncompressedBytes > UNCOMPRESSED_SIZE_LIMIT_CLOSE;
    if (closeToLimit || exceededLimit || (0, import_build_utils.getPlatformEnv)("BUILDER_DEBUG") || process.env.NEXT_DEBUG_FUNCTION_SIZE) {
      if (exceededLimit) {
        numExceededLimit += 1;
      }
      if (closeToLimit) {
        numCloseToLimit += 1;
      }
      return true;
    }
  });
  for (const group of filteredGroups) {
    if (!loggedHeadInfo) {
      if (numExceededLimit || numCloseToLimit) {
        console.log(
          `Warning: Max serverless function size of ${prettyBytes(
            MAX_UNCOMPRESSED_LAMBDA_SIZE
          )} uncompressed${numExceededLimit ? "" : " almost"} reached`
        );
      } else {
        console.log(`Serverless function size info`);
      }
      loggedHeadInfo = true;
    }
    outputFunctionFileSizeInfo(
      group.pages,
      group.pseudoLayer,
      group.pseudoLayerUncompressedBytes,
      compressedPages
    );
  }
  if (numExceededLimit) {
    console.log(
      `Max serverless function size was exceeded for ${numExceededLimit} function${numExceededLimit === 1 ? "" : "s"}`
    );
  }
};
var onPrerenderRouteInitial = (prerenderManifest, canUsePreviewMode, entryDirectory, nonLambdaSsgPages, routeKey, hasPages404, routesManifest, appDir) => {
  let static404Page;
  let static500Page;
  const pr = prerenderManifest.staticRoutes[routeKey];
  const { initialRevalidate, srcRoute, dataRoute } = pr;
  const route = srcRoute || routeKey;
  const isAppPathRoute = appDir && (!dataRoute || dataRoute?.endsWith(".rsc"));
  const routeNoLocale = routesManifest?.i18n ? normalizeLocalePath(routeKey, routesManifest.i18n.locales).pathname : routeKey;
  if (routeNoLocale === "/404") {
    static404Page = import_path2.default.posix.join(entryDirectory, routeKey);
  }
  if (routeNoLocale === "/500") {
    static500Page = import_path2.default.posix.join(entryDirectory, routeKey);
  }
  if (
    // App paths must be Prerenders to ensure Vary header is
    // correctly added
    !isAppPathRoute && initialRevalidate === false && (!canUsePreviewMode || hasPages404 && routeNoLocale === "/404") && !prerenderManifest.fallbackRoutes[route] && !prerenderManifest.blockingFallbackRoutes[route]
  ) {
    if (routesManifest?.i18n && Object.keys(prerenderManifest.staticRoutes).some((route2) => {
      const staticRoute = prerenderManifest.staticRoutes[route2];
      return staticRoute.srcRoute === srcRoute && staticRoute.initialRevalidate !== false;
    })) {
      return {
        static404Page,
        static500Page
      };
    }
    nonLambdaSsgPages.add(route === "/" ? "/index" : route);
  }
  return {
    static404Page,
    static500Page
  };
};
var prerenderGroup = 1;
var onPrerenderRoute = (prerenderRouteArgs) => async (routeKey, {
  isBlocking,
  isFallback,
  isOmitted,
  locale
}) => {
  const {
    appDir,
    pagesDir,
    static404Page,
    localePrefixed404,
    entryDirectory,
    prerenderManifest,
    isSharedLambdas,
    isServerMode,
    canUsePreviewMode,
    lambdas,
    experimentalStreamingLambdaPaths,
    prerenders,
    pageLambdaMap,
    routesManifest,
    isCorrectNotFoundRoutes,
    isEmptyAllowQueryForPrendered,
    isAppPPREnabled
  } = prerenderRouteArgs;
  if (isBlocking && isFallback) {
    throw new import_build_utils.NowBuildError({
      code: "NEXT_ISBLOCKING_ISFALLBACK",
      message: "invariant: isBlocking and isFallback cannot both be true"
    });
  }
  if (isFallback && isOmitted) {
    throw new import_build_utils.NowBuildError({
      code: "NEXT_ISOMITTED_ISFALLBACK",
      message: "invariant: isOmitted and isFallback cannot both be true"
    });
  }
  let routeFileNoExt = routeKey === "/" ? "/index" : routeKey;
  let origRouteFileNoExt = routeFileNoExt;
  const { isLocalePrefixed } = prerenderManifest;
  if (!locale && isLocalePrefixed) {
    const localePathResult = normalizeLocalePath(
      routeKey,
      routesManifest?.i18n?.locales || []
    );
    locale = localePathResult.detectedLocale;
    origRouteFileNoExt = localePathResult.pathname === "/" ? "/index" : localePathResult.pathname;
  }
  const nonDynamicSsg = !isFallback && !isBlocking && !isOmitted && !prerenderManifest.staticRoutes[routeKey].srcRoute;
  if (nonDynamicSsg && !isLocalePrefixed || isFallback || isOmitted) {
    routeFileNoExt = addLocaleOrDefault(
      // root index files are located without folder/index.html
      routeFileNoExt,
      routesManifest,
      locale
    );
  }
  const isNotFound = prerenderManifest.notFoundRoutes.includes(routeKey);
  let initialRevalidate;
  let srcRoute;
  let dataRoute;
  let prefetchDataRoute;
  let initialStatus;
  let initialHeaders;
  let experimentalBypassFor;
  let renderingMode;
  if (isFallback || isBlocking) {
    const pr = isFallback ? prerenderManifest.fallbackRoutes[routeKey] : prerenderManifest.blockingFallbackRoutes[routeKey];
    initialRevalidate = 1;
    if (initialRevalidate === false) {
      throw new import_build_utils.NowBuildError({
        code: "NEXT_ISLAZY_INITIALREVALIDATE",
        message: "invariant isLazy: initialRevalidate !== false"
      });
    }
    srcRoute = null;
    dataRoute = pr.dataRoute;
    experimentalBypassFor = pr.experimentalBypassFor;
    renderingMode = pr.renderingMode;
    prefetchDataRoute = pr.prefetchDataRoute;
  } else if (isOmitted) {
    initialRevalidate = false;
    srcRoute = routeKey;
    dataRoute = prerenderManifest.omittedRoutes[routeKey].dataRoute;
    experimentalBypassFor = prerenderManifest.omittedRoutes[routeKey].experimentalBypassFor;
    renderingMode = prerenderManifest.omittedRoutes[routeKey].renderingMode;
    prefetchDataRoute = prerenderManifest.omittedRoutes[routeKey].prefetchDataRoute;
  } else {
    const pr = prerenderManifest.staticRoutes[routeKey];
    ({
      initialRevalidate,
      srcRoute,
      dataRoute,
      initialHeaders,
      initialStatus,
      experimentalBypassFor,
      renderingMode,
      prefetchDataRoute
    } = pr);
  }
  let isAppPathRoute = false;
  if (appDir && renderingMode === "PARTIALLY_STATIC" /* PARTIALLY_STATIC */) {
    isAppPathRoute = true;
    if (isFallback) {
      const { fallbackStatus, fallbackHeaders } = prerenderManifest.fallbackRoutes[routeKey];
      if (fallbackStatus) {
        initialStatus = fallbackStatus;
      }
      if (fallbackHeaders) {
        initialHeaders = fallbackHeaders;
      }
    }
  }
  if (appDir && srcRoute && (!dataRoute || dataRoute?.endsWith(".rsc"))) {
    isAppPathRoute = true;
  }
  const isOmittedOrNotFound = isOmitted || isNotFound;
  let htmlFsRef = null;
  let postponedPrerender;
  if (renderingMode === "PARTIALLY_STATIC" /* PARTIALLY_STATIC */ && appDir) {
    const htmlPath = import_path2.default.join(appDir, `${routeFileNoExt}.html`);
    const metaPath = import_path2.default.join(appDir, `${routeFileNoExt}.meta`);
    if (import_fs_extra3.default.existsSync(htmlPath) && import_fs_extra3.default.existsSync(metaPath)) {
      const meta = JSON.parse(await import_fs_extra3.default.readFile(metaPath, "utf8"));
      if ("postponed" in meta && typeof meta.postponed === "string") {
        postponedPrerender = meta.postponed;
        initialHeaders ??= {};
        initialHeaders["content-type"] = `application/x-nextjs-pre-render; state-length=${meta.postponed.length}`;
        const html = await import_fs_extra3.default.readFileSync(htmlPath, "utf8");
        postponedPrerender += html;
      }
    }
    if (!dataRoute?.endsWith(".rsc")) {
      throw new Error(
        `Invariant: unexpected output path for ${dataRoute} and PPR`
      );
    }
    if (!prefetchDataRoute?.endsWith(".prefetch.rsc")) {
      throw new Error(
        `Invariant: unexpected output path for ${prefetchDataRoute} and PPR`
      );
    }
  }
  if (postponedPrerender) {
    const contentType = initialHeaders?.["content-type"];
    if (!contentType) {
      throw new Error("Invariant: contentType can't be undefined");
    }
    htmlFsRef = new import_build_utils.FileBlob({ contentType, data: postponedPrerender });
  } else if (appDir && !dataRoute && !prefetchDataRoute && isAppPathRoute && !(isBlocking || isFallback)) {
    const contentType = initialHeaders?.["content-type"];
    const fsPath = import_path2.default.join(appDir, `${routeFileNoExt}.body`);
    if (import_fs_extra3.default.existsSync(fsPath)) {
      htmlFsRef = new import_build_utils.FileFsRef({
        fsPath,
        contentType: contentType || "text/html;charset=utf-8"
      });
    }
  } else {
    htmlFsRef = isBlocking || isNotFound && !static404Page ? (
      // Blocking pages do not have an HTML fallback
      null
    ) : new import_build_utils.FileFsRef({
      fsPath: import_path2.default.join(
        isAppPathRoute && !isOmittedOrNotFound && appDir ? appDir : pagesDir,
        isFallback ? (
          // Fallback pages have a special file.
          addLocaleOrDefault(
            prerenderManifest.fallbackRoutes[routeKey].fallback,
            routesManifest,
            locale
          )
        ) : (
          // Otherwise, the route itself should exist as a static HTML
          // file.
          `${isOmittedOrNotFound ? localePrefixed404 ? addLocaleOrDefault("/404", routesManifest, locale) : "/404" : routeFileNoExt}.html`
        )
      )
    });
  }
  const jsonFsRef = (
    // JSON data does not exist for fallback or blocking pages
    isFallback || isBlocking || isNotFound && !static404Page || !dataRoute ? null : new import_build_utils.FileFsRef({
      fsPath: import_path2.default.join(
        isAppPathRoute && !isOmittedOrNotFound && appDir ? appDir : pagesDir,
        `${isOmittedOrNotFound ? localePrefixed404 ? addLocaleOrDefault("/404.html", routesManifest, locale) : "/404.html" : isAppPathRoute ? (
          // When experimental PPR is enabled, we expect that the data
          // that should be served as a part of the prerender should
          // be from the prefetch data route. If this isn't enabled
          // for ppr, the only way to get the data is from the data
          // route.
          renderingMode === "PARTIALLY_STATIC" /* PARTIALLY_STATIC */ ? prefetchDataRoute : dataRoute
        ) : routeFileNoExt + ".json"}`
      )
    })
  );
  if (isOmittedOrNotFound) {
    initialStatus = 404;
  }
  let outputPathPage = import_path2.default.posix.join(entryDirectory, routeFileNoExt);
  if (!isAppPathRoute) {
    outputPathPage = normalizeIndexOutput(outputPathPage, isServerMode);
  }
  const outputPathPageOrig = import_path2.default.posix.join(
    entryDirectory,
    origRouteFileNoExt
  );
  let lambda;
  function normalizeDataRoute(route) {
    let normalized = import_path2.default.posix.join(entryDirectory, route);
    if (nonDynamicSsg || isFallback || isOmitted) {
      normalized = normalized.replace(
        new RegExp(`${(0, import_escape_string_regexp.default)(origRouteFileNoExt)}.json$`),
        // ensure we escape "$" correctly while replacing as "$" is a special
        // character, we need to do double escaping as first is for the initial
        // replace on the routeFile and then the second on the outputPath
        `${routeFileNoExt.replace(/\$/g, "$$$$")}.json`
      );
    }
    return normalized;
  }
  let outputPathData = null;
  if (dataRoute) {
    outputPathData = normalizeDataRoute(dataRoute);
  }
  let outputPathPrefetchData = null;
  if (prefetchDataRoute) {
    if (!isAppPPREnabled) {
      throw new Error(
        "Invariant: prefetchDataRoute can't be set without PPR"
      );
    }
    outputPathPrefetchData = normalizeDataRoute(prefetchDataRoute);
  } else if (renderingMode === "PARTIALLY_STATIC" /* PARTIALLY_STATIC */) {
    throw new Error("Invariant: expected to find prefetch data route PPR");
  }
  if (isSharedLambdas) {
    const outputSrcPathPage = normalizeIndexOutput(
      import_path2.default.join(
        "/",
        srcRoute == null ? outputPathPageOrig : import_path2.default.posix.join(
          entryDirectory,
          srcRoute === "/" ? "/index" : srcRoute
        )
      ),
      isServerMode
    );
    const lambdaId = pageLambdaMap[outputSrcPathPage];
    lambda = lambdas[lambdaId];
  } else {
    let outputSrcPathPage = srcRoute == null ? outputPathPageOrig : import_path2.default.posix.join(
      entryDirectory,
      srcRoute === "/" ? "/index" : srcRoute
    );
    if (!isAppPathRoute) {
      outputSrcPathPage = normalizeIndexOutput(
        outputSrcPathPage,
        isServerMode
      );
    }
    lambda = lambdas[outputSrcPathPage];
  }
  if (!isAppPathRoute && !isNotFound && initialRevalidate === false) {
    if (htmlFsRef == null || jsonFsRef == null) {
      throw new import_build_utils.NowBuildError({
        code: "NEXT_HTMLFSREF_JSONFSREF",
        message: `invariant: htmlFsRef != null && jsonFsRef != null ${routeFileNoExt}`
      });
    }
    if (!canUsePreviewMode || routeKey === "/404" && !lambdas[outputPathPage]) {
      htmlFsRef.contentType = htmlContentType;
      prerenders[outputPathPage] = htmlFsRef;
      if (outputPathPrefetchData) {
        prerenders[outputPathPrefetchData] = jsonFsRef;
      }
      if (outputPathData && renderingMode !== "PARTIALLY_STATIC" /* PARTIALLY_STATIC */) {
        prerenders[outputPathData] = jsonFsRef;
      }
    }
  }
  const isNotFoundPreview = isCorrectNotFoundRoutes && !initialRevalidate && canUsePreviewMode && isServerMode && isNotFound;
  if (prerenders[outputPathPage] == null && (!isNotFound || initialRevalidate || isNotFoundPreview)) {
    if (lambda == null) {
      throw new import_build_utils.NowBuildError({
        code: "NEXT_MISSING_LAMBDA",
        message: `Unable to find lambda for route: ${routeFileNoExt}`
      });
    }
    const pageKey = srcRoute || routeKey;
    const route = routesManifest?.dynamicRoutes.find(
      (r) => r.page === pageKey && !("isMiddleware" in r)
    );
    const routeKeys = route?.routeKeys;
    let allowQuery;
    if (isEmptyAllowQueryForPrendered) {
      const isDynamic = isDynamicRoute(routeKey);
      if (!isDynamic) {
        allowQuery = [];
      } else if (routeKeys) {
        allowQuery = Object.values(routeKeys);
      }
    } else {
      const isDynamic = isDynamicRoute(pageKey);
      if (routeKeys) {
        allowQuery = Object.values(routeKeys);
      } else if (!isDynamic) {
        allowQuery = [];
      }
    }
    const rscEnabled = !!routesManifest?.rsc;
    const rscVaryHeader = routesManifest?.rsc?.varyHeader || "RSC, Next-Router-State-Tree, Next-Router-Prefetch";
    const rscContentTypeHeader = routesManifest?.rsc?.contentTypeHeader || RSC_CONTENT_TYPE;
    const rscDidPostponeHeader = routesManifest?.rsc?.didPostponeHeader;
    let sourcePath;
    if (`/${outputPathPage}` !== srcRoute && srcRoute) {
      sourcePath = srcRoute;
    }
    let chain;
    let experimentalStreamingLambdaPath;
    if (renderingMode === "PARTIALLY_STATIC" /* PARTIALLY_STATIC */ && experimentalStreamingLambdaPaths) {
      let paths = experimentalStreamingLambdaPaths.get(
        pathnameToOutputName(entryDirectory, routeKey)
      );
      if (!paths && srcRoute) {
        paths = experimentalStreamingLambdaPaths.get(
          pathnameToOutputName(entryDirectory, srcRoute)
        );
      }
      if (!paths) {
        throw new Error(
          `Invariant: experimentalStreamingLambdaPath is undefined for routeKey=${routeKey} and srcRoute=${srcRoute ?? "null"}`
        );
      }
      experimentalStreamingLambdaPath = paths.output;
      if (routesManifest?.ppr?.chain?.headers) {
        chain = {
          outputPath: pathnameToOutputName(entryDirectory, routeKey),
          headers: routesManifest.ppr.chain.headers
        };
      } else {
        chain = {
          outputPath: paths.output,
          headers: { "x-matched-path": paths.pathname }
        };
      }
    }
    prerenders[outputPathPage] = new import_build_utils.Prerender({
      expiration: initialRevalidate,
      lambda,
      allowQuery,
      fallback: htmlFsRef,
      group: prerenderGroup,
      bypassToken: prerenderManifest.bypassToken,
      experimentalBypassFor,
      initialStatus,
      initialHeaders,
      sourcePath,
      experimentalStreamingLambdaPath,
      chain,
      ...isNotFound ? {
        initialStatus: 404
      } : {},
      ...rscEnabled ? {
        initialHeaders: {
          ...initialHeaders,
          vary: rscVaryHeader
        }
      } : {}
    });
    const normalizePathData = (pathData) => {
      if ((srcRoute === "/" || srcRoute == "/index") && pathData.endsWith(RSC_PREFETCH_SUFFIX)) {
        delete lambdas[pathData];
        return pathData.replace(/([^/]+\.prefetch\.rsc)$/, "__$1");
      }
      return pathData;
    };
    if (outputPathData || outputPathPrefetchData) {
      const prerender = new import_build_utils.Prerender({
        expiration: initialRevalidate,
        lambda,
        allowQuery,
        fallback: jsonFsRef,
        group: prerenderGroup,
        bypassToken: prerenderManifest.bypassToken,
        experimentalBypassFor,
        ...isNotFound ? {
          initialStatus: 404
        } : {},
        ...rscEnabled ? {
          initialHeaders: {
            ...initialHeaders,
            vary: rscVaryHeader,
            ...(outputPathData || outputPathPrefetchData)?.endsWith(
              ".json"
            ) ? {
              "content-type": "application/json"
            } : {},
            ...isAppPathRoute ? {
              "content-type": rscContentTypeHeader
            } : {},
            ...postponedPrerender && rscDidPostponeHeader && !isFallback ? { [rscDidPostponeHeader]: "1" } : {}
          }
        } : {}
      });
      if (outputPathPrefetchData) {
        prerenders[normalizePathData(outputPathPrefetchData)] = prerender;
      }
      if (outputPathData && renderingMode !== "PARTIALLY_STATIC" /* PARTIALLY_STATIC */) {
        prerenders[normalizePathData(outputPathData)] = prerender;
      }
    }
    if (outputPathData?.endsWith(".json") && appDir) {
      const dummyOutput = new import_build_utils.FileBlob({
        data: "{}",
        contentType: "application/json"
      });
      const rscKey = `${outputPathPage}.rsc`;
      const prefetchRscKey = `${outputPathPage}${RSC_PREFETCH_SUFFIX}`;
      prerenders[rscKey] = dummyOutput;
      prerenders[prefetchRscKey] = dummyOutput;
    }
    ++prerenderGroup;
    if (routesManifest?.i18n && isBlocking) {
      for (const locale2 of routesManifest.i18n.locales) {
        const localeRouteFileNoExt = addLocaleOrDefault(
          routeFileNoExt,
          routesManifest,
          locale2
        );
        let localeOutputPathPage = import_path2.default.posix.join(
          entryDirectory,
          localeRouteFileNoExt
        );
        if (!isAppPathRoute) {
          localeOutputPathPage = normalizeIndexOutput(
            localeOutputPathPage,
            isServerMode
          );
        }
        const origPrerenderPage = prerenders[outputPathPage];
        prerenders[localeOutputPathPage] = {
          ...origPrerenderPage,
          group: prerenderGroup
        };
        if (outputPathData) {
          const localeOutputPathData = outputPathData.replace(
            new RegExp(`${(0, import_escape_string_regexp.default)(origRouteFileNoExt)}.json$`),
            `${localeRouteFileNoExt}${localeRouteFileNoExt !== origRouteFileNoExt && origRouteFileNoExt === "/index" ? "/index" : ""}.json`
          );
          const origPrerenderData = prerenders[outputPathData];
          prerenders[localeOutputPathData] = {
            ...origPrerenderData,
            group: prerenderGroup
          };
        }
        ++prerenderGroup;
      }
    }
  }
  if ((nonDynamicSsg && !isLocalePrefixed || isFallback || isOmitted) && routesManifest?.i18n && !locale) {
    for (const locale2 of routesManifest.i18n.locales) {
      if (locale2 === routesManifest.i18n.defaultLocale)
        continue;
      onPrerenderRoute(prerenderRouteArgs)(routeKey, {
        isBlocking,
        isFallback,
        isOmitted,
        locale: locale2
      });
    }
  }
};
async function getStaticFiles(entryPath, entryDirectory, outputDirectory) {
  const collectLabel = "Collected static files (public/, static/, .next/static)";
  console.time(collectLabel);
  const nextStaticFiles = await (0, import_build_utils.glob)(
    "**",
    import_path2.default.join(entryPath, outputDirectory, "static")
  );
  const staticFolderFiles = await (0, import_build_utils.glob)("**", import_path2.default.join(entryPath, "static"));
  let publicFolderFiles = {};
  let publicFolderPath;
  if (await import_fs_extra3.default.pathExists(import_path2.default.join(entryPath, "public"))) {
    publicFolderPath = import_path2.default.join(entryPath, "public");
  } else if (
    // check at the same level as the output directory also
    await import_fs_extra3.default.pathExists(import_path2.default.join(entryPath, outputDirectory, "../public"))
  ) {
    publicFolderPath = import_path2.default.join(entryPath, outputDirectory, "../public");
  }
  if (publicFolderPath) {
    (0, import_build_utils.debug)(`Using public folder at ${publicFolderPath}`);
    publicFolderFiles = await (0, import_build_utils.glob)("**/*", publicFolderPath);
  } else {
    (0, import_build_utils.debug)("No public folder found");
  }
  const staticFiles = {};
  const staticDirectoryFiles = {};
  const publicDirectoryFiles = {};
  for (const file of Object.keys(nextStaticFiles)) {
    staticFiles[import_path2.default.posix.join(entryDirectory, `_next/static/${file}`)] = nextStaticFiles[file];
  }
  for (const file of Object.keys(staticFolderFiles)) {
    staticDirectoryFiles[import_path2.default.posix.join(entryDirectory, "static", file)] = staticFolderFiles[file];
  }
  for (const file of Object.keys(publicFolderFiles)) {
    publicDirectoryFiles[import_path2.default.posix.join(entryDirectory, file)] = publicFolderFiles[file];
  }
  console.timeEnd(collectLabel);
  return {
    staticFiles,
    staticDirectoryFiles,
    publicDirectoryFiles
  };
}
function normalizeIndexOutput(outputName, isServerMode) {
  if (outputName !== "index" && outputName !== "/index" && isServerMode) {
    return outputName.replace(/\/index$/, "");
  }
  return outputName;
}
function getNextServerPath(nextVersion) {
  return import_semver.default.gte(nextVersion, "v11.0.2-canary.4") ? "next/dist/server" : "next/dist/next-server/server";
}
function pathnameToOutputName(entryDirectory, pathname) {
  if (pathname === "/") {
    pathname = "/index";
  }
  return import_path2.default.posix.join(entryDirectory, pathname);
}
function getPostponeResumePathname(pathname) {
  if (pathname === "/")
    pathname = "/index";
  return import_path2.default.posix.join("_next/postponed/resume", pathname);
}
function getPostponeResumeOutput(entryDirectory, pathname) {
  if (pathname === "/")
    pathname = "/index";
  return import_path2.default.posix.join(entryDirectory, "_next/postponed/resume", pathname);
}
function updateRouteSrc(route, index, manifestItems) {
  if (route.src) {
    route.src = manifestItems[index].regex;
  }
  return route;
}
async function getPrivateOutputs(dir, entries) {
  const files = {};
  const routes = [];
  for (const [existingFile, outputFile] of Object.entries(entries)) {
    const fsPath = import_path2.default.join(dir, existingFile);
    try {
      const { mode, size } = await (0, import_fs_extra3.stat)(fsPath);
      if (size > 30 * 1024 * 1024) {
        throw new Error(`Exceeds maximum file size: ${size}`);
      }
      files[outputFile] = new import_build_utils.FileFsRef({ mode, fsPath });
      routes.push({
        src: `/${outputFile}`,
        dest: "/404",
        status: 404,
        continue: true
      });
    } catch (error) {
      (0, import_build_utils.debug)(
        `Private file ${existingFile} had an error and will not be uploaded: ${error}`
      );
    }
  }
  return { files, routes };
}
var vercelFunctionRegionsVar = process.env.VERCEL_FUNCTION_REGIONS;
var vercelFunctionRegions;
if (vercelFunctionRegionsVar) {
  vercelFunctionRegions = vercelFunctionRegionsVar.split(",");
}
function normalizeRegions(regions) {
  if (typeof regions === "string") {
    regions = [regions];
  }
  const newRegions = [];
  for (const region of regions) {
    if (region === "home") {
      if (vercelFunctionRegions) {
        newRegions.push(...vercelFunctionRegions);
      }
      continue;
    }
    if (region === "global") {
      return "all";
    }
    if (region === "auto") {
      return "auto";
    }
    newRegions.push(region);
  }
  if (newRegions.length === 0) {
    return void 0;
  }
  return newRegions;
}
function normalizeEdgeFunctionPath(shortPath, appPathRoutesManifest) {
  if (shortPath.startsWith("app/") && (shortPath.endsWith("/page") || shortPath.endsWith("/route") || shortPath === "app/_not-found")) {
    const ogRoute = shortPath.replace(/^app\//, "/");
    shortPath = (appPathRoutesManifest[ogRoute] || shortPath.replace(/(^|\/)(page|route)$/, "")).replace(/^\//, "");
    if (!shortPath || shortPath === "/") {
      shortPath = "index";
    }
  }
  if (shortPath.startsWith("pages/")) {
    shortPath = shortPath.replace(/^pages\//, "");
  }
  return shortPath;
}
async function getMiddlewareBundle({
  entryPath,
  outputDirectory,
  routesManifest,
  isCorrectMiddlewareOrder,
  prerenderBypassToken,
  nextVersion,
  appPathRoutesManifest
}) {
  const middlewareManifest = await getMiddlewareManifest(
    entryPath,
    outputDirectory
  );
  const sortedFunctions = [
    ...!middlewareManifest ? [] : middlewareManifest.sortedMiddleware.map((key) => ({
      key,
      edgeFunction: middlewareManifest?.middleware[key],
      type: "middleware"
    })),
    ...Object.entries(middlewareManifest?.functions ?? {}).map(
      ([key, edgeFunction]) => {
        return {
          key,
          edgeFunction,
          type: "function"
        };
      }
    )
  ];
  if (middlewareManifest && sortedFunctions.length > 0) {
    const workerConfigs = await Promise.all(
      sortedFunctions.map(async ({ key, edgeFunction, type }) => {
        try {
          const wrappedModuleSource = await getNextjsEdgeFunctionSource(
            edgeFunction.files,
            {
              name: edgeFunction.name,
              staticRoutes: routesManifest.staticRoutes,
              dynamicRoutes: routesManifest.dynamicRoutes.filter(
                (r) => !("isMiddleware" in r)
              ),
              nextConfig: {
                basePath: routesManifest.basePath,
                i18n: routesManifest.i18n
              }
            },
            import_path2.default.resolve(entryPath, outputDirectory),
            edgeFunction.wasm
          );
          return {
            type,
            page: edgeFunction.page,
            name: edgeFunction.name,
            edgeFunction: (() => {
              const { source: source2, map } = wrappedModuleSource.sourceAndMap();
              const transformedMap = stringifySourceMap(
                transformSourceMap(map)
              );
              const wasmFiles = (edgeFunction.wasm ?? []).reduce(
                (acc, { filePath, name }) => {
                  const fullFilePath = import_path2.default.join(
                    entryPath,
                    outputDirectory,
                    filePath
                  );
                  acc[`wasm/${name}.wasm`] = new import_build_utils.FileFsRef({
                    mode: 420,
                    contentType: "application/wasm",
                    fsPath: fullFilePath
                  });
                  return acc;
                },
                {}
              );
              const assetFiles = (edgeFunction.assets ?? []).reduce(
                (acc, { filePath, name }) => {
                  const fullFilePath = import_path2.default.join(
                    entryPath,
                    outputDirectory,
                    filePath
                  );
                  acc[`assets/${name}`] = new import_build_utils.FileFsRef({
                    mode: 420,
                    contentType: "application/octet-stream",
                    fsPath: fullFilePath
                  });
                  return acc;
                },
                {}
              );
              return new import_build_utils.EdgeFunction({
                deploymentTarget: "v8-worker",
                name: edgeFunction.name,
                files: {
                  "index.js": new import_build_utils.FileBlob({
                    data: source2,
                    contentType: "application/javascript",
                    mode: 420
                  }),
                  ...transformedMap && {
                    "index.js.map": new import_build_utils.FileBlob({
                      data: transformedMap,
                      contentType: "application/json",
                      mode: 420
                    })
                  },
                  ...wasmFiles,
                  ...assetFiles
                },
                regions: edgeFunction.regions ? normalizeRegions(edgeFunction.regions) : void 0,
                entrypoint: "index.js",
                assets: (edgeFunction.assets ?? []).map(({ name }) => {
                  return {
                    name,
                    path: `assets/${name}`
                  };
                }),
                framework: {
                  slug: "nextjs",
                  version: nextVersion
                },
                environment: edgeFunction.env
              });
            })(),
            routeMatchers: getRouteMatchers(edgeFunction, routesManifest)
          };
        } catch (e) {
          e.message = `Can't build edge function ${key}: ${e.message}`;
          throw e;
        }
      })
    );
    const source = {
      staticRoutes: [],
      dynamicRouteMap: /* @__PURE__ */ new Map(),
      edgeFunctions: {}
    };
    for (const worker of workerConfigs.values()) {
      let shortPath = worker.name;
      if (shortPath.startsWith("pages/")) {
        shortPath = shortPath.replace(/^pages\//, "");
      } else {
        shortPath = normalizeEdgeFunctionPath(shortPath, appPathRoutesManifest);
      }
      if (routesManifest?.basePath) {
        const isAppPathRoute = !!appPathRoutesManifest[shortPath];
        shortPath = import_path2.default.posix.join(
          "./",
          routesManifest?.basePath,
          shortPath.replace(/^\//, "")
        );
        if (!isAppPathRoute) {
          shortPath = normalizeIndexOutput(shortPath, true);
        }
      }
      worker.edgeFunction.name = shortPath;
      source.edgeFunctions[shortPath] = worker.edgeFunction;
      if (worker.type === "function") {
        continue;
      }
      for (const matcher of worker.routeMatchers) {
        const route = {
          continue: true,
          src: matcher.regexp,
          has: matcher.has,
          missing: [
            {
              type: "header",
              key: "x-prerender-revalidate",
              value: prerenderBypassToken
            },
            ...matcher.missing || []
          ]
        };
        route.middlewarePath = shortPath;
        route.middlewareRawSrc = matcher.originalSource ? [matcher.originalSource] : [];
        if (isCorrectMiddlewareOrder) {
          route.override = true;
        }
        if (routesManifest.version > 3 && isDynamicRoute(worker.page)) {
          source.dynamicRouteMap.set(worker.page, route);
        } else {
          source.staticRoutes.push(route);
        }
      }
    }
    return source;
  }
  return {
    staticRoutes: [],
    dynamicRouteMap: /* @__PURE__ */ new Map(),
    edgeFunctions: {}
  };
}
async function getFunctionsConfigManifest(entryPath, outputDirectory) {
  const functionConfigManifestPath = import_path2.default.join(
    entryPath,
    outputDirectory,
    "./server/functions-config-manifest.json"
  );
  const hasManifest = await import_fs_extra3.default.access(functionConfigManifestPath).then(() => true).catch(() => false);
  if (!hasManifest) {
    return;
  }
  const manifest = await import_fs_extra3.default.readJSON(
    functionConfigManifestPath
  );
  return manifest.version === 1 ? manifest : void 0;
}
async function getMiddlewareManifest(entryPath, outputDirectory) {
  const middlewareManifestPath = import_path2.default.join(
    entryPath,
    outputDirectory,
    "./server/middleware-manifest.json"
  );
  const hasManifest = await import_fs_extra3.default.access(middlewareManifestPath).then(() => true).catch(() => false);
  if (!hasManifest) {
    return;
  }
  const manifest = await import_fs_extra3.default.readJSON(
    middlewareManifestPath
  );
  if (manifest.version === 1) {
    return upgradeMiddlewareManifestV1(manifest);
  }
  if (manifest.version === 2) {
    return upgradeMiddlewareManifestV2(manifest);
  }
  return manifest;
}
function upgradeMiddlewareManifestV1(v1) {
  function updateInfo(v1Info) {
    const { regexp, ...rest } = v1Info;
    return {
      ...rest,
      matchers: [{ regexp }],
      env: {}
    };
  }
  const middleware = Object.fromEntries(
    Object.entries(v1.middleware).map(([p, info]) => [p, updateInfo(info)])
  );
  const functions = v1.functions ? Object.fromEntries(
    Object.entries(v1.functions).map(([p, info]) => [p, updateInfo(info)])
  ) : void 0;
  return {
    ...v1,
    version: 3,
    middleware,
    functions
  };
}
function upgradeMiddlewareManifestV2(v2) {
  function updateInfo(v2Info) {
    const { ...rest } = v2Info;
    return {
      ...rest,
      env: {}
    };
  }
  const middleware = Object.fromEntries(
    Object.entries(v2.middleware).map(([p, info]) => [p, updateInfo(info)])
  );
  const functions = v2.functions ? Object.fromEntries(
    Object.entries(v2.functions).map(([p, info]) => [p, updateInfo(info)])
  ) : void 0;
  return {
    ...v2,
    version: 3,
    middleware,
    functions
  };
}
function getRouteMatchers(info, { basePath = "", i18n }) {
  function getRegexp(regexp) {
    if (info.page === "/") {
      return regexp;
    }
    const locale = i18n?.locales.length ? `(?:/(${i18n.locales.map((locale2) => (0, import_escape_string_regexp.default)(locale2)).join("|")}))?` : "";
    return `(?:^${basePath}${locale}${regexp.substring(1)})`;
  }
  function normalizeHas(has) {
    return has.map(
      (v) => v.type === "header" ? {
        ...v,
        key: v.key.toLowerCase()
      } : v
    );
  }
  return info.matchers.map((matcher) => {
    const m = {
      regexp: getRegexp(matcher.regexp),
      originalSource: matcher.originalSource
    };
    if (matcher.has) {
      m.has = normalizeHas(matcher.has);
    }
    if (matcher.missing) {
      m.missing = normalizeHas(matcher.missing);
    }
    return m;
  });
}
function transformSourceMap(sourcemap) {
  if (!sourcemap)
    return;
  const sources = sourcemap.sources?.map((source) => {
    return source.replace(/^webpack:\/\/?_N_E\/(?:\.\/)?/, "");
  }).map((source) => {
    return source.startsWith("?") ? "[native code]" : source;
  });
  return { ...sourcemap, sources };
}
function getOperationType({
  group,
  prerenderManifest,
  pageFileName
}) {
  if (group?.isApiLambda || isApiPage(pageFileName)) {
    return "API";
  }
  if (group?.isPrerenders) {
    return "ISR";
  }
  if (pageFileName && prerenderManifest) {
    const { blockingFallbackRoutes = {}, fallbackRoutes = {} } = prerenderManifest;
    if (pageFileName in blockingFallbackRoutes || pageFileName in fallbackRoutes) {
      return "ISR";
    }
  }
  return "Page";
}
function isApiPage(page) {
  if (!page) {
    return false;
  }
  return page.replace(/\\/g, "/").match(/(serverless|server)\/pages\/api(\/|\.js$)/);
}
async function getVariantsManifest(entryPath, outputDirectory) {
  const pathVariantsManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "variants-manifest.json"
  );
  const hasVariantsManifest = await import_fs_extra3.default.access(pathVariantsManifest).then(() => true).catch(() => false);
  if (!hasVariantsManifest)
    return null;
  const variantsManifest = await import_fs_extra3.default.readJSON(pathVariantsManifest);
  return variantsManifest;
}
async function getServerlessPages(params) {
  const appDir = import_path2.default.join(params.pagesDir, "../app");
  const [pages, appPaths, middlewareManifest] = await Promise.all([
    (0, import_build_utils.glob)("**/!(_middleware).js", params.pagesDir),
    params.appPathRoutesManifest ? Promise.all([
      (0, import_build_utils.glob)("**/page.js", appDir),
      (0, import_build_utils.glob)("**/route.js", appDir),
      (0, import_build_utils.glob)("**/_not-found.js", appDir)
    ]).then((items) => Object.assign(...items)) : Promise.resolve({}),
    getMiddlewareManifest(params.entryPath, params.outputDirectory)
  ]);
  const normalizedAppPaths = {};
  if (params.appPathRoutesManifest) {
    for (const [entry, normalizedEntry] of Object.entries(
      params.appPathRoutesManifest
    )) {
      const normalizedPath = `${import_path2.default.join(
        ".",
        normalizedEntry === "/" ? "/index" : normalizedEntry
      )}.js`;
      const globPath = `${import_path2.default.posix.join(".", entry)}.js`;
      if (appPaths[globPath]) {
        normalizedAppPaths[normalizedPath] = appPaths[globPath];
      }
    }
  }
  for (const edgeFunctionFile of Object.keys(
    middlewareManifest?.functions ?? {}
  )) {
    let edgePath = middlewareManifest?.functions?.[edgeFunctionFile].name || edgeFunctionFile;
    edgePath = normalizeEdgeFunctionPath(
      edgePath,
      params.appPathRoutesManifest || {}
    );
    edgePath = (edgePath || "index") + ".js";
    delete normalizedAppPaths[edgePath];
    delete pages[edgePath];
  }
  return { pages, appPaths: normalizedAppPaths };
}
function normalizePrefetches(prefetches) {
  const updatedPrefetches = {};
  for (const key in prefetches) {
    if (key === "index.prefetch.rsc") {
      const newKey = key.replace(/([^/]+\.prefetch\.rsc)$/, "__$1");
      updatedPrefetches[newKey] = prefetches[key];
    } else {
      updatedPrefetches[key] = prefetches[key];
    }
  }
  return updatedPrefetches;
}

// src/create-serverless-config.ts
function getCustomData(importName, target) {
  return `
// @ts-nocheck
module.exports = function(...args) {
  let original = require('./${importName}');

  const finalConfig = {};
  const target = { target: '${target}' };

  if (typeof original === 'function' && original.constructor.name === 'AsyncFunction') {
    // AsyncFunctions will become promises
    original = original(...args);
  }

  if (original instanceof Promise) {
    // Special case for promises, as it's currently not supported
    // and will just error later on
    return original
      .then((orignalConfig) => Object.assign(finalConfig, orignalConfig))
      .then((config) => Object.assign(config, target));
  } else if (typeof original === 'function') {
    Object.assign(finalConfig, original(...args));
  } else if (typeof original === 'object') {
    Object.assign(finalConfig, original);
  }

  Object.assign(finalConfig, target);

  return finalConfig;
}
  `.trim();
}
function getDefaultData(target) {
  return `
// @ts-nocheck
module.exports = { target: '${target}' };
  `.trim();
}
async function createServerlessConfig(workPath, entryPath, nextVersion) {
  let target = "serverless";
  if (nextVersion) {
    try {
      if (import_semver2.default.gte(nextVersion, ExperimentalTraceVersion)) {
        target = "experimental-serverless-trace";
      }
    } catch (_ignored) {
    }
  }
  const primaryConfigPath = import_path3.default.join(entryPath, "next.config.js");
  const secondaryConfigPath = import_path3.default.join(workPath, "next.config.js");
  const backupConfigName = `next.config.__vercel_builder_backup__.js`;
  const hasPrimaryConfig = import_fs_extra4.default.existsSync(primaryConfigPath);
  const hasSecondaryConfig = import_fs_extra4.default.existsSync(secondaryConfigPath);
  let configPath;
  let backupConfigPath;
  if (hasPrimaryConfig) {
    configPath = primaryConfigPath;
    backupConfigPath = import_path3.default.join(entryPath, backupConfigName);
  } else if (hasSecondaryConfig) {
    configPath = secondaryConfigPath;
    backupConfigPath = import_path3.default.join(workPath, backupConfigName);
  } else {
    configPath = primaryConfigPath;
    backupConfigPath = import_path3.default.join(entryPath, backupConfigName);
  }
  if (import_fs_extra4.default.existsSync(configPath)) {
    await import_fs_extra4.default.rename(configPath, backupConfigPath);
    await import_fs_extra4.default.writeFile(configPath, getCustomData(backupConfigName, target));
  } else {
    await import_fs_extra4.default.writeFile(configPath, getDefaultData(target));
  }
  return target;
}

// src/legacy-versions.ts
var legacy_versions_default = [
  "0.1.0",
  "0.1.1",
  "0.2.0",
  "0.2.1",
  "0.2.2",
  "0.2.3",
  "0.2.4",
  "0.2.5",
  "0.2.6",
  "0.2.7",
  "0.2.8",
  "0.2.9",
  "0.2.10",
  "0.2.11",
  "0.2.12",
  "0.2.13",
  "0.2.14",
  "0.3.0",
  "0.3.1",
  "0.3.2",
  "0.3.3",
  "0.4.0",
  "0.4.1",
  "0.9.9",
  "0.9.10",
  "0.9.11",
  "1.0.0",
  "1.0.1",
  "1.0.2",
  "1.1.0",
  "1.1.1",
  "1.1.2",
  "1.2.0",
  "1.2.1",
  "1.2.2",
  "1.2.3",
  "2.0.0-beta.0",
  "2.0.0-beta.1",
  "2.0.0-beta.2",
  "2.0.0-beta.3",
  "2.0.0-beta.4",
  "2.0.0-beta.5",
  "2.0.0-beta.6",
  "2.0.0-beta.7",
  "2.0.0-beta.8",
  "2.0.0-beta.9",
  "2.0.0-beta.10",
  "2.0.0-beta.11",
  "2.0.0-beta.12",
  "2.0.0-beta.13",
  "2.0.0-beta.14",
  "2.0.0-beta.15",
  "2.0.0-beta.16",
  "2.0.0-beta.17",
  "2.0.0-beta.18",
  "2.0.0-beta.19",
  "2.0.0-beta.20",
  "2.0.0-beta.21",
  "2.0.0-beta.22",
  "2.0.0-beta.23",
  "2.0.0-beta.24",
  "2.0.0-beta.25",
  "2.0.0-beta.26",
  "2.0.0-beta.27",
  "2.0.0-beta.28",
  "2.0.0-beta.29",
  "2.0.0-beta.30",
  "2.0.0-beta.31",
  "2.0.0-beta.32",
  "2.0.0-beta.33",
  "2.0.0-beta.34",
  "2.0.0-beta.35",
  "2.0.0-beta.36",
  "2.0.0-beta.37",
  "2.0.0-beta.38",
  "2.0.0-beta.39",
  "2.0.0-beta.40",
  "2.0.0-beta.41",
  "2.0.0-beta.42",
  "2.0.0",
  "2.0.1",
  "2.1.0",
  "2.1.1",
  "2.2.0",
  "2.3.0-alpha1",
  "2.3.0",
  "2.3.1",
  "2.4.0",
  "2.4.1",
  "2.4.2",
  "2.4.3",
  "2.4.4",
  "2.4.5",
  "2.4.6",
  "2.4.7",
  "2.4.8",
  "2.4.9",
  "3.0.0-beta1",
  "3.0.0-beta10",
  "3.0.0-beta11",
  "3.0.0-beta12",
  "3.0.0-beta13",
  "3.0.0-beta14",
  "3.0.0-beta15",
  "3.0.0-beta16",
  "3.0.0-beta2",
  "3.0.0-beta3",
  "3.0.0-beta4",
  "3.0.0-beta5",
  "3.0.0-beta6",
  "3.0.0-beta7",
  "3.0.0-beta8",
  "3.0.0-beta9",
  "3.0.1-beta.1",
  "3.0.1-beta.2",
  "3.0.1-beta.3",
  "3.0.1-beta.4",
  "3.0.1-beta.5",
  "3.0.1-beta.6",
  "3.0.1-beta.7",
  "3.0.1-beta.8",
  "3.0.1-beta.9",
  "3.0.1-beta.10",
  "3.0.1-beta.11",
  "3.0.1-beta.12",
  "3.0.1-beta.13",
  "3.0.1-beta.14",
  "3.0.1-beta.15",
  "3.0.1-beta.16",
  "3.0.1-beta.17",
  "3.0.1-beta.18",
  "3.0.1-beta.19",
  "3.0.1-beta.20",
  "3.0.1-beta.21",
  "3.0.1",
  "3.0.2",
  "3.0.3",
  "3.0.4",
  "3.0.5",
  "3.0.6",
  "3.1.0",
  "3.2.0",
  "3.2.1",
  "3.2.2",
  "3.2.3",
  "4.0.0-beta.1",
  "4.0.0-beta.2",
  "4.0.0-beta.3",
  "4.0.0-beta.4",
  "4.0.0-beta.5",
  "4.0.0-beta.6",
  "4.0.0",
  "4.0.1",
  "4.0.2",
  "4.0.3",
  "4.0.4",
  "4.0.5",
  "4.1.0",
  "4.1.1",
  "4.1.2",
  "4.1.3",
  "4.1.4-canary.1",
  "4.1.4-canary.2",
  "4.1.4",
  "4.2.0-canary.1",
  "4.2.0-zones.2",
  "4.2.0",
  "4.2.1",
  "4.2.2",
  "4.2.3",
  "4.3.0-canary.1",
  "4.3.0-universal-alpha.1",
  "4.3.0-universal-alpha.2",
  "4.3.0-universal-alpha.3",
  "4.3.0-universal-alpha.4",
  "4.3.0-zones.1",
  "4.4.0-canary.2",
  "4.4.0-canary.3",
  "5.0.0-universal-alpha.1",
  "5.0.0-universal-alpha.2",
  "5.0.0-universal-alpha.3",
  "5.0.0-universal-alpha.4",
  "5.0.0-universal-alpha.5",
  "5.0.0-universal-alpha.6",
  "5.0.0-universal-alpha.7",
  "5.0.0-universal-alpha.8",
  "5.0.0-universal-alpha.9",
  "5.0.0-universal-alpha.10",
  "5.0.0-universal-alpha.11",
  "5.0.0-universal-alpha.12",
  "5.0.0-universal-alpha.13",
  "5.0.0-universal-alpha.14",
  "5.0.0-universal-alpha.15",
  "5.0.0-universal-alpha.16",
  "5.0.0-universal-alpha.17",
  "5.0.0-universal-alpha.18",
  "5.0.0-universal-alpha.19",
  "5.0.0-universal-alpha.20",
  "5.0.0-universal-alpha.21",
  "5.0.0-universal-alpha.22",
  "5.0.0-universal-alpha.23",
  "5.0.0-zones.1",
  "5.0.0",
  "5.0.1-canary.1",
  "5.0.1-canary.2",
  "5.0.1-canary.3",
  "5.0.1-canary.4",
  "5.0.1-canary.5",
  "5.0.1-canary.6",
  "5.0.1-canary.7",
  "5.0.1-canary.8",
  "5.0.1-canary.9",
  "5.0.1-canary.10",
  "5.0.1-canary.11",
  "5.0.1-canary.12",
  "5.0.1-canary.13",
  "5.0.1-canary.14",
  "5.0.1-canary.15",
  "5.0.1-canary.16",
  "5.0.1-canary.17",
  "5.1.0",
  "6.0.0-canary.1",
  "6.0.0-canary.2",
  "6.0.0-canary.3",
  "6.0.0-canary.4",
  "6.0.0-canary.5",
  "6.0.0-canary.6",
  "6.0.0-canary.7",
  "6.0.0",
  "6.0.1-canary.0",
  "6.0.1-canary.1",
  "6.0.1-canary.2",
  "6.0.1",
  "6.0.2-canary.0",
  "6.0.2",
  "6.0.3-canary.0",
  "6.0.3-canary.1",
  "6.0.3",
  "6.0.4-canary.0",
  "6.0.4-canary.1",
  "6.0.4-canary.2",
  "6.0.4-canary.3",
  "6.0.4-canary.4",
  "6.0.4-canary.5",
  "6.0.4-canary.6",
  "6.0.4-canary.7",
  "6.0.4-canary.8",
  "6.0.4-canary.9",
  "6.1.0-canary.0",
  "6.1.0",
  "6.1.1-canary.0",
  "6.1.1-canary.1",
  "6.1.1-canary.2",
  "6.1.1-canary.3",
  "6.1.1-canary.4",
  "6.1.1-canary.5",
  "6.1.1",
  "6.1.2",
  "7.0.0-canary.0",
  "7.0.0-canary.1",
  "7.0.0-canary.2",
  "7.0.0-canary.3",
  "7.0.0-canary.4",
  "7.0.0-canary.5",
  "7.0.0-canary.6",
  "7.0.0-canary.7",
  "7.0.0-canary.8",
  "7.0.0-canary.9",
  "7.0.0-canary.10",
  "7.0.0-canary.11",
  "7.0.0-canary.12",
  "7.0.0-canary.13",
  "7.0.0-canary.14",
  "7.0.0-canary.15",
  "7.0.0-canary.16",
  "7.0.0-canary.18",
  "7.0.0-canary.19",
  "7.0.0-canary.20",
  "7.0.0",
  "7.0.1-canary.0",
  "7.0.1-canary.1",
  "7.0.1-canary.2",
  "7.0.1-canary.3",
  "7.0.1-canary.4",
  "7.0.1-canary.5",
  "7.0.1-canary.6",
  "7.0.1",
  "7.0.2-alpha.1",
  "7.0.2-alpha.3",
  "7.0.2-canary.5",
  "7.0.2-canary.6",
  "7.0.2-canary.7",
  "7.0.2-canary.8",
  "7.0.2-canary.9",
  "7.0.2-canary.10",
  "7.0.2-canary.11",
  "7.0.2-canary.12",
  "7.0.2-canary.13",
  "7.0.2-canary.14",
  "7.0.2-canary.15",
  "7.0.2-canary.16",
  "7.0.2-canary.17",
  "7.0.2-canary.18",
  "7.0.2-canary.19",
  "7.0.2-canary.20",
  "7.0.2-canary.21",
  "7.0.2-canary.22",
  "7.0.2-canary.23",
  "7.0.2-canary.24",
  "7.0.2-canary.25",
  "7.0.2-canary.26",
  "7.0.2-canary.27",
  "7.0.2-canary.28",
  "7.0.2-canary.29",
  "7.0.2-canary.31",
  "7.0.2-canary.33",
  "7.0.2-canary.34",
  "7.0.2-canary.35",
  "7.0.2-canary.36",
  "7.0.2-canary.37",
  "7.0.2-canary.38",
  "7.0.2-canary.39",
  "7.0.2-canary.40",
  "7.0.2-canary.41",
  "7.0.2-canary.42",
  "7.0.2-canary.43",
  "7.0.2-canary.44",
  "7.0.2-canary.45",
  "7.0.2-canary.46",
  "7.0.2-canary.47",
  "7.0.2-canary.48",
  "7.0.2-canary.49",
  "7.0.2-canary.50",
  "7.0.2"
];

// src/server-build.ts
var import_path4 = __toESM(require("path"));
var import_semver3 = __toESM(require_semver());
var import_async_sema2 = __toESM(require_lib());
var import_build_utils2 = require("@vercel/build-utils");
var import_nft = require("@vercel/nft");
var import_resolve_from = __toESM(require_resolve_from());
var import_fs_extra5 = __toESM(require_lib2());
var import_escape_string_regexp2 = __toESM(require_escape_string_regexp());
var import_pretty_bytes3 = __toESM(require_pretty_bytes());
var CORRECT_NOT_FOUND_ROUTES_VERSION = "v12.0.1";
var CORRECT_MIDDLEWARE_ORDER_VERSION = "v12.1.7-canary.29";
var NEXT_DATA_MIDDLEWARE_RESOLVING_VERSION = "v12.1.7-canary.33";
var EMPTY_ALLOW_QUERY_FOR_PRERENDERED_VERSION = "v12.2.0";
var CORRECTED_MANIFESTS_VERSION = "v12.2.0";
var PRELOAD_CHUNKS = {
  APP_ROUTER_PAGES: [
    ".next/server/webpack-runtime.js",
    "next/dist/client/components/action-async-storage.external.js",
    "next/dist/client/components/request-async-storage.external.js",
    "next/dist/client/components/static-generation-async-storage.external.js",
    "next/dist/compiled/next-server/app-page.runtime.prod.js"
  ],
  APP_ROUTER_HANDLER: [
    ".next/server/webpack-runtime.js",
    "next/dist/compiled/next-server/app-route.runtime.prod.js"
  ],
  PAGES_ROUTER_PAGES: [
    ".next/server/webpack-runtime.js",
    "next/dist/compiled/next-server/pages.runtime.prod.js"
  ],
  PAGES_ROUTER_API: [
    ".next/server/webpack-api-runtime.js",
    "next/dist/compiled/next-server/pages-api.runtime.prod.js"
  ]
};
var BUNDLED_SERVER_NEXT_VERSION = "v13.5.4";
var BUNDLED_SERVER_NEXT_PATH = "next/dist/compiled/next-server/server.runtime.prod.js";
async function serverBuild({
  dynamicPages,
  pagesDir,
  config = {},
  functionsConfigManifest,
  privateOutputs,
  baseDir,
  workPath,
  entryPath,
  nodeVersion,
  buildId,
  escapedBuildId,
  dynamicPrefix,
  entryDirectory,
  outputDirectory,
  redirects,
  beforeFilesRewrites,
  afterFilesRewrites,
  fallbackRewrites,
  headers,
  dataRoutes,
  hasIsr404Page,
  hasIsr500Page,
  imagesManifest,
  wildcardConfig,
  routesManifest,
  staticPages,
  lambdaPages,
  localePrefixed404,
  nextVersion,
  lambdaAppPaths,
  canUsePreviewMode,
  trailingSlash,
  prerenderManifest,
  appPathRoutesManifest,
  omittedPrerenderRoutes,
  trailingSlashRedirects,
  isCorrectLocaleAPIRoutes,
  requiredServerFilesManifest,
  variantsManifest,
  experimentalPPRRoutes,
  isAppPPREnabled
}) {
  if (isAppPPREnabled) {
    (0, import_build_utils2.debug)(
      "experimentalPPRRoutes",
      JSON.stringify(Array.from(experimentalPPRRoutes))
    );
  }
  lambdaPages = Object.assign({}, lambdaPages, lambdaAppPaths);
  const experimentalAllowBundling = Boolean(
    process.env.NEXT_EXPERIMENTAL_FUNCTION_BUNDLING
  );
  const lambdas = {};
  const prerenders = {};
  const lambdaPageKeys = Object.keys(lambdaPages);
  const internalPages = ["_app.js", "_error.js", "_document.js"];
  const pageBuildTraces = await (0, import_build_utils2.glob)("**/*.js.nft.json", pagesDir);
  const isEmptyAllowQueryForPrendered = import_semver3.default.gte(
    nextVersion,
    EMPTY_ALLOW_QUERY_FOR_PRERENDERED_VERSION
  );
  const projectDir = requiredServerFilesManifest.relativeAppDir ? import_path4.default.join(baseDir, requiredServerFilesManifest.relativeAppDir) : requiredServerFilesManifest.appDir || entryPath;
  const inversedAppPathManifest = {};
  if (appPathRoutesManifest) {
    for (const ogRoute of Object.keys(appPathRoutesManifest)) {
      inversedAppPathManifest[appPathRoutesManifest[ogRoute]] = ogRoute;
    }
  }
  let appRscPrefetches = {};
  let appBuildTraces = {};
  let appDir = null;
  if (appPathRoutesManifest) {
    appDir = import_path4.default.join(pagesDir, "../app");
    appBuildTraces = await (0, import_build_utils2.glob)("**/*.js.nft.json", appDir);
    appRscPrefetches = isAppPPREnabled ? {} : await (0, import_build_utils2.glob)(`**/*${RSC_PREFETCH_SUFFIX}`, appDir);
    const rscContentTypeHeader = routesManifest?.rsc?.contentTypeHeader || RSC_CONTENT_TYPE;
    appRscPrefetches = normalizePrefetches(appRscPrefetches);
    for (const value of Object.values(appRscPrefetches)) {
      if (!value.contentType) {
        value.contentType = rscContentTypeHeader;
      }
    }
    for (const rewrite of afterFilesRewrites) {
      if (rewrite.src && rewrite.dest) {
        const rscSuffix = isAppPPREnabled ? `(\\.prefetch)?\\.rsc` : "\\.rsc";
        rewrite.src = rewrite.src.replace(
          /\/?\(\?:\/\)\?/,
          `(?<rscsuff>${rscSuffix})?(?:/)?`
        );
        let destQueryIndex = rewrite.dest.indexOf("?");
        if (destQueryIndex === -1) {
          destQueryIndex = rewrite.dest.length;
        }
        rewrite.dest = rewrite.dest.substring(0, destQueryIndex) + "$rscsuff" + rewrite.dest.substring(destQueryIndex);
      }
    }
  }
  const isCorrectNotFoundRoutes = import_semver3.default.gte(
    nextVersion,
    CORRECT_NOT_FOUND_ROUTES_VERSION
  );
  const isCorrectMiddlewareOrder = import_semver3.default.gte(
    nextVersion,
    CORRECT_MIDDLEWARE_ORDER_VERSION
  );
  const isCorrectManifests = !experimentalAllowBundling && import_semver3.default.gte(nextVersion, CORRECTED_MANIFESTS_VERSION);
  let hasStatic500 = !!staticPages[import_path4.default.posix.join(entryDirectory, "500")];
  if (lambdaPageKeys.length === 0) {
    throw new import_build_utils2.NowBuildError({
      code: "NEXT_NO_SERVER_PAGES",
      message: "No server pages were built",
      link: "https://err.sh/vercel/vercel/now-next-no-serverless-pages-built"
    });
  }
  const pageMatchesApi = (page) => {
    const normalizedPage = `/${page.replace(/\.js$/, "")}`;
    return !inversedAppPathManifest[normalizedPage] && (page.startsWith("api/") || page === "api.js");
  };
  const { i18n } = routesManifest;
  const hasPages404 = routesManifest.pages404;
  let static404Page = staticPages[import_path4.default.posix.join(entryDirectory, "404")] && hasPages404 ? import_path4.default.posix.join(entryDirectory, "404") : staticPages[import_path4.default.posix.join(entryDirectory, "_errors/404")] ? import_path4.default.posix.join(entryDirectory, "_errors/404") : void 0;
  if (!static404Page && i18n && staticPages[import_path4.default.posix.join(entryDirectory, i18n.defaultLocale, "404")]) {
    static404Page = import_path4.default.posix.join(entryDirectory, i18n.defaultLocale, "404");
  }
  if (!hasStatic500 && i18n) {
    hasStatic500 = !!staticPages[import_path4.default.posix.join(entryDirectory, i18n.defaultLocale, "500")];
  }
  const lstatSema = new import_async_sema2.Sema(25);
  const lstatResults = {};
  const nonLambdaSsgPages = /* @__PURE__ */ new Set();
  Object.keys(prerenderManifest.staticRoutes).forEach((route) => {
    const result = onPrerenderRouteInitial(
      prerenderManifest,
      canUsePreviewMode,
      entryDirectory,
      nonLambdaSsgPages,
      route,
      routesManifest.pages404,
      routesManifest,
      appDir
    );
    if (result && result.static404Page) {
      static404Page = result.static404Page;
    }
    if (result && result.static500Page) {
      hasStatic500 = true;
    }
  });
  const hasLambdas = !static404Page || lambdaPageKeys.some(
    (page) => !internalPages.includes(page) && !nonLambdaSsgPages.has("/" + page.replace(/\.js$/, ""))
  );
  if (lambdaPages["404.js"]) {
    internalPages.push("404.js");
  }
  const prerenderRoutes = /* @__PURE__ */ new Set([
    ...canUsePreviewMode ? omittedPrerenderRoutes : [],
    ...Object.keys(prerenderManifest.blockingFallbackRoutes),
    ...Object.keys(prerenderManifest.fallbackRoutes),
    ...Object.keys(prerenderManifest.staticRoutes).map((route) => {
      const staticRoute = prerenderManifest.staticRoutes[route];
      return staticRoute.srcRoute || route;
    })
  ]);
  const experimentalStreamingLambdaPaths = /* @__PURE__ */ new Map();
  if (hasLambdas) {
    const initialTracingLabel = "Traced Next.js server files in";
    console.time(initialTracingLabel);
    const initialTracedFiles = {};
    let initialFileList;
    let initialFileReasons;
    let nextServerBuildTrace;
    let instrumentationHookBuildTrace;
    const useBundledServer = import_semver3.default.gte(nextVersion, BUNDLED_SERVER_NEXT_VERSION) && process.env.VERCEL_NEXT_BUNDLED_SERVER === "1";
    if (useBundledServer) {
      (0, import_build_utils2.debug)("Using bundled Next.js server");
    }
    const nextServerFile = (0, import_resolve_from.default)(
      projectDir,
      useBundledServer ? BUNDLED_SERVER_NEXT_PATH : `${getNextServerPath(nextVersion)}/next-server.js`
    );
    try {
      nextServerBuildTrace = JSON.parse(
        await import_fs_extra5.default.readFile(
          import_path4.default.join(
            entryPath,
            outputDirectory,
            useBundledServer ? "next-minimal-server.js.nft.json" : "next-server.js.nft.json"
          ),
          "utf8"
        )
      );
    } catch (_) {
    }
    try {
      instrumentationHookBuildTrace = JSON.parse(
        await import_fs_extra5.default.readFile(
          import_path4.default.join(
            entryPath,
            outputDirectory,
            "server",
            "instrumentation.js.nft.json"
          ),
          "utf8"
        )
      );
    } catch (_) {
    }
    if (nextServerBuildTrace) {
      initialFileList = nextServerBuildTrace.files.map((file) => {
        return import_path4.default.relative(
          baseDir,
          import_path4.default.join(entryPath, outputDirectory, file)
        );
      });
      initialFileReasons = /* @__PURE__ */ new Map();
      (0, import_build_utils2.debug)("Using next-server.js.nft.json trace from build");
    } else {
      const serverTraceLabel = `Tracing initial Next.js server files due to missing build trace`;
      console.time(serverTraceLabel);
      const result = await (0, import_nft.nodeFileTrace)([nextServerFile], {
        base: baseDir,
        cache: {},
        processCwd: entryPath,
        ignore: [
          ...requiredServerFilesManifest.ignore.map(
            (file) => import_path4.default.join(entryPath, file)
          ),
          "node_modules/next/dist/pages/**/*",
          `node_modules/${getNextServerPath(
            nextVersion
          )}/lib/squoosh/**/*.wasm`,
          "node_modules/next/dist/compiled/webpack/(bundle4|bundle5).js",
          "node_modules/react/**/*.development.js",
          "node_modules/react-dom/**/*.development.js",
          "node_modules/use-subscription/**/*.development.js",
          "node_modules/sharp/**/*"
        ]
      });
      initialFileList = Array.from(result.fileList);
      initialFileReasons = result.reasons;
      console.timeEnd(serverTraceLabel);
    }
    if (instrumentationHookBuildTrace) {
      initialFileList = initialFileList.concat(
        instrumentationHookBuildTrace.files.map((file) => {
          return import_path4.default.relative(
            baseDir,
            import_path4.default.join(entryPath, outputDirectory, "server", file)
          );
        })
      );
      (0, import_build_utils2.debug)("Using instrumentation.js.nft.json trace from build");
    }
    (0, import_build_utils2.debug)("collecting initial Next.js server files");
    await Promise.all(
      initialFileList.map(
        collectTracedFiles(
          baseDir,
          lstatResults,
          lstatSema,
          initialFileReasons,
          initialTracedFiles
        )
      )
    );
    (0, import_build_utils2.debug)("creating initial pseudo layer");
    const initialPseudoLayer = await createPseudoLayer(initialTracedFiles);
    console.timeEnd(initialTracingLabel);
    const lambdaCreationLabel = "Created all serverless functions in";
    console.time(lambdaCreationLabel);
    const apiPages = [];
    const nonApiPages = [];
    const appRouterPages = [];
    const appRouteHandlers = [];
    lambdaPageKeys.forEach((page) => {
      if (internalPages.includes(page) && page !== "404.js" && !(page === "_error.js" && !(static404Page || lambdaPages["404.js"]))) {
        return;
      }
      const pathname = page.replace(/\.js$/, "");
      if (nonLambdaSsgPages.has(pathname)) {
        return;
      }
      const normalizedPathname = normalizePage(pathname);
      if (isDynamicRoute(normalizedPathname)) {
        dynamicPages.push(normalizedPathname);
      }
      if (lambdaAppPaths[page]) {
        if (lambdaAppPaths[page].fsPath.endsWith("route.js")) {
          appRouteHandlers.push(page);
        } else {
          appRouterPages.push(page);
        }
      } else if (pageMatchesApi(page)) {
        apiPages.push(page);
      } else {
        nonApiPages.push(page);
      }
    });
    const requiredFiles = {};
    requiredFiles[import_path4.default.relative(baseDir, nextServerFile)] = new import_build_utils2.FileFsRef({
      mode: (await import_fs_extra5.default.lstat(nextServerFile)).mode,
      fsPath: nextServerFile
    });
    if (static404Page) {
      if (i18n) {
        for (const locale of i18n.locales) {
          let static404File = staticPages[import_path4.default.posix.join(entryDirectory, locale, "/404")];
          if (!static404File) {
            static404File = new import_build_utils2.FileFsRef({
              fsPath: import_path4.default.join(pagesDir, locale, "/404.html")
            });
            if (!import_fs_extra5.default.existsSync(static404File.fsPath)) {
              static404File = new import_build_utils2.FileFsRef({
                fsPath: import_path4.default.join(pagesDir, "/404.html")
              });
            }
          }
          requiredFiles[import_path4.default.relative(baseDir, static404File.fsPath)] = static404File;
        }
      } else {
        const static404File = staticPages[static404Page] || new import_build_utils2.FileFsRef({
          fsPath: import_path4.default.join(pagesDir, "/404.html")
        });
        requiredFiles[import_path4.default.relative(baseDir, static404File.fsPath)] = static404File;
      }
    }
    const envFiles = [];
    for (const file of await import_fs_extra5.default.readdir(workPath)) {
      const isEnv = file === ".env" || file.startsWith(".env.");
      if (isEnv) {
        const statResult = await import_fs_extra5.default.lstat(import_path4.default.join(workPath, file));
        if (statResult.isFile()) {
          envFiles.push(file);
        }
      }
    }
    for (const envFile of envFiles) {
      requiredFiles[import_path4.default.join(import_path4.default.relative(baseDir, entryPath), envFile)] = new import_build_utils2.FileFsRef({
        fsPath: import_path4.default.join(workPath, envFile)
      });
    }
    await Promise.all(
      requiredServerFilesManifest.files.map(async (file) => {
        await lstatSema.acquire();
        let fsPath = import_path4.default.join(
          entryPath,
          // remove last part of outputDirectory `.next` since this is already
          // included in the file path
          import_path4.default.join(outputDirectory, ".."),
          file
        );
        if (projectDir) {
          fsPath = import_path4.default.join(projectDir, file);
        }
        const relativePath = import_path4.default.relative(baseDir, fsPath);
        const { mode } = await import_fs_extra5.default.lstat(fsPath);
        lstatSema.release();
        requiredFiles[relativePath] = new import_build_utils2.FileFsRef({
          mode,
          fsPath
        });
      })
    );
    const requiredFilesLayer = await createPseudoLayer(requiredFiles);
    Object.assign(
      initialPseudoLayer.pseudoLayer,
      requiredFilesLayer.pseudoLayer
    );
    initialPseudoLayer.pseudoLayerBytes += requiredFilesLayer.pseudoLayerBytes;
    const uncompressedInitialSize = Object.keys(
      initialPseudoLayer.pseudoLayer
    ).reduce((prev, cur) => {
      const file = initialPseudoLayer.pseudoLayer[cur];
      return prev + file.uncompressedSize || 0;
    }, 0);
    (0, import_build_utils2.debug)(
      JSON.stringify(
        {
          uncompressedInitialSize,
          compressedInitialSize: initialPseudoLayer.pseudoLayerBytes
        },
        null,
        2
      )
    );
    if (uncompressedInitialSize > MAX_UNCOMPRESSED_LAMBDA_SIZE) {
      console.log(
        `Warning: Max serverless function size of ${(0, import_pretty_bytes3.default)(
          MAX_UNCOMPRESSED_LAMBDA_SIZE
        )} uncompressed reached`
      );
      outputFunctionFileSizeInfo(
        [],
        initialPseudoLayer.pseudoLayer,
        uncompressedInitialSize,
        {}
      );
      throw new import_build_utils2.NowBuildError({
        message: `Required files read using Node.js fs library and node_modules exceed max lambda size of ${MAX_UNCOMPRESSED_LAMBDA_SIZE} bytes`,
        code: "NEXT_REQUIRED_FILES_LIMIT",
        link: "https://vercel.com/docs/platform/limits#serverless-function-size"
      });
    }
    const launcherData = await import_fs_extra5.default.readFile(
      import_path4.default.join(__dirname, "server-launcher.js"),
      "utf8"
    );
    let launcher = launcherData.replace(
      "const conf = __NEXT_CONFIG__",
      `const conf = ${JSON.stringify({
        ...requiredServerFilesManifest.config,
        distDir: import_path4.default.relative(
          projectDir,
          import_path4.default.join(entryPath, outputDirectory)
        ),
        compress: false
      })}`
    ).replace(
      "__NEXT_SERVER_PATH__",
      useBundledServer ? BUNDLED_SERVER_NEXT_PATH : `${getNextServerPath(nextVersion)}/next-server.js`
    );
    const appLauncher = launcher.replace(
      "// @preserve pre-next-server-target",
      `process.env.__NEXT_PRIVATE_PREBUNDLED_REACT = "${requiredServerFilesManifest.config?.experimental?.serverActions ? "experimental" : "next"}"`
    );
    if (entryDirectory !== "." && import_path4.default.posix.join("/", entryDirectory) !== routesManifest.basePath) {
      launcher = launcher.replace(
        "// @preserve entryDirectory handler",
        `req.url = req.url.replace(/^${import_path4.default.posix.join("/", entryDirectory).replace(/\//g, "\\/")}/, '')`
      );
    }
    const pageTraces = {};
    const compressedPages = {};
    const mergedPageKeys = [
      ...nonApiPages,
      ...appRouterPages,
      ...appRouteHandlers,
      ...apiPages,
      ...internalPages
    ];
    const traceCache = {};
    const getOriginalPagePath = (page) => {
      let originalPagePath = page;
      if (appDir && lambdaAppPaths[page]) {
        const { fsPath } = lambdaAppPaths[page];
        originalPagePath = import_path4.default.relative(appDir, fsPath);
      }
      return originalPagePath;
    };
    const getBuildTraceFile = (page) => {
      return pageBuildTraces[page + ".nft.json"] || appBuildTraces[page + ".nft.json"];
    };
    const pathsToTrace = mergedPageKeys.map((page) => {
      const originalPagePath = getOriginalPagePath(page);
      if (!getBuildTraceFile(originalPagePath)) {
        return lambdaPages[page].fsPath;
      }
    }).filter(Boolean);
    let traceResult;
    let parentFilesMap;
    if (pathsToTrace.length > 0) {
      const traceLabel = `Tracing entries due to missing build traces:
${JSON.stringify(
        pathsToTrace,
        null,
        2
      )}`;
      console.time(traceLabel);
      traceResult = await (0, import_nft.nodeFileTrace)(pathsToTrace, {
        base: baseDir,
        cache: traceCache,
        processCwd: projectDir
      });
      traceResult.esmFileList.forEach((file) => traceResult?.fileList.add(file));
      parentFilesMap = getFilesMapFromReasons(
        traceResult.fileList,
        traceResult.reasons
      );
      console.timeEnd(traceLabel);
    }
    for (const page of mergedPageKeys) {
      const tracedFiles = {};
      const originalPagePath = getOriginalPagePath(page);
      const pageBuildTrace = getBuildTraceFile(originalPagePath);
      let fileList;
      let reasons;
      if (pageBuildTrace) {
        const { files } = JSON.parse(
          await import_fs_extra5.default.readFile(pageBuildTrace.fsPath, "utf8")
        );
        const isAppPath = appDir && lambdaAppPaths[page];
        const serverComponentFile = isAppPath ? pageBuildTrace.fsPath.replace(
          /\.js\.nft\.json$/,
          ".__sc_client__.js"
        ) : null;
        if (serverComponentFile && await import_fs_extra5.default.pathExists(serverComponentFile)) {
          files.push(
            import_path4.default.relative(
              import_path4.default.dirname(pageBuildTrace.fsPath),
              serverComponentFile
            )
          );
          try {
            const scTrace = JSON.parse(
              await import_fs_extra5.default.readFile(`${serverComponentFile}.nft.json`, "utf8")
            );
            scTrace.files.forEach((file) => files.push(file));
          } catch (err) {
          }
        }
        fileList = [];
        const curPagesDir = isAppPath && appDir ? appDir : pagesDir;
        const pageDir = import_path4.default.dirname(import_path4.default.join(curPagesDir, originalPagePath));
        const normalizedBaseDir = `${baseDir}${baseDir.endsWith(import_path4.default.sep) ? "" : import_path4.default.sep}`;
        files.forEach((file) => {
          const absolutePath = import_path4.default.join(pageDir, file);
          if (absolutePath.startsWith(normalizedBaseDir)) {
            fileList.push(import_path4.default.relative(baseDir, absolutePath));
          }
        });
        reasons = /* @__PURE__ */ new Map();
      } else {
        fileList = Array.from(
          parentFilesMap?.get(
            import_path4.default.relative(baseDir, lambdaPages[page].fsPath)
          ) || []
        );
        if (!fileList) {
          throw new Error(
            `Invariant: Failed to trace ${page}, missing fileList`
          );
        }
        reasons = traceResult?.reasons || /* @__PURE__ */ new Map();
      }
      await Promise.all(
        fileList.map(
          collectTracedFiles(
            baseDir,
            lstatResults,
            lstatSema,
            reasons,
            tracedFiles
          )
        )
      );
      pageTraces[page] = tracedFiles;
      compressedPages[page] = (await createPseudoLayer({
        [page]: lambdaPages[page]
      })).pseudoLayer[page];
    }
    const tracedPseudoLayer = await createPseudoLayer(
      mergedPageKeys.reduce((prev, page) => {
        Object.assign(prev, pageTraces[page]);
        return prev;
      }, {})
    );
    const pageExtensions = requiredServerFilesManifest.config?.pageExtensions;
    const pageLambdaGroups = await getPageLambdaGroups({
      experimentalAllowBundling,
      entryPath: projectDir,
      config,
      functionsConfigManifest,
      pages: nonApiPages,
      prerenderRoutes,
      pageTraces,
      compressedPages,
      experimentalPPRRoutes: void 0,
      tracedPseudoLayer: tracedPseudoLayer.pseudoLayer,
      initialPseudoLayer,
      initialPseudoLayerUncompressed: uncompressedInitialSize,
      internalPages,
      pageExtensions
    });
    for (const group of pageLambdaGroups) {
      group.isPages = true;
    }
    const appRouterLambdaGroups = await getPageLambdaGroups({
      experimentalAllowBundling,
      entryPath: projectDir,
      config,
      functionsConfigManifest,
      pages: appRouterPages,
      prerenderRoutes,
      pageTraces,
      compressedPages,
      experimentalPPRRoutes,
      tracedPseudoLayer: tracedPseudoLayer.pseudoLayer,
      initialPseudoLayer,
      initialPseudoLayerUncompressed: uncompressedInitialSize,
      internalPages,
      pageExtensions,
      inversedAppPathManifest
    });
    const appRouteHandlersLambdaGroups = await getPageLambdaGroups({
      experimentalAllowBundling,
      entryPath: projectDir,
      config,
      functionsConfigManifest,
      pages: appRouteHandlers,
      prerenderRoutes,
      pageTraces,
      compressedPages,
      experimentalPPRRoutes: void 0,
      tracedPseudoLayer: tracedPseudoLayer.pseudoLayer,
      initialPseudoLayer,
      initialPseudoLayerUncompressed: uncompressedInitialSize,
      internalPages,
      pageExtensions,
      inversedAppPathManifest,
      isRouteHandlers: true
    });
    const appRouterStreamingActionLambdaGroups = [];
    for (const group of appRouterLambdaGroups) {
      group.isStreaming = true;
      group.isAppRouter = true;
    }
    for (const group of appRouteHandlersLambdaGroups) {
      if (!group.isPrerenders) {
        group.isStreaming = true;
      }
      group.isAppRouter = true;
      group.isAppRouteHandler = true;
    }
    const apiLambdaGroups = await getPageLambdaGroups({
      entryPath: projectDir,
      config,
      functionsConfigManifest,
      pages: apiPages,
      prerenderRoutes,
      pageTraces,
      compressedPages,
      experimentalPPRRoutes: void 0,
      tracedPseudoLayer: tracedPseudoLayer.pseudoLayer,
      initialPseudoLayer,
      initialPseudoLayerUncompressed: uncompressedInitialSize,
      internalPages,
      pageExtensions
    });
    for (const group of apiLambdaGroups) {
      group.isApiLambda = true;
    }
    (0, import_build_utils2.debug)(
      JSON.stringify(
        {
          apiLambdaGroups: apiLambdaGroups.map((group) => ({
            pages: group.pages,
            isPrerender: group.isPrerenders,
            isStreaming: group.isStreaming,
            isExperimentalPPR: group.isExperimentalPPR,
            pseudoLayerBytes: group.pseudoLayerBytes,
            uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
          })),
          pageLambdaGroups: pageLambdaGroups.map((group) => ({
            pages: group.pages,
            isPrerender: group.isPrerenders,
            isStreaming: group.isStreaming,
            isExperimentalPPR: group.isExperimentalPPR,
            pseudoLayerBytes: group.pseudoLayerBytes,
            uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
          })),
          appRouterLambdaGroups: appRouterLambdaGroups.map((group) => ({
            pages: group.pages,
            isPrerender: group.isPrerenders,
            isStreaming: group.isStreaming,
            isExperimentalPPR: group.isExperimentalPPR,
            pseudoLayerBytes: group.pseudoLayerBytes,
            uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
          })),
          appRouterStreamingPrerenderLambdaGroups: appRouterStreamingActionLambdaGroups.map((group) => ({
            pages: group.pages,
            isPrerender: group.isPrerenders,
            isStreaming: group.isStreaming,
            isExperimentalPPR: group.isExperimentalPPR,
            pseudoLayerBytes: group.pseudoLayerBytes,
            uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
          })),
          appRouteHandlersLambdaGroups: appRouteHandlersLambdaGroups.map(
            (group) => ({
              pages: group.pages,
              isPrerender: group.isPrerenders,
              isStreaming: group.isStreaming,
              isExperimentalPPR: group.isExperimentalPPR,
              pseudoLayerBytes: group.pseudoLayerBytes,
              uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
            })
          ),
          nextServerLayerSize: initialPseudoLayer.pseudoLayerBytes
        },
        null,
        2
      )
    );
    const combinedGroups = [
      ...pageLambdaGroups,
      ...appRouterLambdaGroups,
      ...appRouterStreamingActionLambdaGroups,
      ...apiLambdaGroups,
      ...appRouteHandlersLambdaGroups
    ];
    await detectLambdaLimitExceeding(combinedGroups, compressedPages);
    const appNotFoundTraces = pageTraces["_not-found.js"];
    const appNotFoundPsuedoLayer = appNotFoundTraces && await createPseudoLayer(appNotFoundTraces);
    for (const group of combinedGroups) {
      const groupPageFiles = {};
      for (const page of [
        ...group.pages,
        ...internalPages,
        ...group.isAppRouter && appNotFoundTraces ? ["_not-found.js"] : []
      ]) {
        const pageFileName = import_path4.default.normalize(
          import_path4.default.relative(baseDir, lambdaPages[page].fsPath)
        );
        groupPageFiles[pageFileName] = compressedPages[page];
      }
      const updatedManifestFiles = {};
      if (isCorrectManifests) {
        for (const manifest of [
          "routes-manifest.json",
          "server/pages-manifest.json"
        ]) {
          const fsPath = import_path4.default.join(entryPath, outputDirectory, manifest);
          const relativePath = import_path4.default.relative(baseDir, fsPath);
          delete group.pseudoLayer[relativePath];
          const manifestData = await import_fs_extra5.default.readJSON(fsPath);
          const normalizedPages = new Set(
            group.pages.map((page) => {
              page = `/${page.replace(/\.js$/, "")}`;
              if (page === "/index")
                page = "/";
              return page;
            })
          );
          switch (manifest) {
            case "routes-manifest.json": {
              const filterItem = (item) => normalizedPages.has(item.page);
              manifestData.dynamicRoutes = manifestData.dynamicRoutes?.filter(filterItem);
              manifestData.staticRoutes = manifestData.staticRoutes?.filter(filterItem);
              break;
            }
            case "server/pages-manifest.json": {
              for (const key of Object.keys(manifestData)) {
                if (isDynamicRoute(key) && !normalizedPages.has(key)) {
                  delete manifestData[key];
                }
              }
              break;
            }
            default: {
              throw new import_build_utils2.NowBuildError({
                message: `Unexpected manifest value ${manifest}, please contact support if this continues`,
                code: "NEXT_MANIFEST_INVARIANT"
              });
            }
          }
          updatedManifestFiles[relativePath] = new import_build_utils2.FileBlob({
            contentType: "application/json",
            data: JSON.stringify(manifestData)
          });
        }
      }
      let launcherData2 = group.isAppRouter ? appLauncher : launcher;
      let preloadChunks = [];
      if (process.env.VERCEL_NEXT_PRELOAD_COMMON === "1") {
        const nextPackageDir = import_path4.default.dirname(
          (0, import_resolve_from.default)(projectDir, "next/package.json")
        );
        if (group.isPages) {
          preloadChunks = PRELOAD_CHUNKS.PAGES_ROUTER_PAGES;
        } else if (group.isApiLambda) {
          preloadChunks = PRELOAD_CHUNKS.PAGES_ROUTER_API;
        } else if (group.isAppRouter && !group.isAppRouteHandler) {
          preloadChunks = PRELOAD_CHUNKS.APP_ROUTER_PAGES;
        } else if (group.isAppRouteHandler) {
          preloadChunks = PRELOAD_CHUNKS.APP_ROUTER_HANDLER;
        }
        const normalizedPreloadChunks = [];
        for (const preloadChunk of preloadChunks) {
          const absoluteChunk = preloadChunk.startsWith(".next") ? import_path4.default.join(projectDir, preloadChunk) : import_path4.default.join(nextPackageDir, "..", preloadChunk);
          if (group.pseudoLayer[import_path4.default.join(".", import_path4.default.relative(baseDir, absoluteChunk))]) {
            normalizedPreloadChunks.push(
              // relative files need to be prefixed with ./ for require
              preloadChunk.startsWith(".next") ? `./${preloadChunk}` : preloadChunk
            );
          }
        }
        if (normalizedPreloadChunks.length > 0) {
          launcherData2 = launcherData2.replace(
            "// @preserve next-server-preload-target",
            normalizedPreloadChunks.map((name) => `require('${name}');`).join("\n")
          );
        }
      }
      const launcherFiles = {
        [import_path4.default.join(import_path4.default.relative(baseDir, projectDir), "___next_launcher.cjs")]: new import_build_utils2.FileBlob({ data: launcherData2 })
      };
      const operationType = getOperationType({ group, prerenderManifest });
      const options = {
        files: {
          ...launcherFiles,
          ...updatedManifestFiles
        },
        layers: [group.pseudoLayer, groupPageFiles],
        handler: import_path4.default.join(
          import_path4.default.relative(baseDir, projectDir),
          "___next_launcher.cjs"
        ),
        operationType,
        memory: group.memory,
        runtime: nodeVersion.runtime,
        maxDuration: group.maxDuration,
        isStreaming: group.isStreaming,
        nextVersion,
        experimentalAllowBundling
      };
      if (group.isAppRouter && appNotFoundPsuedoLayer) {
        options.layers.push(appNotFoundPsuedoLayer.pseudoLayer);
      }
      const lambda = await createLambdaFromPseudoLayers(options);
      for (const pageFilename of group.pages) {
        const pageName = pageFilename.replace(/\.js$/, "");
        const pagePathname = normalizePage(pageName);
        let isPrerender = prerenderRoutes.has(pagePathname);
        const isRoutePPREnabled = experimentalPPRRoutes.has(pagePathname);
        if (!isPrerender && routesManifest?.i18n) {
          isPrerender = routesManifest.i18n.locales.some((locale) => {
            return prerenderRoutes.has(
              import_path4.default.join("/", locale, pageName === "index" ? "" : pageName)
            );
          });
        }
        let outputName = import_path4.default.posix.join(entryDirectory, pageName);
        if (group.isActionLambda) {
          outputName = `${outputName}.action`;
        }
        if (isRoutePPREnabled) {
          if (!options.isStreaming) {
            throw new Error("Invariant: PPR lambda isn't streaming");
          }
          lambdas[outputName] = lambda;
          if (!omittedPrerenderRoutes.has(pagePathname)) {
            const output = getPostponeResumeOutput(entryDirectory, pageName);
            lambdas[output] = lambda;
            experimentalStreamingLambdaPaths.set(outputName, {
              pathname: getPostponeResumePathname(pageName),
              output
            });
          }
          for (const [
            routePathname,
            { srcRoute, renderingMode }
          ] of Object.entries(prerenderManifest.staticRoutes)) {
            if (srcRoute !== pagePathname || renderingMode !== "PARTIALLY_STATIC" /* PARTIALLY_STATIC */)
              continue;
            if (routePathname === pagePathname)
              continue;
            const output = getPostponeResumePathname(routePathname);
            lambdas[output] = lambda;
            outputName = import_path4.default.posix.join(entryDirectory, routePathname);
            experimentalStreamingLambdaPaths.set(outputName, {
              pathname: getPostponeResumePathname(routePathname),
              output
            });
          }
          continue;
        }
        if (!group.isAppRouter && !group.isAppRouteHandler) {
          outputName = normalizeIndexOutput(outputName, true);
        }
        if (i18n && !isPrerender && !group.isAppRouter && (!isCorrectLocaleAPIRoutes || !(pageName === "api" || pageName.startsWith("api/")))) {
          for (const locale of i18n.locales) {
            lambdas[normalizeIndexOutput(
              import_path4.default.posix.join(
                entryDirectory,
                locale,
                pageName === "index" ? "" : pageName
              ),
              true
            )] = lambda;
          }
        } else {
          lambdas[outputName] = lambda;
        }
      }
    }
    console.timeEnd(lambdaCreationLabel);
  }
  if (isAppPPREnabled) {
    (0, import_build_utils2.debug)(
      "experimentalStreamingLambdaPaths",
      JSON.stringify(Array.from(experimentalStreamingLambdaPaths))
    );
  }
  const prerenderRoute = onPrerenderRoute({
    appDir,
    pagesDir,
    pageLambdaMap: {},
    lambdas,
    experimentalStreamingLambdaPaths,
    prerenders,
    entryDirectory,
    routesManifest,
    prerenderManifest,
    appPathRoutesManifest,
    isServerMode: true,
    isSharedLambdas: false,
    canUsePreviewMode,
    static404Page,
    localePrefixed404,
    hasPages404: routesManifest.pages404,
    isCorrectNotFoundRoutes,
    isEmptyAllowQueryForPrendered,
    isAppPPREnabled
  });
  await Promise.all(
    Object.keys(prerenderManifest.staticRoutes).map(
      (route) => prerenderRoute(route, {})
    )
  );
  await Promise.all(
    Object.keys(prerenderManifest.fallbackRoutes).map(
      (route) => prerenderRoute(route, { isFallback: true })
    )
  );
  await Promise.all(
    Object.keys(prerenderManifest.blockingFallbackRoutes).map(
      (route) => prerenderRoute(route, { isBlocking: true })
    )
  );
  if (static404Page && canUsePreviewMode) {
    await Promise.all(
      Array.from(omittedPrerenderRoutes).map(
        (route) => prerenderRoute(route, { isOmitted: true })
      )
    );
  }
  prerenderRoutes.forEach((route) => {
    if (experimentalPPRRoutes.has(route))
      return;
    if (routesManifest?.i18n) {
      route = normalizeLocalePath(route, routesManifest.i18n.locales).pathname;
    }
    if (
      // we can't delete dynamic app route lambdas just because
      // they are in the prerender manifest since a dynamic
      // route can have some prerendered paths and the rest SSR
      inversedAppPathManifest[route] && isDynamicRoute(route)
    ) {
      return;
    }
    delete lambdas[normalizeIndexOutput(
      import_path4.default.posix.join("./", entryDirectory, route === "/" ? "/index" : route),
      true
    )];
  });
  const middleware = await getMiddlewareBundle({
    config,
    entryPath,
    outputDirectory,
    routesManifest,
    isCorrectMiddlewareOrder,
    prerenderBypassToken: prerenderManifest.bypassToken || "",
    nextVersion,
    appPathRoutesManifest: appPathRoutesManifest || {}
  });
  const isNextDataServerResolving = middleware.staticRoutes.length > 0 && import_semver3.default.gte(nextVersion, NEXT_DATA_MIDDLEWARE_RESOLVING_VERSION);
  const dynamicRoutes = await getDynamicRoutes({
    entryPath,
    entryDirectory,
    dynamicPages,
    isDev: false,
    routesManifest,
    omittedRoutes: omittedPrerenderRoutes,
    canUsePreviewMode,
    bypassToken: prerenderManifest.bypassToken || "",
    isServerMode: true,
    dynamicMiddlewareRouteMap: middleware.dynamicRouteMap,
    isAppPPREnabled
  }).then(
    (arr) => localizeDynamicRoutes(
      arr,
      dynamicPrefix,
      entryDirectory,
      staticPages,
      prerenderManifest,
      routesManifest,
      true,
      isCorrectLocaleAPIRoutes,
      inversedAppPathManifest
    )
  );
  const pagesPlaceholderRscEntries = {};
  if (appDir) {
    const pagesManifest = import_path4.default.join(
      entryPath,
      outputDirectory,
      `server/pages-manifest.json`
    );
    const pagesData = await import_fs_extra5.default.readJSON(pagesManifest);
    const pagesEntries = Object.keys(pagesData);
    for (const page of pagesEntries) {
      const pathName = page.startsWith("/") ? page.slice(1) : page;
      pagesPlaceholderRscEntries[`${pathName}.rsc`] = new import_build_utils2.FileBlob({
        data: "{}",
        contentType: "application/json"
      });
    }
  }
  const { staticFiles, publicDirectoryFiles, staticDirectoryFiles } = await getStaticFiles(entryPath, entryDirectory, outputDirectory);
  const normalizeNextDataRoute = (isOverride = false) => {
    return isNextDataServerResolving ? [
      // strip _next/data prefix for resolving
      {
        src: `^${import_path4.default.posix.join(
          "/",
          entryDirectory,
          "/_next/data/",
          escapedBuildId,
          "/(.*).json"
        )}`,
        dest: `${import_path4.default.posix.join(
          "/",
          entryDirectory,
          "/$1",
          trailingSlash ? "/" : ""
        )}`,
        ...isOverride ? { override: true } : {},
        continue: true,
        has: [
          {
            type: "header",
            key: "x-nextjs-data"
          }
        ]
      },
      // normalize "/index" from "/_next/data/index.json" to -> just "/"
      // as matches a rewrite sources will expect just "/"
      {
        src: import_path4.default.posix.join("^/", entryDirectory, "/index(?:/)?"),
        has: [
          {
            type: "header",
            key: "x-nextjs-data"
          }
        ],
        dest: import_path4.default.posix.join(
          "/",
          entryDirectory,
          trailingSlash ? "/" : ""
        ),
        ...isOverride ? { override: true } : {},
        continue: true
      }
    ] : [];
  };
  const denormalizeNextDataRoute = (isOverride = false) => {
    return isNextDataServerResolving ? [
      {
        src: import_path4.default.posix.join(
          "^/",
          entryDirectory !== "." ? `${entryDirectory}${trailingSlash ? "/$" : "$"}` : "$"
        ),
        has: [
          {
            type: "header",
            key: "x-nextjs-data"
          }
        ],
        dest: `${import_path4.default.posix.join(
          "/",
          entryDirectory,
          "/_next/data/",
          buildId,
          "/index.json"
        )}`,
        continue: true,
        ...isOverride ? { override: true } : {}
      },
      {
        src: import_path4.default.posix.join(
          "^/",
          entryDirectory,
          "((?!_next/)(?:.*[^/]|.*))/?$"
        ),
        has: [
          {
            type: "header",
            key: "x-nextjs-data"
          }
        ],
        dest: `${import_path4.default.posix.join(
          "/",
          entryDirectory,
          "/_next/data/",
          buildId,
          "/$1.json"
        )}`,
        continue: true,
        ...isOverride ? { override: true } : {}
      }
    ] : [];
  };
  let nextDataCatchallOutput = void 0;
  if (isNextDataServerResolving) {
    const catchallFsPath = import_path4.default.join(
      entryPath,
      outputDirectory,
      "__next_data_catchall.json"
    );
    await import_fs_extra5.default.writeFile(catchallFsPath, "{}");
    nextDataCatchallOutput = new import_build_utils2.FileFsRef({
      contentType: "application/json",
      fsPath: catchallFsPath
    });
  }
  if (appPathRoutesManifest) {
    const edgeFunctions = middleware.edgeFunctions;
    for (const route of Object.values(appPathRoutesManifest)) {
      const pathname = import_path4.default.posix.join(
        "./",
        entryDirectory,
        route === "/" ? "/index" : route
      );
      if (lambdas[pathname]) {
        lambdas[`${pathname}.rsc`] = lambdas[pathname];
        if (isAppPPREnabled) {
          lambdas[`${pathname}${RSC_PREFETCH_SUFFIX}`] = lambdas[pathname];
        }
      }
      if (edgeFunctions[pathname]) {
        edgeFunctions[`${pathname}.rsc`] = edgeFunctions[pathname];
        if (isAppPPREnabled) {
          edgeFunctions[`${pathname}${RSC_PREFETCH_SUFFIX}`] = edgeFunctions[pathname];
        }
      }
    }
  }
  const rscHeader = routesManifest.rsc?.header?.toLowerCase() || "__rsc__";
  const rscPrefetchHeader = routesManifest.rsc?.prefetchHeader?.toLowerCase();
  const rscVaryHeader = routesManifest?.rsc?.varyHeader || "RSC, Next-Router-State-Tree, Next-Router-Prefetch";
  const appNotFoundPath = import_path4.default.posix.join(".", entryDirectory, "_not-found");
  if (isAppPPREnabled && !rscPrefetchHeader) {
    throw new Error("Invariant: cannot use PPR without 'rsc.prefetchHeader'");
  }
  if (isAppPPREnabled) {
    for (const { srcRoute, dataRoute, renderingMode } of Object.values(
      prerenderManifest.staticRoutes
    )) {
      if (renderingMode !== "PARTIALLY_STATIC" /* PARTIALLY_STATIC */ || !dataRoute || !srcRoute)
        continue;
      if (!omittedPrerenderRoutes.has(srcRoute))
        continue;
      const srcPathname = srcRoute.substring(1);
      const dataPathname = dataRoute.substring(1);
      const dataPathnameExists = dataPathname in lambdas;
      if (dataPathnameExists)
        continue;
      const srcPathnameExists = srcPathname in lambdas;
      if (!srcPathnameExists) {
        throw new Error(
          `Invariant: Expected to have a lambda for the source route: ${srcPathname}`
        );
      }
      lambdas[dataPathname] = lambdas[srcPathname];
    }
  }
  return {
    wildcard: wildcardConfig,
    images: getImagesConfig(imagesManifest),
    output: {
      ...publicDirectoryFiles,
      ...lambdas,
      ...appRscPrefetches,
      ...pagesPlaceholderRscEntries,
      // Prerenders may override Lambdas -- this is an intentional behavior.
      ...prerenders,
      ...staticPages,
      ...staticFiles,
      ...staticDirectoryFiles,
      ...privateOutputs.files,
      ...middleware.edgeFunctions,
      ...isNextDataServerResolving ? {
        __next_data_catchall: nextDataCatchallOutput
      } : {}
    },
    routes: [
      /*
        Desired routes order
        - Runtime headers
        - User headers and redirects
        - Runtime redirects
        - Runtime routes
        - Check filesystem, if nothing found continue
        - User rewrites
        - Builder rewrites
      */
      // force trailingSlashRedirect to the very top so it doesn't
      // conflict with i18n routes that don't have or don't have the
      // trailing slash
      ...trailingSlashRedirects,
      ...privateOutputs.routes,
      // normalize _next/data URL before processing redirects
      ...normalizeNextDataRoute(true),
      ...i18n ? [
        // Handle auto-adding current default locale to path based on
        // $wildcard
        // This is split into two rules to avoid matching the `/index` route as it causes issues with trailing slash redirect
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(?:/.*|$))$`,
          // we aren't able to ensure trailing slash mode here
          // so ensure this comes after the trailing slash redirect
          dest: `${entryDirectory !== "." ? import_path4.default.posix.join("/", entryDirectory) : ""}$wildcard${trailingSlash ? "/" : ""}`,
          continue: true
        },
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(?:/.*|$))(.*)$`,
          // we aren't able to ensure trailing slash mode here
          // so ensure this comes after the trailing slash redirect
          dest: `${entryDirectory !== "." ? import_path4.default.posix.join("/", entryDirectory) : ""}$wildcard/$1`,
          continue: true
        },
        // Handle redirecting to locale specific domains
        ...i18n.domains && i18n.domains.length > 0 && i18n.localeDetection !== false ? [
          {
            src: `^${import_path4.default.posix.join(
              "/",
              entryDirectory
            )}/?(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})?/?$`,
            locale: {
              redirect: i18n.domains.reduce(
                (prev, item) => {
                  prev[item.defaultLocale] = `http${item.http ? "" : "s"}://${item.domain}/`;
                  if (item.locales) {
                    item.locales.map((locale) => {
                      prev[locale] = `http${item.http ? "" : "s"}://${item.domain}/${locale}`;
                    });
                  }
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        // Handle redirecting to locale paths
        ...i18n.localeDetection !== false ? [
          {
            // TODO: if default locale is included in this src it won't
            // be visitable by users who prefer another language since a
            // cookie isn't set signaling the default locale is
            // preferred on redirect currently, investigate adding this
            src: "/",
            locale: {
              redirect: i18n.locales.reduce(
                (prev, locale) => {
                  prev[locale] = locale === i18n.defaultLocale ? `/` : `/${locale}`;
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        {
          src: `^${import_path4.default.posix.join("/", entryDirectory)}$`,
          dest: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            i18n.defaultLocale
          )}`,
          continue: true
        },
        // Auto-prefix non-locale path with default locale
        // note for prerendered pages this will cause
        // x-now-route-matches to contain the path minus the locale
        // e.g. for /de/posts/[slug] x-now-route-matches would have
        // 1=posts%2Fpost-1
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(?:/.*|$))(.*)$`,
          dest: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            i18n.defaultLocale
          )}/$1`,
          continue: true
        }
      ] : [],
      ...headers,
      ...redirects,
      // middleware comes directly after redirects but before
      // beforeFiles rewrites as middleware is not a "file" route
      ...routesManifest?.skipMiddlewareUrlNormalize ? denormalizeNextDataRoute(true) : [],
      ...isCorrectMiddlewareOrder ? middleware.staticRoutes : [],
      ...routesManifest?.skipMiddlewareUrlNormalize ? normalizeNextDataRoute(true) : [],
      ...beforeFilesRewrites,
      // Make sure to 404 for the /404 path itself
      ...i18n ? [
        {
          src: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})?[/]?404/?`,
          status: 404,
          continue: true,
          missing: [
            {
              type: "header",
              key: "x-prerender-revalidate"
            }
          ]
        }
      ] : [
        {
          src: import_path4.default.posix.join("/", entryDirectory, "404/?"),
          status: 404,
          continue: true,
          missing: [
            {
              type: "header",
              key: "x-prerender-revalidate"
            }
          ]
        }
      ],
      // Make sure to 500 when visiting /500 directly for static 500
      ...!hasStatic500 ? [] : i18n ? [
        {
          src: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})?[/]?500`,
          status: 500,
          continue: true
        }
      ] : [
        {
          src: import_path4.default.posix.join("/", entryDirectory, "500"),
          status: 500,
          continue: true
        }
      ],
      // we need to undo _next/data normalize before checking filesystem
      ...denormalizeNextDataRoute(true),
      // while middleware was in beta the order came right before
      // handle: 'filesystem' we maintain this for older versions
      // to prevent a local/deploy mismatch
      ...!isCorrectMiddlewareOrder ? middleware.staticRoutes : [],
      ...appDir ? [
        ...rscPrefetchHeader && isAppPPREnabled ? [
          {
            src: `^${import_path4.default.posix.join("/", entryDirectory, "/")}`,
            has: [
              {
                type: "header",
                key: rscPrefetchHeader
              }
            ],
            dest: import_path4.default.posix.join(
              "/",
              entryDirectory,
              `/__index${RSC_PREFETCH_SUFFIX}`
            ),
            headers: { vary: rscVaryHeader },
            continue: true,
            override: true
          },
          {
            src: `^${import_path4.default.posix.join(
              "/",
              entryDirectory,
              "/((?!.+\\.rsc).+?)(?:/)?$"
            )}`,
            has: [
              {
                type: "header",
                key: rscPrefetchHeader
              }
            ],
            dest: import_path4.default.posix.join(
              "/",
              entryDirectory,
              `/$1${RSC_PREFETCH_SUFFIX}`
            ),
            headers: { vary: rscVaryHeader },
            continue: true,
            override: true
          }
        ] : [],
        {
          src: `^${import_path4.default.posix.join("/", entryDirectory, "/?")}`,
          has: [
            {
              type: "header",
              key: rscHeader
            }
          ],
          dest: import_path4.default.posix.join("/", entryDirectory, "/index.rsc"),
          headers: { vary: rscVaryHeader },
          continue: true,
          override: true
        },
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/((?!.+\\.rsc).+?)(?:/)?$"
          )}`,
          has: [
            {
              type: "header",
              key: rscHeader
            }
          ],
          dest: import_path4.default.posix.join("/", entryDirectory, "/$1.rsc"),
          headers: { vary: rscVaryHeader },
          continue: true,
          override: true
        }
      ] : [],
      // Next.js page lambdas, `static/` folder, reserved assets, and `public/`
      // folder
      { handle: "filesystem" },
      // ensure the basePath prefixed _next/image is rewritten to the root
      // _next/image path
      ...routesManifest?.basePath ? [
        {
          src: import_path4.default.posix.join("/", entryDirectory, "_next/image/?"),
          dest: "/_next/image",
          check: true
        }
      ] : [],
      // normalize _next/data URL before processing rewrites
      ...normalizeNextDataRoute(),
      ...!isNextDataServerResolving ? [
        // No-op _next/data rewrite to trigger handle: 'rewrites' and then 404
        // if no match to prevent rewriting _next/data unexpectedly
        {
          src: import_path4.default.posix.join("/", entryDirectory, "_next/data/(.*)"),
          dest: import_path4.default.posix.join("/", entryDirectory, "_next/data/$1"),
          check: true
        }
      ] : [],
      // before processing rewrites, remove any special `/index` routes that were added
      // as these won't be properly normalized by `afterFilesRewrites` / `dynamicRoutes`
      ...appPathRoutesManifest ? [
        {
          src: import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/index(\\.action|\\.rsc)"
          ),
          dest: import_path4.default.posix.join("/", entryDirectory),
          continue: true
        }
      ] : [],
      // These need to come before handle: miss or else they are grouped
      // with that routing section
      ...afterFilesRewrites,
      // ensure non-normalized /.rsc from rewrites is handled
      ...appPathRoutesManifest ? [
        {
          src: import_path4.default.posix.join("/", entryDirectory, "/\\.prefetch\\.rsc$"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/__index${RSC_PREFETCH_SUFFIX}`
          ),
          check: true
        },
        {
          src: import_path4.default.posix.join(
            "/",
            entryDirectory,
            "(.+)/\\.prefetch\\.rsc$"
          ),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `$1${RSC_PREFETCH_SUFFIX}`
          ),
          check: true
        },
        {
          src: import_path4.default.posix.join("/", entryDirectory, "/\\.rsc$"),
          dest: import_path4.default.posix.join("/", entryDirectory, `/index.rsc`),
          check: true
        },
        {
          src: import_path4.default.posix.join("/", entryDirectory, "(.+)/\\.rsc$"),
          dest: import_path4.default.posix.join("/", entryDirectory, "$1.rsc"),
          check: true
        }
      ] : [],
      { handle: "resource" },
      ...fallbackRewrites,
      // make sure 404 page is used when a directory is matched without
      // an index page
      { src: import_path4.default.posix.join("/", entryDirectory, ".*"), status: 404 },
      { handle: "miss" },
      // We need to make sure to 404 for /_next after handle: miss since
      // handle: miss is called before rewrites and to prevent rewriting /_next
      {
        src: import_path4.default.posix.join(
          "/",
          entryDirectory,
          "_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media)/.+"
        ),
        status: 404,
        check: true,
        dest: "$0"
      },
      // remove locale prefixes to check public files and
      // to allow checking non-prefixed lambda outputs
      ...i18n ? [
        {
          src: import_path4.default.posix.join(
            "/",
            entryDirectory,
            (0, import_escape_string_regexp2.default)(i18n.defaultLocale)
          ),
          dest: "/",
          check: true
        },
        {
          src: `^${import_path4.default.posix.join("/", entryDirectory)}/?(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})/(.*)`,
          dest: `${import_path4.default.posix.join("/", entryDirectory, "/")}$1`,
          check: true
        }
      ] : [],
      // routes that are called after each rewrite or after routes
      // if there no rewrites
      { handle: "rewrite" },
      // re-build /_next/data URL after resolving
      ...denormalizeNextDataRoute(),
      ...isNextDataServerResolving ? dataRoutes.filter((route) => {
        const { pathname } = new URL(route.dest || "/", "http://n");
        return !isDynamicRoute(pathname.replace(/\.json$/, ""));
      }) : [],
      // /_next/data routes for getServerProps/getStaticProps pages
      ...isNextDataServerResolving ? (
        // when resolving data routes for middleware we need to include
        // all dynamic routes including non-SSG/SSP so that the priority
        // is correct
        dynamicRoutes.filter((route) => !route.src.includes(".rsc")).map((route) => {
          route = Object.assign({}, route);
          let normalizedSrc = route.src;
          if (routesManifest.basePath) {
            normalizedSrc = normalizedSrc.replace(
              new RegExp(
                `\\^${(0, import_escape_string_regexp2.default)(routesManifest.basePath)}`
              ),
              "^"
            );
          }
          route.src = import_path4.default.posix.join(
            "^/",
            entryDirectory,
            "_next/data/",
            escapedBuildId,
            normalizedSrc.replace(/\^\(\?:\/\(\?</, "(?:(?<").replace(/(^\^|\$$)/g, "") + ".json$"
          );
          const parsedDestination = new URL(route.dest || "/", "http://n");
          let pathname = parsedDestination.pathname;
          const search = parsedDestination.search;
          let isPrerender = !!prerenders[import_path4.default.join("./", pathname)];
          if (routesManifest.i18n) {
            for (const locale of routesManifest.i18n?.locales || []) {
              const prerenderPathname = pathname.replace(
                /^\/\$nextLocale/,
                `/${locale}`
              );
              if (prerenders[import_path4.default.join("./", prerenderPathname)]) {
                isPrerender = true;
                break;
              }
            }
          }
          if (isPrerender) {
            if (routesManifest.basePath) {
              pathname = pathname.replace(
                new RegExp(
                  `^${(0, import_escape_string_regexp2.default)(routesManifest.basePath)}`
                ),
                ""
              );
            }
            route.dest = `${routesManifest.basePath || ""}/_next/data/${buildId}${pathname}.json${search || ""}`;
          }
          return route;
        }).filter(Boolean)
      ) : dataRoutes,
      ...!isNextDataServerResolving ? [
        // ensure we 404 for non-existent _next/data routes before
        // trying page dynamic routes
        {
          src: import_path4.default.posix.join("/", entryDirectory, "_next/data/(.*)"),
          dest: import_path4.default.posix.join("/", entryDirectory, "404"),
          status: 404
        }
      ] : [],
      // Dynamic routes (must come after dataRoutes as dataRoutes are more
      // specific)
      ...dynamicRoutes,
      ...isNextDataServerResolving ? [
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/_next/data/",
            escapedBuildId,
            "/(.*).json"
          )}`,
          headers: {
            "x-nextjs-matched-path": "/$1"
          },
          continue: true,
          override: true
        },
        // add a catch-all data route so we don't 404 when getting
        // middleware effects
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/_next/data/",
            escapedBuildId,
            "/(.*).json"
          )}`,
          dest: "__next_data_catchall"
        }
      ] : [],
      // routes to call after a file has been matched
      { handle: "hit" },
      // Before we handle static files we need to set proper caching headers
      {
        // This ensures we only match known emitted-by-Next.js files and not
        // user-emitted files which may be missing a hash in their filename.
        src: import_path4.default.posix.join(
          "/",
          entryDirectory,
          `_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapedBuildId})/.+`
        ),
        // Next.js assets contain a hash or entropy in their filenames, so they
        // are guaranteed to be unique and cacheable indefinitely.
        headers: {
          "cache-control": `public,max-age=${MAX_AGE_ONE_YEAR},immutable`
        },
        continue: true,
        important: true
      },
      {
        src: import_path4.default.posix.join("/", entryDirectory, "/index(?:/)?"),
        headers: {
          "x-matched-path": "/"
        },
        continue: true,
        important: true
      },
      {
        src: import_path4.default.posix.join("/", entryDirectory, `/((?!index$).*?)(?:/)?`),
        headers: {
          "x-matched-path": "/$1"
        },
        continue: true,
        important: true
      },
      // error handling
      { handle: "error" },
      // Custom Next.js 404 page
      ...i18n && (static404Page || hasIsr404Page || lambdaPages["404.js"]) ? [
        {
          src: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?<nextLocale>${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(/.*|$)`,
          dest: import_path4.default.posix.join("/", entryDirectory, "/$nextLocale/404"),
          status: 404,
          caseSensitive: true
        },
        {
          src: import_path4.default.posix.join("/", entryDirectory, ".*"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/${i18n.defaultLocale}/404`
          ),
          status: 404
        }
      ] : [
        {
          src: import_path4.default.posix.join("/", entryDirectory, ".*"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            static404Page || hasIsr404Page || lambdas[import_path4.default.posix.join(entryDirectory, "404")] ? "/404" : appPathRoutesManifest && (middleware.edgeFunctions[appNotFoundPath] || lambdas[appNotFoundPath]) ? "/_not-found" : "/_error"
          ),
          status: 404
        }
      ],
      // custom 500 page if present
      ...i18n && (hasStatic500 || hasIsr500Page || lambdaPages["500.js"]) ? [
        {
          src: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?<nextLocale>${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(/.*|$)`,
          dest: import_path4.default.posix.join("/", entryDirectory, "/$nextLocale/500"),
          status: 500,
          caseSensitive: true
        },
        {
          src: import_path4.default.posix.join("/", entryDirectory, ".*"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/${i18n.defaultLocale}/500`
          ),
          status: 500
        }
      ] : [
        {
          src: import_path4.default.posix.join("/", entryDirectory, ".*"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            hasStatic500 || hasIsr500Page || lambdas[import_path4.default.posix.join(entryDirectory, "500")] ? "/500" : "/_error"
          ),
          status: 500
        }
      ]
    ],
    framework: { version: nextVersion },
    flags: variantsManifest || void 0
  };
}

// src/index.ts
var version = 2;
var htmlContentType = "text/html; charset=utf-8";
var SERVER_BUILD_MINIMUM_NEXT_VERSION = "v10.0.9-canary.4";
var BEFORE_FILES_CONTINUE_NEXT_VERSION = "v10.2.3-canary.1";
var REDIRECTS_NO_STATIC_NEXT_VERSION = "v11.0.2-canary.15";
var MAX_AGE_ONE_YEAR = 31536e3;
async function readPackageJson(entryPath) {
  const packagePath = import_path5.default.join(entryPath, "package.json");
  try {
    return JSON.parse(await (0, import_fs_extra6.readFile)(packagePath, "utf8"));
  } catch (err) {
    (0, import_build_utils3.debug)("package.json not found in entry");
    return {};
  }
}
async function writePackageJson(workPath, packageJson) {
  await (0, import_fs_extra6.writeFile)(
    import_path5.default.join(workPath, "package.json"),
    JSON.stringify(packageJson, null, 2)
  );
}
async function writeNpmRc(workPath, token) {
  await (0, import_fs_extra6.writeFile)(
    import_path5.default.join(workPath, ".npmrc"),
    `//registry.npmjs.org/:_authToken=${token}`
  );
}
function getRealNextVersion(entryPath) {
  try {
    const resolved = require_.resolve("next/package.json", {
      paths: [entryPath]
    });
    const nextVersion = require_(resolved).version;
    console.log(`Detected Next.js version: ${nextVersion}`);
    return nextVersion;
  } catch (_ignored) {
    console.log(
      `Warning: Could not identify Next.js version, ensure it is defined as a project dependency.`
    );
    return false;
  }
}
async function getNextVersionRange(entryPath) {
  let nextVersion = false;
  const pkg = await readPackageJson(entryPath);
  if (pkg.dependencies && pkg.dependencies.next) {
    nextVersion = pkg.dependencies.next;
  } else if (pkg.devDependencies && pkg.devDependencies.next) {
    nextVersion = pkg.devDependencies.next;
  }
  return nextVersion;
}
function isLegacyNext(nextVersion) {
  if (nextVersion === "canary" || nextVersion === "latest") {
    return false;
  }
  if (legacy_versions_default.indexOf(nextVersion) !== -1) {
    return true;
  }
  const maxSatisfying = import_semver4.default.maxSatisfying(legacy_versions_default, nextVersion);
  if (maxSatisfying === null) {
    return false;
  }
  return true;
}
var build = async (buildOptions) => {
  let { workPath, repoRootPath } = buildOptions;
  const {
    files,
    entrypoint,
    config = {},
    meta = {},
    buildCallback
  } = buildOptions;
  validateEntrypoint(entrypoint);
  let entryDirectory = import_path5.default.dirname(entrypoint);
  let entryPath = import_path5.default.join(workPath, entryDirectory);
  if (config.rootDirectory) {
    repoRootPath = entryPath;
    entryPath = import_path5.default.join(entryPath, config.rootDirectory);
  }
  const outputDirectory = import_path5.default.join("./", config.outputDirectory || ".next");
  const dotNextStatic = import_path5.default.join(entryPath, outputDirectory, "static");
  const baseDir = repoRootPath || workPath;
  (0, import_build_utils3.debug)(
    JSON.stringify(
      {
        repoRootPath,
        baseDir,
        workPath,
        entryPath,
        entryDirectory,
        outputDirectory
      },
      null,
      2
    )
  );
  const prefixedEnvs = (0, import_build_utils3.getPrefixedEnvVars)({
    envPrefix: "NEXT_PUBLIC_",
    envs: process.env
  });
  for (const [key, value] of Object.entries(prefixedEnvs)) {
    process.env[key] = value;
  }
  await (0, import_build_utils3.download)(files, workPath, meta);
  if (config.rootDirectory) {
    workPath = import_path5.default.join(workPath, config.rootDirectory);
  }
  let pkg = await readPackageJson(entryPath);
  const nextVersionRange = await getNextVersionRange(entryPath);
  const nodeVersion = await (0, import_build_utils3.getNodeVersion)(entryPath, void 0, config, meta);
  const spawnOpts = (0, import_build_utils3.getSpawnOptions)(meta, nodeVersion);
  const { cliType, lockfileVersion, packageJson } = await (0, import_build_utils3.scanParentDirs)(
    entryPath,
    true
  );
  spawnOpts.env = (0, import_build_utils3.getEnvForPackageManager)({
    cliType,
    lockfileVersion,
    packageJsonPackageManager: packageJson?.packageManager,
    nodeVersion,
    env: spawnOpts.env || {}
  });
  const nowJsonPath = await (0, import_find_up.default)(["now.json", "vercel.json"], {
    cwd: entryPath
  });
  let hasLegacyRoutes = false;
  const hasFunctionsConfig = Boolean(config.functions);
  if (await (0, import_fs_extra6.pathExists)(dotNextStatic)) {
    console.warn("WARNING: You should not upload the `.next` directory.");
  }
  const isLegacy = nextVersionRange && isLegacyNext(nextVersionRange);
  (0, import_build_utils3.debug)(`MODE: ${isLegacy ? "legacy" : "server(less)"}`);
  if (isLegacy) {
    console.warn(
      "WARNING: your application is being deployed in @vercel/next's legacy mode. http://err.sh/vercel/vercel/now-next-legacy-mode"
    );
    await Promise.all([
      (0, import_fs_extra6.remove)(import_path5.default.join(entryPath, "yarn.lock")),
      (0, import_fs_extra6.remove)(import_path5.default.join(entryPath, "package-lock.json"))
    ]);
    (0, import_build_utils3.debug)("Normalizing package.json");
    pkg = normalizePackageJson(pkg);
    (0, import_build_utils3.debug)("Normalized package.json result: ", pkg);
    await writePackageJson(entryPath, pkg);
  }
  let buildScriptName = (0, import_build_utils3.getScriptName)(pkg, [
    "vercel-build",
    "now-build",
    "build"
  ]);
  const { installCommand, buildCommand } = config;
  if (!buildScriptName && !buildCommand) {
    console.log(
      'Your application is being built using `next build`. If you need to define a different build step, please create a `vercel-build` script in your `package.json` (e.g. `{ "scripts": { "vercel-build": "npm run prepare && next build" } }`).'
    );
    await writePackageJson(entryPath, {
      ...pkg,
      scripts: {
        "vercel-build": "next build",
        ...pkg.scripts
      }
    });
    buildScriptName = "vercel-build";
  }
  if (process.env.NPM_AUTH_TOKEN) {
    (0, import_build_utils3.debug)("Found NPM_AUTH_TOKEN in environment, creating .npmrc");
    await writeNpmRc(entryPath, process.env.NPM_AUTH_TOKEN);
  }
  if (typeof installCommand === "string") {
    if (installCommand.trim()) {
      console.log(`Running "install" command: \`${installCommand}\`...`);
      await (0, import_build_utils3.execCommand)(installCommand, {
        ...spawnOpts,
        cwd: entryPath
      });
    } else {
      console.log(`Skipping "install" command...`);
    }
  } else {
    await (0, import_build_utils3.runNpmInstall)(entryPath, [], spawnOpts, meta, nodeVersion);
  }
  if (spawnOpts.env.VERCEL_ANALYTICS_ID) {
    (0, import_build_utils3.debug)("Found VERCEL_ANALYTICS_ID in environment");
    const version2 = await (0, import_build_utils3.getInstalledPackageVersion)(
      "@vercel/speed-insights",
      entryPath
    );
    if (version2) {
      delete spawnOpts.env.VERCEL_ANALYTICS_ID;
      delete process.env.VERCEL_ANALYTICS_ID;
      (0, import_build_utils3.debug)(
        "@vercel/speed-insights is installed, removing VERCEL_ANALYTICS_ID from environment"
      );
    }
  }
  const nextVersion = getRealNextVersion(entryPath);
  if (!nextVersion) {
    throw new import_build_utils3.NowBuildError({
      code: "NEXT_NO_VERSION",
      message: 'No Next.js version could be detected in your project. Make sure `"next"` is installed in "dependencies" or "devDependencies"'
    });
  }
  let isServerMode = !(config.framework === "blitzjs") && import_semver4.default.gte(nextVersion, SERVER_BUILD_MINIMUM_NEXT_VERSION);
  const beforeFilesShouldContinue = import_semver4.default.gte(
    nextVersion,
    BEFORE_FILES_CONTINUE_NEXT_VERSION
  );
  const isCorrectLocaleAPIRoutes = import_semver4.default.gte(nextVersion, "v11.0.2-canary.3");
  if (isServerMode) {
    (0, import_build_utils3.debug)(
      `Application is being built in server mode since ${nextVersion} meets minimum version of ${SERVER_BUILD_MINIMUM_NEXT_VERSION}`
    );
  } else {
    if (nowJsonPath) {
      const nowJsonData = JSON.parse(await (0, import_fs_extra6.readFile)(nowJsonPath, "utf8"));
      if (Array.isArray(nowJsonData.routes) && nowJsonData.routes.length > 0) {
        hasLegacyRoutes = true;
        console.warn(
          `WARNING: your application is being opted out of @vercel/next's optimized lambdas mode due to legacy routes in ${import_path5.default.basename(
            nowJsonPath
          )}. http://err.sh/vercel/vercel/next-legacy-routes-optimized-lambdas`
        );
      }
    }
    if (hasFunctionsConfig) {
      console.warn(
        `WARNING: Your application is being opted out of "@vercel/next" optimized lambdas mode due to \`functions\` config.
More info: http://err.sh/vercel/vercel/next-functions-config-optimized-lambdas`
      );
    }
  }
  const isSharedLambdas = !isServerMode && !hasLegacyRoutes && !hasFunctionsConfig && typeof config.sharedLambdas === "undefined" ? true : !!config.sharedLambdas;
  let target;
  if (isServerMode) {
    target = "server";
  } else if (!isLegacy) {
    target = await createServerlessConfig(workPath, entryPath, nextVersion);
  }
  const env = { ...spawnOpts.env };
  env.NEXT_EDGE_RUNTIME_PROVIDER = "vercel";
  if (target) {
    env.NEXT_PRIVATE_TARGET = target;
  }
  env.NEXT_PRIVATE_OUTPUT_TRACE_ROOT = baseDir;
  if (isServerMode) {
    env.NODE_ENV = "production";
  }
  if (buildCommand) {
    const nodeBinPaths = (0, import_build_utils3.getNodeBinPaths)({
      start: entryPath,
      base: repoRootPath
    });
    const nodeBinPath = nodeBinPaths.join(import_path5.default.delimiter);
    env.PATH = `${nodeBinPath}${import_path5.default.delimiter}${env.PATH}`;
    if (!env.YARN_NODE_LINKER) {
      env.YARN_NODE_LINKER = "node-modules";
    }
    (0, import_build_utils3.debug)(
      `Added "${nodeBinPath}" to PATH env because a build command was used.`
    );
    console.log(`Running "${buildCommand}"`);
    await (0, import_build_utils3.execCommand)(buildCommand, {
      ...spawnOpts,
      cwd: entryPath,
      env
    });
  } else if (buildScriptName) {
    await (0, import_build_utils3.runPackageJsonScript)(entryPath, buildScriptName, {
      ...spawnOpts,
      env
    });
  }
  (0, import_build_utils3.debug)("build command exited");
  if (buildCallback) {
    await buildCallback(buildOptions);
  }
  let buildOutputVersion;
  try {
    const data = await (0, import_fs_extra6.readJSON)(
      import_path5.default.join(outputDirectory, "output/config.json")
    );
    buildOutputVersion = data.version;
  } catch (_) {
  }
  if (buildOutputVersion) {
    return {
      buildOutputPath: import_path5.default.join(outputDirectory, "output"),
      buildOutputVersion
    };
  }
  let appMountPrefixNoTrailingSlash = import_path5.default.posix.join("/", entryDirectory).replace(/\/+$/, "");
  const requiredServerFilesManifest = isServerMode ? await getRequiredServerFilesManifest(entryPath, outputDirectory) : false;
  isServerMode = Boolean(requiredServerFilesManifest);
  const functionsConfigManifest = await getFunctionsConfigManifest(
    entryPath,
    outputDirectory
  );
  const variantsManifest = await getVariantsManifest(
    entryPath,
    outputDirectory
  );
  const routesManifest = await getRoutesManifest(
    entryPath,
    outputDirectory,
    nextVersion
  );
  const imagesManifest = await getImagesManifest(entryPath, outputDirectory);
  const prerenderManifest = await getPrerenderManifest(
    entryPath,
    outputDirectory
  );
  const omittedPrerenderRoutes = new Set(
    Object.keys(prerenderManifest.omittedRoutes)
  );
  const hasIsr404Page = typeof prerenderManifest.staticRoutes[routesManifest?.i18n ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
    import_path5.default.join("/", routesManifest?.i18n.defaultLocale, "/404")
  ) : "/404"]?.initialRevalidate === "number";
  const hasIsr500Page = typeof prerenderManifest.staticRoutes[routesManifest?.i18n ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
    import_path5.default.join("/", routesManifest?.i18n.defaultLocale, "/500")
  ) : "/500"]?.initialRevalidate === "number";
  const wildcardConfig = routesManifest?.i18n?.domains && routesManifest.i18n.domains.length > 0 ? routesManifest.i18n.domains.map((item) => {
    return {
      domain: item.domain,
      value: item.defaultLocale === routesManifest.i18n?.defaultLocale ? "" : `/${item.defaultLocale}`
    };
  }) : void 0;
  const privateOutputs = await getPrivateOutputs(
    import_path5.default.join(entryPath, outputDirectory),
    {
      "next-stats.json": "_next/__private/stats.json",
      trace: "_next/__private/trace"
    }
  );
  const headers = [];
  const beforeFilesRewrites = [];
  const afterFilesRewrites = [];
  const fallbackRewrites = [];
  let redirects = [];
  const dataRoutes = [];
  let dynamicRoutes = [];
  let hasPages404 = false;
  let buildId = "";
  let escapedBuildId = "";
  if (isLegacy || isSharedLambdas || isServerMode) {
    try {
      buildId = await (0, import_fs_extra6.readFile)(
        import_path5.default.join(entryPath, outputDirectory, "BUILD_ID"),
        "utf8"
      );
      escapedBuildId = (0, import_escape_string_regexp3.default)(buildId);
    } catch (err) {
      throw new import_build_utils3.NowBuildError({
        code: "NOW_NEXT_NO_BUILD_ID",
        message: 'The BUILD_ID file was not found in the Output Directory. Did you forget to run "next build" in your Build Command?'
      });
    }
  }
  if (routesManifest) {
    switch (routesManifest.version) {
      case 1:
      case 2:
      case 3:
      case 4: {
        redirects.push(...(0, import_superstatic.convertRedirects)(routesManifest.redirects));
        if (Array.isArray(routesManifest.rewrites)) {
          afterFilesRewrites.push(
            ...(0, import_superstatic.convertRewrites)(
              routesManifest.rewrites,
              routesManifest.i18n ? ["nextInternalLocale"] : void 0
            )
          );
        } else {
          beforeFilesRewrites.push(
            ...(0, import_superstatic.convertRewrites)(routesManifest.rewrites.beforeFiles).map((r) => {
              if ("check" in r) {
                if (beforeFilesShouldContinue) {
                  delete r.check;
                  r.continue = true;
                }
                r.override = true;
              }
              return r;
            })
          );
          afterFilesRewrites.push(
            ...(0, import_superstatic.convertRewrites)(routesManifest.rewrites.afterFiles)
          );
          fallbackRewrites.push(
            ...(0, import_superstatic.convertRewrites)(routesManifest.rewrites.fallback)
          );
        }
        if (routesManifest.headers) {
          headers.push(...(0, import_superstatic.convertHeaders)(routesManifest.headers));
        }
        if (import_semver4.default.gte(nextVersion, REDIRECTS_NO_STATIC_NEXT_VERSION)) {
          redirects.forEach(
            (r, i) => updateRouteSrc(r, i, routesManifest.redirects)
          );
          afterFilesRewrites.forEach(
            (r, i) => updateRouteSrc(
              r,
              i,
              Array.isArray(routesManifest.rewrites) ? routesManifest.rewrites : routesManifest.rewrites.afterFiles
            )
          );
          beforeFilesRewrites.forEach(
            (r, i) => updateRouteSrc(
              r,
              i,
              Array.isArray(routesManifest.rewrites) ? [] : routesManifest.rewrites.beforeFiles
            )
          );
          fallbackRewrites.forEach(
            (r, i) => updateRouteSrc(
              r,
              i,
              Array.isArray(routesManifest.rewrites) ? [] : routesManifest.rewrites.fallback
            )
          );
          headers.forEach(
            (r, i) => updateRouteSrc(r, i, routesManifest.headers || [])
          );
        }
        if (routesManifest.basePath && routesManifest.basePath !== "/") {
          const nextBasePath = routesManifest.basePath;
          if (!nextBasePath.startsWith("/")) {
            throw new import_build_utils3.NowBuildError({
              code: "NEXT_BASEPATH_STARTING_SLASH",
              message: "basePath must start with `/`. Please upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
            });
          }
          if (nextBasePath.endsWith("/")) {
            throw new import_build_utils3.NowBuildError({
              code: "NEXT_BASEPATH_TRAILING_SLASH",
              message: "basePath must not end with `/`. Please upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
            });
          }
          if (entryDirectory.length > 1) {
            throw new import_build_utils3.NowBuildError({
              code: "NEXT_BASEPATH_LEGACY_BUILDS",
              message: "basePath can not be used with `builds` in vercel.json, use Project Settings to configure your monorepo instead",
              link: "https://vercel.com/docs/platform/projects#project-settings"
            });
          }
          entryDirectory = import_path5.default.join(entryDirectory, nextBasePath);
          appMountPrefixNoTrailingSlash = import_path5.default.posix.join("/", entryDirectory).replace(/\/+$/, "");
        }
        if (routesManifest.pages404) {
          hasPages404 = true;
        }
        break;
      }
      default: {
        throw new import_build_utils3.NowBuildError({
          code: "NEXT_VERSION_OUTDATED",
          message: "This version of `@vercel/next` does not support the version of Next.js you are trying to deploy.\nPlease upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
        });
      }
    }
  }
  let dynamicPrefix = import_path5.default.posix.join("/", entryDirectory);
  dynamicPrefix = dynamicPrefix === "/" ? "" : dynamicPrefix;
  if (imagesManifest) {
    switch (imagesManifest.version) {
      case 1: {
        if (!imagesManifest.images) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_MISSING",
            message: 'image-manifest.json "images" is required. Contact support if this continues to happen.'
          });
        }
        const { images } = imagesManifest;
        if (!Array.isArray(images.domains)) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_DOMAINS",
            message: 'image-manifest.json "images.domains" must be an array. Contact support if this continues to happen.'
          });
        }
        if (!Array.isArray(images.sizes)) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_SIZES",
            message: 'image-manifest.json "images.sizes" must be an array. Contact support if this continues to happen.'
          });
        }
        if (images.remotePatterns && !Array.isArray(images.remotePatterns)) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_REMOTEPATTERNS",
            message: 'image-manifest.json "images.remotePatterns" must be an array. Contact support if this continues to happen'
          });
        }
        if (images.minimumCacheTTL && !Number.isInteger(images.minimumCacheTTL)) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_MINIMUMCACHETTL",
            message: 'image-manifest.json "images.minimumCacheTTL" must be an integer. Contact support if this continues to happen.'
          });
        }
        if (typeof images.dangerouslyAllowSVG !== "undefined" && typeof images.dangerouslyAllowSVG !== "boolean") {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_DANGEROUSLYALLOWSVG",
            message: 'image-manifest.json "images.dangerouslyAllowSVG" must be a boolean. Contact support if this continues to happen.'
          });
        }
        if (typeof images.contentSecurityPolicy !== "undefined" && typeof images.contentSecurityPolicy !== "string") {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_CONTENTSECURITYPOLICY",
            message: 'image-manifest.json "images.contentSecurityPolicy" must be a string. Contact support if this continues to happen.'
          });
        }
        break;
      }
      default: {
        throw new import_build_utils3.NowBuildError({
          code: "NEXT_IMAGES_VERSION_UNKNOWN",
          message: "This version of `@vercel/next` does not support the version of Next.js you are trying to deploy.\nPlease upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
        });
      }
    }
  }
  const userExport = await getExportStatus(entryPath);
  if (userExport) {
    const exportIntent = await getExportIntent(entryPath);
    const { trailingSlash: trailingSlash2 = false } = exportIntent || {};
    const resultingExport = await getExportStatus(entryPath);
    if (!resultingExport) {
      throw new import_build_utils3.NowBuildError({
        code: "NEXT_EXPORT_FAILED",
        message: "Exporting Next.js app failed. Please check your build logs and contact us if this continues."
      });
    }
    if (resultingExport.success !== true) {
      throw new import_build_utils3.NowBuildError({
        code: "NEXT_EXPORT_FAILED",
        message: "Export of Next.js app failed. Please check your build logs."
      });
    }
    const outDirectory = resultingExport.outDirectory;
    (0, import_build_utils3.debug)(`next export should use trailing slash: ${trailingSlash2}`);
    const filesAfterBuild = await (0, import_build_utils3.glob)("**", outDirectory);
    const output = {
      ...filesAfterBuild,
      ...privateOutputs.files
    };
    Object.entries(output).filter(([name]) => name.endsWith(".html")).forEach(([name, value]) => {
      const cleanName = name.slice(0, -5);
      delete output[name];
      output[cleanName] = value;
      if (value.type === "FileBlob" || value.type === "FileFsRef") {
        value.contentType = value.contentType || "text/html; charset=utf-8";
      }
    });
    console.log(
      "Notice: detected `next export`, this de-opts some Next.js features\nSee more info: https://nextjs.org/docs/advanced-features/static-html-export"
    );
    return {
      output,
      images: getImagesConfig(imagesManifest),
      routes: [
        ...privateOutputs.routes,
        ...headers,
        ...redirects,
        ...beforeFilesRewrites,
        // Make sure to 404 for the /404 path itself
        {
          src: import_path5.default.posix.join("/", entryDirectory, "404/?"),
          status: 404,
          continue: true
        },
        // Next.js pages, `static/` folder, reserved assets, and `public/`
        // folder
        { handle: "filesystem" },
        // ensure the basePath prefixed _next/image is rewritten to the root
        // _next/image path
        ...routesManifest?.basePath ? [
          {
            src: import_path5.default.posix.join("/", entryDirectory, "_next/image/?"),
            dest: "/_next/image",
            check: true
          }
        ] : [],
        // No-op _next/data rewrite to trigger handle: 'rewrites' and then 404
        // if no match to prevent rewriting _next/data unexpectedly
        {
          src: import_path5.default.posix.join("/", entryDirectory, "_next/data/(.*)"),
          dest: import_path5.default.posix.join("/", entryDirectory, "_next/data/$1"),
          check: true
        },
        {
          src: import_path5.default.posix.join("/", entryDirectory, "_next/data/(.*)"),
          status: 404
        },
        // These need to come before handle: miss or else they are grouped
        // with that routing section
        ...afterFilesRewrites,
        // make sure 404 page is used when a directory is matched without
        // an index page
        { handle: "resource" },
        ...fallbackRewrites,
        { src: import_path5.default.posix.join("/", entryDirectory, ".*"), status: 404 },
        // We need to make sure to 404 for /_next after handle: miss since
        // handle: miss is called before rewrites and to prevent rewriting
        // /_next
        { handle: "miss" },
        {
          src: import_path5.default.posix.join(
            "/",
            entryDirectory,
            "_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media)/.+"
          ),
          status: 404,
          check: true,
          dest: "$0"
        },
        // Dynamic routes
        // TODO: do we want to do this?: ...dynamicRoutes,
        // (if so make sure to add any dynamic routes after handle: 'rewrite' )
        // routes to call after a file has been matched
        { handle: "hit" },
        // Before we handle static files we need to set proper caching headers
        {
          // This ensures we only match known emitted-by-Next.js files and not
          // user-emitted files which may be missing a hash in their filename.
          src: import_path5.default.posix.join(
            "/",
            entryDirectory,
            `_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapedBuildId})/.+`
          ),
          // Next.js assets contain a hash or entropy in their filenames, so they
          // are guaranteed to be unique and cacheable indefinitely.
          headers: {
            "cache-control": `public,max-age=${MAX_AGE_ONE_YEAR},immutable`
          },
          continue: true,
          important: true
        },
        // error handling
        ...output[import_path5.default.posix.join("./", entryDirectory, "404")] || output[import_path5.default.posix.join("./", entryDirectory, "404/index")] ? [
          { handle: "error" },
          {
            status: 404,
            src: import_path5.default.posix.join(entryDirectory, ".*"),
            dest: import_path5.default.posix.join("/", entryDirectory, "404")
          }
        ] : []
      ],
      framework: { version: nextVersion }
    };
  }
  if (isLegacy) {
    (0, import_build_utils3.debug)("Running npm install --production...");
    await (0, import_build_utils3.runNpmInstall)(
      entryPath,
      ["--production"],
      spawnOpts,
      meta,
      nodeVersion
    );
  }
  if (process.env.NPM_AUTH_TOKEN) {
    await (0, import_fs_extra6.remove)(import_path5.default.join(entryPath, ".npmrc"));
  }
  const trailingSlashRedirects = [];
  let trailingSlash = false;
  redirects = redirects.filter((_redir) => {
    const redir = _redir;
    const location = redir.headers && (redir.headers.location || redir.headers.Location);
    if (redir.status === 308 && (location === "/$1" || location === "/$1/")) {
      redir.continue = true;
      trailingSlashRedirects.push(redir);
      if (location === "/$1/") {
        trailingSlash = true;
      }
      return false;
    }
    return true;
  });
  const pageLambdaRoutes = [];
  const dynamicPageLambdaRoutes = [];
  const dynamicPageLambdaRoutesMap = {};
  const pageLambdaMap = {};
  const lambdas = {};
  const prerenders = {};
  let staticPages = {};
  const dynamicPages = [];
  let static404Page;
  let page404Path = "";
  let hasStatic500;
  if (isLegacy) {
    const filesAfterBuild = await (0, import_build_utils3.glob)("**", entryPath);
    (0, import_build_utils3.debug)("Preparing serverless function files...");
    const dotNextRootFiles = await (0, import_build_utils3.glob)(`${outputDirectory}/*`, entryPath);
    const dotNextServerRootFiles = await (0, import_build_utils3.glob)(
      `${outputDirectory}/server/*`,
      entryPath
    );
    const nodeModules = excludeFiles(
      await (0, import_build_utils3.glob)("node_modules/**", entryPath),
      (file) => file.startsWith("node_modules/.cache")
    );
    const nextFiles = {
      ...nodeModules,
      ...dotNextRootFiles,
      ...dotNextServerRootFiles
    };
    if (filesAfterBuild["next.config.js"]) {
      nextFiles["next.config.js"] = filesAfterBuild["next.config.js"];
    }
    const pagesDir = import_path5.default.join(
      entryPath,
      outputDirectory,
      "server",
      "static",
      buildId,
      "pages"
    );
    const { pages } = await getServerlessPages({
      pagesDir,
      entryPath,
      outputDirectory
    });
    const launcherPath = import_path5.default.join(__dirname, "legacy-launcher.js");
    const launcherData = await (0, import_fs_extra6.readFile)(launcherPath, "utf8");
    await Promise.all(
      Object.keys(pages).map(async (page) => {
        if (["_app.js", "_error.js", "_document.js"].includes(page)) {
          return;
        }
        const pathname = page.replace(/\.js$/, "");
        const launcher = launcherData.replace(
          "PATHNAME_PLACEHOLDER",
          `/${pathname.replace(/(^|\/)index$/, "")}`
        );
        const pageFiles = {
          [`${outputDirectory}/server/static/${buildId}/pages/_document.js`]: filesAfterBuild[`${outputDirectory}/server/static/${buildId}/pages/_document.js`],
          [`${outputDirectory}/server/static/${buildId}/pages/_app.js`]: filesAfterBuild[`${outputDirectory}/server/static/${buildId}/pages/_app.js`],
          [`${outputDirectory}/server/static/${buildId}/pages/_error.js`]: filesAfterBuild[`${outputDirectory}/server/static/${buildId}/pages/_error.js`],
          [`${outputDirectory}/server/static/${buildId}/pages/${page}`]: filesAfterBuild[`${outputDirectory}/server/static/${buildId}/pages/${page}`]
        };
        let lambdaOptions = {};
        if (config && config.functions) {
          lambdaOptions = await (0, import_build_utils3.getLambdaOptionsFromFunction)({
            sourceFile: await getSourceFilePathFromPage({
              workPath: entryPath,
              page
            }),
            config
          });
        }
        (0, import_build_utils3.debug)(`Creating serverless function for page: "${page}"...`);
        lambdas[import_path5.default.posix.join(entryDirectory, pathname)] = new import_build_utils3.NodejsLambda({
          files: {
            ...nextFiles,
            ...pageFiles,
            "___next_launcher.cjs": new import_build_utils3.FileBlob({ data: launcher })
          },
          handler: "___next_launcher.cjs",
          runtime: nodeVersion.runtime,
          ...lambdaOptions,
          operationType: "Page",
          // always Page because we're in legacy mode
          shouldAddHelpers: false,
          shouldAddSourcemapSupport: false,
          supportsMultiPayloads: true,
          framework: {
            slug: "nextjs",
            version: nextVersion
          }
        });
        (0, import_build_utils3.debug)(`Created serverless function for page: "${page}"`);
      })
    );
  } else {
    (0, import_build_utils3.debug)("Preparing serverless function files...");
    const pagesDir = import_path5.default.join(
      entryPath,
      outputDirectory,
      isServerMode ? "server" : "serverless",
      "pages"
    );
    let appDir = null;
    const appPathRoutesManifest = await (0, import_fs_extra6.readJSON)(
      import_path5.default.join(entryPath, outputDirectory, "app-path-routes-manifest.json")
    ).catch(() => null);
    if (appPathRoutesManifest) {
      appDir = import_path5.default.join(pagesDir, "../app");
    }
    const { pages, appPaths: lambdaAppPaths } = await getServerlessPages({
      pagesDir,
      entryPath,
      outputDirectory,
      appPathRoutesManifest
    });
    const canUsePreviewMode = Object.keys(pages).some(
      (page) => isApiPage(pages[page].fsPath)
    );
    const originalStaticPages = await (0, import_build_utils3.glob)("**/*.html", pagesDir);
    staticPages = filterStaticPages(
      originalStaticPages,
      dynamicPages,
      entryDirectory,
      htmlContentType,
      prerenderManifest,
      routesManifest
    );
    hasStatic500 = !!staticPages[import_path5.default.posix.join(entryDirectory, "500")];
    static404Page = staticPages[import_path5.default.posix.join(entryDirectory, "404")] && hasPages404 ? import_path5.default.posix.join(entryDirectory, "404") : staticPages[import_path5.default.posix.join(entryDirectory, "_errors/404")] ? import_path5.default.posix.join(entryDirectory, "_errors/404") : void 0;
    const { i18n: i18n2 } = routesManifest || {};
    if (!static404Page && i18n2) {
      static404Page = staticPages[import_path5.default.posix.join(entryDirectory, i18n2.defaultLocale, "404")] ? import_path5.default.posix.join(entryDirectory, i18n2.defaultLocale, "404") : void 0;
    }
    if (!hasStatic500 && i18n2) {
      hasStatic500 = !!staticPages[import_path5.default.posix.join(entryDirectory, i18n2.defaultLocale, "500")];
    }
    if (routesManifest) {
      switch (routesManifest.version) {
        case 1:
        case 2:
        case 3:
        case 4: {
          if (routesManifest.dataRoutes) {
            for (const dataRoute of routesManifest.dataRoutes) {
              const isOmittedRoute = prerenderManifest.omittedRoutes[dataRoute.page];
              const ssgDataRoute = isOmittedRoute || prerenderManifest.fallbackRoutes[dataRoute.page] || prerenderManifest.blockingFallbackRoutes[dataRoute.page];
              if (prerenderManifest.staticRoutes[dataRoute.page] || !(static404Page && canUsePreviewMode) && isOmittedRoute) {
                continue;
              }
              const route = {
                src: (dataRoute.namedDataRouteRegex || dataRoute.dataRouteRegex).replace(/^\^/, `^${appMountPrefixNoTrailingSlash}`),
                dest: import_path5.default.posix.join(
                  "/",
                  entryDirectory,
                  // make sure to route SSG data route to the data prerender
                  // output, we don't do this for SSP routes since they don't
                  // have a separate data output
                  `${ssgDataRoute && ssgDataRoute.dataRoute || dataRoute.page}${dataRoute.routeKeys ? `?${Object.keys(dataRoute.routeKeys).map((key) => `${dataRoute.routeKeys[key]}=$${key}`).join("&")}` : ""}`
                )
              };
              if (!isServerMode) {
                route.check = true;
              }
              if (isOmittedRoute && isServerMode) {
                route.has = [
                  {
                    type: "cookie",
                    key: "__prerender_bypass",
                    value: prerenderManifest.bypassToken || void 0
                  },
                  {
                    type: "cookie",
                    key: "__next_preview_data"
                  }
                ];
              }
              const { i18n: i18n3 } = routesManifest;
              if (i18n3) {
                const origSrc = route.src;
                route.src = route.src.replace(
                  // we need to double escape the build ID here
                  // to replace it properly
                  `/${escapedBuildId}/`,
                  `/${escapedBuildId}/(?${ssgDataRoute || isServerMode ? "<nextLocale>" : ":"}${i18n3.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})/`
                );
                if (route.src === origSrc) {
                  route.src = route.src.replace(
                    // we need to double escape the build ID here
                    // to replace it properly
                    `/${escapedBuildId}`,
                    `/${escapedBuildId}/(?${ssgDataRoute || isServerMode ? "<nextLocale>" : ":"}${i18n3.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})[/]?`
                  );
                }
                if (dataRoute.page === "/") {
                  route.src = route.src.replace(/\/index\.json/, ".json");
                }
                if (ssgDataRoute) {
                  route.dest = route.dest.replace(
                    `/${buildId}/`,
                    `/${buildId}/$nextLocale/`
                  );
                } else if (isServerMode) {
                  route.dest = route.dest.replace(
                    dataRoute.page,
                    `/$nextLocale${dataRoute.page}`
                  );
                }
              }
              dataRoutes.push(route);
            }
          }
          break;
        }
        default: {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_VERSION_OUTDATED",
            message: "This version of `@vercel/next` does not support the version of Next.js you are trying to deploy.\nPlease upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
          });
        }
      }
    }
    const experimentalPPRRoutes = /* @__PURE__ */ new Set();
    for (const [route, { renderingMode }] of [
      ...Object.entries(prerenderManifest.staticRoutes),
      ...Object.entries(prerenderManifest.blockingFallbackRoutes),
      ...Object.entries(prerenderManifest.fallbackRoutes),
      ...Object.entries(prerenderManifest.omittedRoutes)
    ]) {
      if (renderingMode !== "PARTIALLY_STATIC" /* PARTIALLY_STATIC */)
        continue;
      experimentalPPRRoutes.add(route);
    }
    const isAppPPREnabled = requiredServerFilesManifest ? requiredServerFilesManifest.config.experimental?.ppr === true || requiredServerFilesManifest.config.experimental?.ppr === "incremental" : false;
    if (requiredServerFilesManifest) {
      if (!routesManifest) {
        throw new Error(
          `A routes-manifest could not be located, please check your outputDirectory and try again.`
        );
      }
      const localePrefixed404 = !!(routesManifest.i18n && originalStaticPages[import_path5.default.posix.join(".", routesManifest.i18n.defaultLocale, "404.html")]);
      return serverBuild({
        config,
        functionsConfigManifest,
        nextVersion,
        trailingSlash,
        appPathRoutesManifest,
        dynamicPages,
        canUsePreviewMode,
        staticPages,
        localePrefixed404,
        lambdaPages: pages,
        lambdaAppPaths,
        omittedPrerenderRoutes,
        isCorrectLocaleAPIRoutes,
        pagesDir,
        headers,
        beforeFilesRewrites,
        afterFilesRewrites,
        fallbackRewrites,
        workPath,
        redirects,
        nodeVersion,
        dynamicPrefix,
        routesManifest,
        imagesManifest,
        wildcardConfig,
        prerenderManifest,
        entryDirectory,
        entryPath,
        baseDir,
        dataRoutes,
        buildId,
        escapedBuildId,
        outputDirectory,
        trailingSlashRedirects,
        requiredServerFilesManifest,
        privateOutputs,
        hasIsr404Page,
        hasIsr500Page,
        variantsManifest,
        experimentalPPRRoutes,
        isAppPPREnabled
      });
    }
    const pageKeys = Object.keys(pages);
    let hasLambdas = !static404Page || pageKeys.length > 1;
    if (pageKeys.length === 0) {
      const nextConfig = await getNextConfig(workPath, entryPath);
      if (nextConfig != null) {
        console.info("Found next.config.js:");
        console.info(nextConfig);
        console.info();
      }
      throw new import_build_utils3.NowBuildError({
        code: "NEXT_NO_SERVERLESS_PAGES",
        message: "No serverless pages were built",
        link: "https://err.sh/vercel/vercel/now-next-no-serverless-pages-built"
      });
    }
    let requiresTracing = hasLambdas;
    try {
      if (nextVersion && import_semver4.default.lt(nextVersion, ExperimentalTraceVersion)) {
        (0, import_build_utils3.debug)(
          "Next.js version is too old for us to trace the required dependencies.\nAssuming Next.js has handled it!"
        );
        requiresTracing = false;
      }
    } catch (err) {
      console.log(
        "Failed to check Next.js version for tracing compatibility: " + err
      );
    }
    let assets;
    const nonLambdaSsgPages = /* @__PURE__ */ new Set();
    Object.keys(prerenderManifest.staticRoutes).forEach((route) => {
      const result = onPrerenderRouteInitial(
        prerenderManifest,
        canUsePreviewMode,
        entryDirectory,
        nonLambdaSsgPages,
        route,
        hasPages404,
        routesManifest
      );
      if (result && result.static404Page) {
        static404Page = result.static404Page;
      }
      if (result && result.static500Page) {
        hasStatic500 = true;
      }
    });
    const pageTraces = {};
    const compressedPages = {};
    let tracedPseudoLayer;
    const apiPages = [];
    const nonApiPages = [];
    for (const page of pageKeys) {
      const pagePath = pages[page].fsPath;
      const route = `/${page.replace(/\.js$/, "")}`;
      if (route === "/_error" && static404Page)
        continue;
      if (isApiPage(pagePath)) {
        apiPages.push(page);
      } else if (!nonLambdaSsgPages.has(route)) {
        nonApiPages.push(page);
      }
      compressedPages[page] = (await createPseudoLayer({
        [page]: pages[page]
      })).pseudoLayer[page];
    }
    const mergedPageKeys = [...nonApiPages, ...apiPages];
    if (requiresTracing) {
      hasLambdas = !static404Page || apiPages.length > 0 || nonApiPages.length > 0;
      const tracingLabel = "Traced Next.js serverless functions for external files in";
      if (hasLambdas) {
        console.time(tracingLabel);
      }
      const nftCache = /* @__PURE__ */ Object.create(null);
      const lstatSema = new import_async_sema3.Sema(25);
      const lstatResults = {};
      const pathsToTrace = mergedPageKeys.map((page) => pages[page].fsPath);
      const result = await (0, import_nft2.nodeFileTrace)(pathsToTrace, {
        base: baseDir,
        cache: nftCache,
        processCwd: entryPath
      });
      result.esmFileList.forEach((file) => result.fileList.add(file));
      const parentFilesMap = getFilesMapFromReasons(
        result.fileList,
        result.reasons
      );
      for (const page of mergedPageKeys) {
        const tracedFiles = {};
        const fileList = parentFilesMap.get(
          import_path5.default.relative(baseDir, pages[page].fsPath)
        );
        if (!fileList) {
          throw new Error(
            `Invariant: Failed to trace ${page}, missing fileList`
          );
        }
        const reasons = result.reasons;
        await Promise.all(
          Array.from(fileList).map(
            collectTracedFiles(
              baseDir,
              lstatResults,
              lstatSema,
              reasons,
              tracedFiles
            )
          )
        );
        pageTraces[page] = tracedFiles;
      }
      if (hasLambdas) {
        console.timeEnd(tracingLabel);
      }
      const zippingLabel = "Compressed shared serverless function files";
      if (hasLambdas) {
        console.time(zippingLabel);
      }
      tracedPseudoLayer = await createPseudoLayer(
        mergedPageKeys.reduce((prev, page) => {
          Object.assign(prev, pageTraces[page]);
          return prev;
        }, {})
      );
      if (hasLambdas) {
        console.timeEnd(zippingLabel);
      }
    } else {
      assets = await (0, import_build_utils3.glob)(
        "assets/**",
        import_path5.default.join(entryPath, outputDirectory, "serverless")
      );
      const assetKeys = Object.keys(assets);
      if (assetKeys.length > 0) {
        (0, import_build_utils3.debug)(
          "detected (legacy) assets to be bundled with serverless function:"
        );
        assetKeys.forEach((assetFile) => (0, import_build_utils3.debug)(`	${assetFile}`));
        (0, import_build_utils3.debug)(
          "\nPlease upgrade to Next.js 9.1 to leverage modern asset handling."
        );
      }
    }
    const launcherPath = import_path5.default.join(__dirname, "templated-launcher.js");
    const launcherData = await (0, import_fs_extra6.readFile)(launcherPath, "utf8");
    const allLambdasLabel = `All serverless functions created in`;
    if (hasLambdas) {
      console.time(allLambdasLabel);
    }
    const apiLambdaGroups = [];
    const pageLambdaGroups = [];
    if (isSharedLambdas) {
      const initialPageLambdaGroups = await getPageLambdaGroups({
        entryPath,
        config,
        functionsConfigManifest,
        pages: nonApiPages,
        prerenderRoutes: /* @__PURE__ */ new Set(),
        pageTraces,
        compressedPages,
        tracedPseudoLayer: tracedPseudoLayer?.pseudoLayer || {},
        initialPseudoLayer: { pseudoLayer: {}, pseudoLayerBytes: 0 },
        initialPseudoLayerUncompressed: 0,
        // internal pages are already referenced in traces for serverless
        // like builds
        internalPages: [],
        experimentalPPRRoutes: void 0
      });
      const initialApiLambdaGroups = await getPageLambdaGroups({
        entryPath,
        config,
        functionsConfigManifest,
        pages: apiPages,
        prerenderRoutes: /* @__PURE__ */ new Set(),
        pageTraces,
        compressedPages,
        tracedPseudoLayer: tracedPseudoLayer?.pseudoLayer || {},
        initialPseudoLayer: { pseudoLayer: {}, pseudoLayerBytes: 0 },
        initialPseudoLayerUncompressed: 0,
        internalPages: [],
        experimentalPPRRoutes: void 0
      });
      for (const group of initialApiLambdaGroups) {
        group.isApiLambda = true;
      }
      (0, import_build_utils3.debug)(
        JSON.stringify(
          {
            apiLambdaGroups: initialApiLambdaGroups.map((group) => ({
              pages: group.pages,
              isPrerender: group.isPrerenders,
              pseudoLayerBytes: group.pseudoLayerBytes
            })),
            pageLambdaGroups: initialPageLambdaGroups.map((group) => ({
              pages: group.pages,
              isPrerender: group.isPrerenders,
              pseudoLayerBytes: group.pseudoLayerBytes
            }))
          },
          null,
          2
        )
      );
      const combinedInitialLambdaGroups = [
        ...initialApiLambdaGroups,
        ...initialPageLambdaGroups
      ];
      await detectLambdaLimitExceeding(
        combinedInitialLambdaGroups,
        compressedPages
      );
      let apiLambdaGroupIndex = 0;
      let nonApiLambdaGroupIndex = 0;
      for (const group of combinedInitialLambdaGroups) {
        let routeIsApi;
        for (const page of group.pages) {
          if (["_app.js", "_document.js"].includes(page)) {
            continue;
          }
          if (page === "_error.js" && (static404Page && staticPages[static404Page] || hasPages404 && pages["404.js"])) {
            continue;
          }
          const pageFileName = import_path5.default.normalize(
            import_path5.default.relative(workPath, pages[page].fsPath)
          );
          const pathname = page.replace(/\.js$/, "");
          const routeIsDynamic = isDynamicRoute(pathname);
          routeIsApi = isApiPage(pageFileName);
          if (routeIsDynamic) {
            dynamicPages.push(normalizePage(pathname));
          }
          if (nonLambdaSsgPages.has(`/${pathname}`)) {
            continue;
          }
          const outputName = import_path5.default.join("/", entryDirectory, pathname);
          const lambdaGroupIndex = routeIsApi ? apiLambdaGroupIndex : nonApiLambdaGroupIndex;
          const lambdaGroups = routeIsApi ? apiLambdaGroups : pageLambdaGroups;
          const lastLambdaGroup = lambdaGroups[lambdaGroupIndex];
          let currentLambdaGroup = lastLambdaGroup;
          if (!currentLambdaGroup) {
            currentLambdaGroup = {
              pages: {},
              isApiLambda: !!routeIsApi,
              pseudoLayer: group.pseudoLayer,
              lambdaCombinedBytes: group.pseudoLayerBytes,
              lambdaIdentifier: import_path5.default.join(
                entryDirectory,
                `__NEXT_${routeIsApi ? "API" : "PAGE"}_LAMBDA_${lambdaGroupIndex}`
              )
            };
          }
          const addPageLambdaRoute = (escapedOutputPath) => {
            const pageLambdaRoute = {
              src: `^${escapedOutputPath.replace(
                /\/index$/,
                "(/|/index|)"
              )}/?$`,
              dest: `${import_path5.default.join("/", currentLambdaGroup.lambdaIdentifier)}`,
              headers: {
                "x-nextjs-page": outputName
              },
              check: true
            };
            if (routeIsDynamic) {
              dynamicPageLambdaRoutes.push(pageLambdaRoute);
              dynamicPageLambdaRoutesMap[outputName] = pageLambdaRoute;
            } else {
              pageLambdaRoutes.push(pageLambdaRoute);
            }
          };
          const { i18n: i18n3 } = routesManifest || {};
          if (i18n3) {
            addPageLambdaRoute(
              `[/]?(?:${i18n3.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})?${(0, import_escape_string_regexp3.default)(outputName)}`
            );
          } else {
            addPageLambdaRoute((0, import_escape_string_regexp3.default)(outputName));
          }
          if (page === "_error.js" || hasPages404 && page === "404.js") {
            page404Path = import_path5.default.join("/", entryDirectory, pathname);
          }
          currentLambdaGroup.pages[outputName] = {
            pageFileName,
            pageName: page
          };
          currentLambdaGroup.pseudoLayer[import_path5.default.join(import_path5.default.relative(baseDir, entryPath), pageFileName)] = compressedPages[page];
          lambdaGroups[lambdaGroupIndex] = currentLambdaGroup;
        }
        if (routeIsApi) {
          apiLambdaGroupIndex++;
        } else {
          nonApiLambdaGroupIndex++;
        }
      }
    } else {
      await Promise.all(
        pageKeys.map(async (page) => {
          if (["_app.js", "_document.js"].includes(page)) {
            return;
          }
          if (page === "_error.js" && (static404Page && staticPages[static404Page] || hasPages404 && pages["404.js"])) {
            return;
          }
          const pathname = page.replace(/\.js$/, "");
          if (isDynamicRoute(pathname)) {
            dynamicPages.push(normalizePage(pathname));
          }
          const pageFileName = import_path5.default.normalize(
            import_path5.default.relative(entryPath, pages[page].fsPath)
          );
          const launcher = launcherData.replace(
            /__LAUNCHER_PAGE_PATH__/g,
            JSON.stringify(requiresTracing ? `./${pageFileName}` : "./page")
          );
          const launcherFiles = {
            [import_path5.default.join(
              import_path5.default.relative(baseDir, entryPath),
              "___next_launcher.cjs"
            )]: new import_build_utils3.FileBlob({ data: launcher })
          };
          let lambdaOptions = {};
          if (config && config.functions) {
            lambdaOptions = await (0, import_build_utils3.getLambdaOptionsFromFunction)({
              sourceFile: await getSourceFilePathFromPage({
                workPath: entryPath,
                page
              }),
              config
            });
          }
          const outputName = normalizeIndexOutput(
            import_path5.default.join(entryDirectory, pathname),
            isServerMode
          );
          if (requiresTracing) {
            lambdas[outputName] = await createLambdaFromPseudoLayers({
              files: launcherFiles,
              layers: [
                Object.keys(pageTraces[page] || {}).reduce((prev, cur) => {
                  prev[cur] = tracedPseudoLayer?.pseudoLayer[cur];
                  return prev;
                }, {}),
                {
                  [import_path5.default.join(import_path5.default.relative(baseDir, entryPath), pageFileName)]: compressedPages[page]
                }
              ],
              handler: import_path5.default.join(
                import_path5.default.relative(baseDir, entryPath),
                "___next_launcher.cjs"
              ),
              operationType: getOperationType({
                prerenderManifest,
                pageFileName
              }),
              runtime: nodeVersion.runtime,
              nextVersion,
              ...lambdaOptions
            });
          } else {
            lambdas[outputName] = await createLambdaFromPseudoLayers({
              files: {
                ...launcherFiles,
                ...assets
              },
              layers: [
                {
                  [import_path5.default.join(import_path5.default.relative(baseDir, entryPath), "page.js")]: compressedPages[page]
                }
              ],
              handler: import_path5.default.join(
                import_path5.default.relative(baseDir, entryPath),
                "___next_launcher.cjs"
              ),
              operationType: getOperationType({ pageFileName }),
              // can only be API or Page
              runtime: nodeVersion.runtime,
              nextVersion,
              ...lambdaOptions
            });
          }
        })
      );
    }
    dynamicRoutes = await getDynamicRoutes({
      entryPath,
      entryDirectory,
      dynamicPages,
      isDev: false,
      routesManifest,
      omittedRoutes: omittedPrerenderRoutes,
      canUsePreviewMode,
      bypassToken: prerenderManifest.bypassToken || "",
      isServerMode,
      isAppPPREnabled: false
    }).then(
      (arr) => localizeDynamicRoutes(
        arr,
        dynamicPrefix,
        entryDirectory,
        staticPages,
        prerenderManifest,
        routesManifest,
        isServerMode,
        isCorrectLocaleAPIRoutes
      )
    );
    if (isSharedLambdas) {
      const launcherPath2 = import_path5.default.join(__dirname, "templated-launcher-shared.js");
      const launcherData2 = await (0, import_fs_extra6.readFile)(launcherPath2, "utf8");
      const completeDynamicRoutes = await getDynamicRoutes({
        entryPath,
        entryDirectory,
        dynamicPages,
        isDev: false,
        routesManifest,
        omittedRoutes: void 0,
        canUsePreviewMode,
        bypassToken: prerenderManifest.bypassToken || "",
        isServerMode,
        isAppPPREnabled: false
      }).then(
        (arr) => arr.map((route) => {
          route.src = route.src.replace("^", `^${dynamicPrefix}`);
          return route;
        })
      );
      await Promise.all(
        [...apiLambdaGroups, ...pageLambdaGroups].map(
          async function buildLambdaGroup(group) {
            const groupPageKeys = Object.keys(group.pages);
            const launcher = launcherData2.replace(
              "let page = {};",
              `let page = {};
              const url = require('url');

              ${routesManifest?.i18n ? `
                  function stripLocalePath(pathname) {
                  // first item will be empty string from splitting at first char
                  const pathnameParts = pathname.split('/')

                  ;(${JSON.stringify(
                routesManifest.i18n.locales
              )}).some((locale) => {
                    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
                      pathnameParts.splice(1, 1)
                      pathname = pathnameParts.join('/') || '/index'
                      return true
                    }
                    return false
                  })

                  return pathname
                }
                ` : `function stripLocalePath(pathname) { return pathname }`}

              page = function(req, res) {
                try {
                  const pages = {
                    ${groupPageKeys.map(
                (page) => `'${page}': () => require('./${import_path5.default.join(
                  "./",
                  group.pages[page].pageFileName
                )}')`
              ).join(",\n")}
                    ${""}
                  }
                  let toRender = req.headers['x-nextjs-page']

                  if (!toRender) {
                    try {
                      const { pathname } = url.parse(req.url)
                      toRender = stripLocalePath(pathname).replace(/\\/$/, '') || '/index'
                    } catch (_) {
                      // handle failing to parse url
                      res.statusCode = 400
                      return res.end('Bad Request')
                    }
                  }

                  let currentPage = pages[toRender]

                  if (
                    toRender &&
                    !currentPage
                  ) {
                    if (toRender.includes('/_next/data')) {
                      toRender = toRender
                        .replace(new RegExp('/_next/data/${escapedBuildId}/'), '/')
                        .replace(/\\.json$/, '')

                      toRender = stripLocalePath(toRender) || '/index'
                      currentPage = pages[toRender]
                    }

                    if (!currentPage) {
                      // for prerendered dynamic routes (/blog/post-1) we need to
                      // find the match since it won't match the page directly
                      const dynamicRoutes = ${JSON.stringify(
                completeDynamicRoutes.map((route) => ({
                  src: route.src,
                  dest: route.dest
                }))
              )}

                      for (const route of dynamicRoutes) {
                        const matcher = new RegExp(route.src)

                        if (matcher.test(toRender)) {
                          toRender = url.parse(route.dest).pathname
                          currentPage = pages[toRender]
                          break
                        }
                      }
                    }
                  }

                  if (!currentPage) {
                    console.error(
                      "pages in lambda:",
                      Object.keys(pages),
                      "page header received:",
                      req.headers["x-nextjs-page"]
                    );
                    throw new Error(
                      "Failed to find matching page in lambda for: " +
                        JSON.stringify(
                          {
                            toRender,
                            url: req.url,
                            header: req.headers["x-nextjs-page"],
                          },
                          null,
                          2
                        )
                    );
                  }

                  const mod = currentPage()
                  const method = mod.render || mod.default || mod

                  return method(req, res)
                } catch (err) {
                  console.error('Unhandled error during request:', err)
                  throw err
                }
              }
              `
            );
            const launcherFiles = {
              [import_path5.default.join(
                import_path5.default.relative(baseDir, entryPath),
                "___next_launcher.cjs"
              )]: new import_build_utils3.FileBlob({ data: launcher })
            };
            for (const page of groupPageKeys) {
              pageLambdaMap[page] = group.lambdaIdentifier;
            }
            const operationType = getOperationType({
              group,
              prerenderManifest
            });
            lambdas[group.lambdaIdentifier] = await createLambdaFromPseudoLayers({
              files: {
                ...launcherFiles,
                ...assets
              },
              layers: [group.pseudoLayer],
              handler: import_path5.default.join(
                import_path5.default.relative(baseDir, entryPath),
                "___next_launcher.cjs"
              ),
              operationType,
              runtime: nodeVersion.runtime,
              nextVersion
            });
          }
        )
      );
    }
    if (hasLambdas) {
      console.timeEnd(allLambdasLabel);
    }
    const prerenderRoute = onPrerenderRoute({
      appDir,
      pagesDir,
      hasPages404,
      static404Page,
      pageLambdaMap,
      lambdas,
      experimentalStreamingLambdaPaths: void 0,
      isServerMode,
      prerenders,
      entryDirectory,
      routesManifest,
      prerenderManifest,
      appPathRoutesManifest,
      isSharedLambdas,
      canUsePreviewMode,
      isAppPPREnabled: false
    });
    await Promise.all(
      Object.keys(prerenderManifest.staticRoutes).map(
        (route) => prerenderRoute(route, {})
      )
    );
    await Promise.all(
      Object.keys(prerenderManifest.fallbackRoutes).map(
        (route) => prerenderRoute(route, { isFallback: true })
      )
    );
    await Promise.all(
      Object.keys(prerenderManifest.blockingFallbackRoutes).map(
        (route) => prerenderRoute(route, { isBlocking: true })
      )
    );
    if (static404Page && canUsePreviewMode) {
      await Promise.all(
        Array.from(omittedPrerenderRoutes).map(
          (route) => prerenderRoute(route, { isOmitted: true })
        )
      );
    }
    if (!(routesManifest && routesManifest.dataRoutes)) {
      [
        ...Object.entries(prerenderManifest.fallbackRoutes),
        ...Object.entries(prerenderManifest.blockingFallbackRoutes)
      ].forEach(
        ([
          ,
          {
            dataRouteRegex,
            dataRoute,
            prefetchDataRouteRegex,
            prefetchDataRoute
          }
        ]) => {
          if (!dataRoute || !dataRouteRegex)
            return;
          dataRoutes.push({
            // Next.js provided data route regex
            src: dataRouteRegex.replace(
              /^\^/,
              `^${appMountPrefixNoTrailingSlash}`
            ),
            // Location of lambda in builder output
            dest: import_path5.default.posix.join(entryDirectory, dataRoute),
            check: true
          });
          if (!prefetchDataRoute || !prefetchDataRouteRegex)
            return;
          dataRoutes.push({
            src: prefetchDataRouteRegex.replace(
              /^\^/,
              `^${appMountPrefixNoTrailingSlash}`
            ),
            dest: import_path5.default.posix.join(entryDirectory, prefetchDataRoute),
            check: true
          });
        }
      );
    }
  }
  if (!isSharedLambdas) {
    omittedPrerenderRoutes.forEach((routeKey) => {
      const routeFileNoExt = import_path5.default.posix.join(
        entryDirectory,
        routeKey === "/" ? "/index" : routeKey
      );
      if (typeof lambdas[routeFileNoExt] === void 0) {
        throw new import_build_utils3.NowBuildError({
          code: "NEXT__UNKNOWN_ROUTE_KEY",
          message: `invariant: unknown lambda ${routeKey} (lookup: ${routeFileNoExt}) | please report this immediately`
        });
      }
      delete lambdas[routeFileNoExt];
    });
  }
  const mergedDataRoutesLambdaRoutes = [];
  const mergedDynamicRoutesLambdaRoutes = [];
  if (isSharedLambdas) {
    for (let i = 0; i < dynamicRoutes.length; i++) {
      const route = dynamicRoutes[i];
      mergedDynamicRoutesLambdaRoutes.push(route);
      const { pathname } = import_url2.default.parse(route.dest);
      if (pathname && pageLambdaMap[pathname]) {
        mergedDynamicRoutesLambdaRoutes.push(
          dynamicPageLambdaRoutesMap[pathname]
        );
      }
    }
    for (let i = 0; i < dataRoutes.length; i++) {
      const route = dataRoutes[i];
      mergedDataRoutesLambdaRoutes.push(route);
      const { pathname } = import_url2.default.parse(route.dest);
      if (pathname && pageLambdaMap[pathname] && dynamicPageLambdaRoutesMap[pathname]) {
        mergedDataRoutesLambdaRoutes.push(dynamicPageLambdaRoutesMap[pathname]);
      }
    }
  }
  const { staticFiles, publicDirectoryFiles, staticDirectoryFiles } = await getStaticFiles(entryPath, entryDirectory, outputDirectory);
  const { i18n } = routesManifest || {};
  return {
    output: {
      ...publicDirectoryFiles,
      ...lambdas,
      // Prerenders may override Lambdas -- this is an intentional behavior.
      ...prerenders,
      ...staticPages,
      ...staticFiles,
      ...staticDirectoryFiles,
      ...privateOutputs.files
    },
    wildcard: wildcardConfig,
    images: getImagesConfig(imagesManifest),
    /*
      Desired routes order
      - Runtime headers
      - User headers and redirects
      - Runtime redirects
      - Runtime routes
      - Check filesystem, if nothing found continue
      - User rewrites
      - Builder rewrites
    */
    routes: [
      // force trailingSlashRedirect to the very top so it doesn't
      // conflict with i18n routes that don't have or don't have the
      // trailing slash
      ...trailingSlashRedirects,
      ...privateOutputs.routes,
      ...i18n ? [
        // Handle auto-adding current default locale to path based on
        // $wildcard
        // This is split into two rules to avoid matching the `/index` route as it causes issues with trailing slash redirect
        {
          src: `^${import_path5.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(?:/.*|$))$`,
          // we aren't able to ensure trailing slash mode here
          // so ensure this comes after the trailing slash redirect
          dest: `${entryDirectory !== "." ? import_path5.default.posix.join("/", entryDirectory) : ""}$wildcard${trailingSlash ? "/" : ""}`,
          continue: true
        },
        {
          src: `^${import_path5.default.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(?:/.*|$))(.*)$`,
          // we aren't able to ensure trailing slash mode here
          // so ensure this comes after the trailing slash redirect
          dest: `${entryDirectory !== "." ? import_path5.default.join("/", entryDirectory) : ""}$wildcard/$1`,
          continue: true
        },
        // Handle redirecting to locale specific domains
        ...i18n.domains && i18n.domains.length > 0 && i18n.localeDetection !== false ? [
          {
            src: `^${import_path5.default.join("/", entryDirectory)}/?(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})?/?$`,
            locale: {
              redirect: i18n.domains.reduce(
                (prev, item) => {
                  prev[item.defaultLocale] = `http${item.http ? "" : "s"}://${item.domain}/`;
                  if (item.locales) {
                    item.locales.map((locale) => {
                      prev[locale] = `http${item.http ? "" : "s"}://${item.domain}/${locale}`;
                    });
                  }
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        // Handle redirecting to locale paths
        ...i18n.localeDetection !== false ? [
          {
            // TODO: if default locale is included in this src it won't
            // be visitable by users who prefer another language since a
            // cookie isn't set signaling the default locale is
            // preferred on redirect currently, investigate adding this
            src: "/",
            locale: {
              redirect: i18n.locales.reduce(
                (prev, locale) => {
                  prev[locale] = locale === i18n.defaultLocale ? `/` : `/${locale}`;
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        {
          src: `^${import_path5.default.join("/", entryDirectory)}$`,
          dest: `${import_path5.default.join("/", entryDirectory, i18n.defaultLocale)}`,
          continue: true
        },
        // Auto-prefix non-locale path with default locale
        // note for prerendered pages this will cause
        // x-now-route-matches to contain the path minus the locale
        // e.g. for /de/posts/[slug] x-now-route-matches would have
        // 1=posts%2Fpost-1
        {
          src: `^${import_path5.default.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(?:/.*|$))(.*)$`,
          dest: `${import_path5.default.join("/", entryDirectory, i18n.defaultLocale)}/$1`,
          continue: true
        }
      ] : [],
      ...headers,
      ...redirects,
      ...beforeFilesRewrites,
      // Make sure to 404 for the /404 path itself
      ...i18n ? [
        {
          src: `${import_path5.default.join("/", entryDirectory, "/")}(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})?[/]?404/?`,
          status: 404,
          continue: true
        }
      ] : [
        {
          src: import_path5.default.join("/", entryDirectory, "404/?"),
          status: 404,
          continue: true
        }
      ],
      // Make sure to 500 when visiting /500 directly for static 500
      ...!hasStatic500 ? [] : i18n ? [
        {
          src: `${import_path5.default.join("/", entryDirectory, "/")}(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})?[/]?500`,
          status: 500,
          continue: true
        }
      ] : [
        {
          src: import_path5.default.join("/", entryDirectory, "500"),
          status: 500,
          continue: true
        }
      ],
      // Next.js page lambdas, `static/` folder, reserved assets, and `public/`
      // folder
      { handle: "filesystem" },
      // map pages to their lambda
      ...pageLambdaRoutes.filter((route) => {
        if ("headers" in route) {
          let page = route.headers?.["x-nextjs-page"];
          page = page === "/index" ? "/" : page;
          if (prerenders[page]) {
            return false;
          }
        }
        return true;
      }),
      // ensure the basePath prefixed _next/image is rewritten to the root
      // _next/image path
      ...routesManifest?.basePath ? [
        {
          src: import_path5.default.join("/", entryDirectory, "_next/image/?"),
          dest: "/_next/image",
          check: true
        }
      ] : [],
      // No-op _next/data rewrite to trigger handle: 'rewrites' and then 404
      // if no match to prevent rewriting _next/data unexpectedly
      {
        src: import_path5.default.join("/", entryDirectory, "_next/data/(.*)"),
        dest: import_path5.default.join("/", entryDirectory, "_next/data/$1"),
        check: true
      },
      // These need to come before handle: miss or else they are grouped
      // with that routing section
      ...afterFilesRewrites,
      // make sure 404 page is used when a directory is matched without
      // an index page
      { handle: "resource" },
      ...fallbackRewrites,
      { src: import_path5.default.join("/", entryDirectory, ".*"), status: 404 },
      // We need to make sure to 404 for /_next after handle: miss since
      // handle: miss is called before rewrites and to prevent rewriting /_next
      { handle: "miss" },
      {
        src: import_path5.default.join(
          "/",
          entryDirectory,
          "_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media)/.+"
        ),
        status: 404,
        check: true,
        dest: "$0"
      },
      // remove locale prefixes to check public files
      ...i18n ? [
        {
          src: `^${import_path5.default.join("/", entryDirectory)}/?(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})/(.*)`,
          dest: `${import_path5.default.join("/", entryDirectory, "/")}$1`,
          check: true
        }
      ] : [],
      // for non-shared lambdas remove locale prefix if present
      // to allow checking for lambda
      ...isSharedLambdas || !i18n ? [] : [
        {
          src: `${import_path5.default.join("/", entryDirectory, "/")}(?:${i18n?.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})/(.*)`,
          dest: "/$1",
          check: true
        }
      ],
      // routes that are called after each rewrite or after routes
      // if there no rewrites
      { handle: "rewrite" },
      // /_next/data routes for getServerProps/getStaticProps pages
      ...isSharedLambdas ? mergedDataRoutesLambdaRoutes : dataRoutes,
      // ensure we 404 for non-existent _next/data routes before
      // trying page dynamic routes
      {
        src: import_path5.default.join("/", entryDirectory, "_next/data/(.*)"),
        dest: import_path5.default.join("/", entryDirectory, "404"),
        status: 404,
        check: true
      },
      // re-check page routes to map them to the lambda
      ...pageLambdaRoutes,
      // Dynamic routes (must come after dataRoutes as dataRoutes are more
      // specific)
      ...isSharedLambdas ? mergedDynamicRoutesLambdaRoutes : dynamicRoutes,
      // routes to call after a file has been matched
      { handle: "hit" },
      // Before we handle static files we need to set proper caching headers
      {
        // This ensures we only match known emitted-by-Next.js files and not
        // user-emitted files which may be missing a hash in their filename.
        src: import_path5.default.join(
          "/",
          entryDirectory,
          `_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapedBuildId})/.+`
        ),
        // Next.js assets contain a hash or entropy in their filenames, so they
        // are guaranteed to be unique and cacheable indefinitely.
        headers: {
          "cache-control": `public,max-age=${MAX_AGE_ONE_YEAR},immutable`
        },
        continue: true,
        important: true
      },
      // error handling
      ...isLegacy ? [] : [
        // Custom Next.js 404 page
        { handle: "error" },
        ...i18n && (static404Page || hasIsr404Page) ? [
          {
            src: `${import_path5.default.join(
              "/",
              entryDirectory,
              "/"
            )}(?<nextLocale>${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(/.*|$)`,
            dest: "/$nextLocale/404",
            status: 404,
            caseSensitive: true
          },
          {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            dest: `/${i18n.defaultLocale}/404`,
            status: 404
          }
        ] : [
          isSharedLambdas ? {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            // if static 404 is not present but we have pages/404.js
            // it is a lambda due to _app getInitialProps
            dest: import_path5.default.join(
              "/",
              static404Page ? static404Page : pageLambdaMap[page404Path]
            ),
            status: 404,
            ...static404Page ? {} : {
              headers: {
                "x-nextjs-page": page404Path
              }
            }
          } : {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            // if static 404 is not present but we have pages/404.js
            // it is a lambda due to _app getInitialProps
            dest: static404Page ? import_path5.default.join("/", static404Page) : import_path5.default.join(
              "/",
              entryDirectory,
              hasPages404 && lambdas[import_path5.default.join("./", entryDirectory, "404")] ? "404" : "_error"
            ),
            status: 404
          }
        ],
        // static 500 page if present
        ...!hasStatic500 ? [] : i18n ? [
          {
            src: `${import_path5.default.join(
              "/",
              entryDirectory,
              "/"
            )}(?<nextLocale>${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(/.*|$)`,
            dest: "/$nextLocale/500",
            status: 500
          },
          {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            dest: `/${i18n.defaultLocale}/500`,
            status: 500
          }
        ] : [
          {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            dest: import_path5.default.join("/", entryDirectory, "/500"),
            status: 500
          }
        ]
      ]
    ],
    framework: { version: nextVersion }
  };
};
var diagnostics = async ({
  config,
  entrypoint,
  workPath,
  repoRootPath
}) => {
  const entryDirectory = import_path5.default.dirname(entrypoint);
  const entryPath = import_path5.default.join(workPath, entryDirectory);
  const outputDirectory = import_path5.default.join("./", config.outputDirectory || ".next");
  const basePath = repoRootPath || workPath;
  const diagnosticsEntrypoint = import_path5.default.relative(basePath, entryPath);
  (0, import_build_utils3.debug)(
    `Reading diagnostics file in diagnosticsEntrypoint=${diagnosticsEntrypoint}`
  );
  return {
    // Collect output in `.next/diagnostics`
    ...await (0, import_build_utils3.glob)(
      "*",
      import_path5.default.join(basePath, diagnosticsEntrypoint, outputDirectory, "diagnostics")
    ),
    // Collect `.next/trace` file
    ...await (0, import_build_utils3.glob)(
      "trace",
      import_path5.default.join(basePath, diagnosticsEntrypoint, outputDirectory)
    )
  };
};
var prepareCache = async ({
  workPath,
  repoRootPath,
  entrypoint,
  config = {}
}) => {
  (0, import_build_utils3.debug)("Preparing cache...");
  const entryDirectory = import_path5.default.dirname(entrypoint);
  const entryPath = import_path5.default.join(workPath, entryDirectory);
  const outputDirectory = import_path5.default.join("./", config.outputDirectory || ".next");
  const nextVersionRange = await getNextVersionRange(entryPath);
  const isLegacy = nextVersionRange && isLegacyNext(nextVersionRange);
  if (isLegacy) {
    return {};
  }
  (0, import_build_utils3.debug)("Producing cache file manifest...");
  const isMonorepo = repoRootPath && repoRootPath !== workPath;
  const cacheBasePath = repoRootPath || workPath;
  const cacheEntrypoint = import_path5.default.relative(cacheBasePath, entryPath);
  const cache = {
    ...await (0, import_build_utils3.glob)(
      isMonorepo ? "**/node_modules/**" : import_path5.default.join(cacheEntrypoint, "node_modules/**"),
      cacheBasePath
    ),
    ...await (0, import_build_utils3.glob)(
      import_path5.default.join(cacheEntrypoint, outputDirectory, "cache/**"),
      cacheBasePath
    )
  };
  (0, import_build_utils3.debug)("Cache file manifest produced");
  return cache;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MAX_AGE_ONE_YEAR,
  build,
  diagnostics,
  htmlContentType,
  prepareCache,
  version
});
/*! Bundled license information:

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)
*/
